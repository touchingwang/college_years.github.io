[{"title":"Mybatis知识笔记","date":"2021-03-12T13:31:24.945Z","path":"2021/03/12/Mybatis/","text":"Mybatis-2.10环境： JDK 1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。最好的方式：看官网文档； 1、简介1.1、什么是 Mybatis 是一款优秀的持久层框架 支持定制化 SQL、存储过程以及高级映射架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 如何获取 Mybatis maven仓库 1.2、持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io 文件持久化 为什么需要持久化？ 有一些对象，不能让他丢掉 内存太贵了 1.3、持久层Dao层(Data Access Objects数据持久层对象)，Service层，Controller层… 完成持久化工作的代码块 层界限十分明显。 1.4、为什么需要Mybatis? 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。技术没有高低之分 优点： 简单易学 灵活 sql 的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组件维护 提供 xml 标签，支持编写动态 sql 使用的人多 Spring SpringMVC SpringBoot 2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 连接数据库会出现serverTimeZone设置时区问题将其改为Asia/Shanghai 2.1、搭建环境搭建数据库 12345678910111213CREATE DATABASE `mybatis`;SHOW DATABASES;USE `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;213123&#x27;) 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!----&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、创建一个模块123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 12345678910111213141516171819202122//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static&#123; try &#123; //使用Myabatis第一步 获取sqlSessionFactory对象 String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。 //SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 //而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 public static SqlSession getSqlSession()&#123; return SqlSessionFactory sqlSessionFactory.openSession(); &#125;&#125; 2.3、编写代码 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//实体类public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wang.dao.UserDao&quot;&gt;&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2.4、测试注意点：org.apache.ibatis.binding.BindingException: Type interface com.wang.dao.UserDao is not known to the MapperRegistry.（UserDao类型接口没有在注册中心显示） MapperRegistry是什么？ 核心配置文件中注册 mappers junit 测试 12345678910111213141516@Testpublic void test()&#123; //第一步：获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一:getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close();&#125; 可能会遇到的问题： 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD1、namespacenamespace中的包命要和 Dao/mapper 接口的包名一致！ 2、select选择，查询语句； id：就是对应的namespace中的方法名； resultType：Sql 语句执行的返回值！ parameterType：参数类型！ 编写接口 12//根据ID查询用户User getUserById(Int id); 编写对应的mapper中的sql语句 1234&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 1234567891011@Testpublic void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close();&#125; 3、Insert123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt; 4、update123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;&lt;/update&gt; 5、Delete123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;;&lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范 NullPointerException，没有注册到资源！ 输出的xml文件中存在中文乱码的问题 maven资源没有导出问题！ 7、万能map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 123//万能的Mapint addUser2(Map&lt;String,Object&gt; map); 1234&lt;!--对象中的属性，可以直接取出来 传递map的key--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id,pwd) values (#&#123;userid&#125;,#&#123;password&#125;);&lt;/insert&gt; 123456789101112131415@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,5); map.put(&quot;password&quot;,&quot;22223333&quot;); mapper.addUser2(map); sqlSession.commit(); sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！【parameterType=”map“】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object“】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8、思考题模糊查询怎么写？ Java代码执行的时候，传递通配符%% 1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符！ 1select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot; 4、配置解析1、核心配置文件 mybatis-config.xml Mybatis 的配置文件包含了会深深影响Mybatis 行为和设置的属性信息 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 2、环境配置（enviroments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是JDBC，连接池：POOLED 3、属性（property）我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 意思是可以的Java属性文件中配置，也可以在db.properties中去配置【db.properties】 将properties标签放在后面，出现这段话的意思是，在xml中，所有的标签都可以规定其顺序，即按照它所给的标签顺序写入，否则会报错 编写一个配置文件 db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF8username=rootpassword=123456 在核心配置文件中映入 12345&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/properties&gt; 可以直接引入外部配置文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，官方文档说首先读取在 properties 元素体内指定的属性。意思是先读取标签元素体内的属性，在去读取外部文件的属性，这样外部的会把标签内的覆盖掉，这样就会读取到外部配置文件的属性。 4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.wang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，Mybatis 会在包名下面搜索需要的Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！ 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.wang.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种不行，如果非要该，需要在实体上增加注解 12@Alias(&quot;user&quot;)public class User &#123;&#125; 5、设置这是Mybatis 中极为重要的调整设置，它们会改变 Mybatis 的运行时行为。 6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用 mapper 7、映射器（mapper）MapperRegistty：注册绑定我们的Mapper文件； 方式一： 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/wang/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二：使用 class 文件绑定注册 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;package name=&quot;com.wang.dao&quot; /&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口和 UserMappper.xml 改为一致！并且放在同一个包下！ 3、生命周期和作用域 作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuider： 一旦创建了SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 连接池的一个连接（请求）! SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用。 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题1、问题数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 12345public class User &#123; private int id; private String name; private String password;&#125; 测试出现问题 123//select * from mybatis.user where id = #&#123;id&#125;//类型处理器//select id,name,pwd from mybatis.user where id = #&#123;id&#125; 解决方法： 起别名 2、resultMap结果集映射 12id name pwdid name password 1234567&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。 6、日志6.1、日志工程如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout，debug 现在：日志工厂！ SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING 在Mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ 6.2、Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入LOG4J的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/wang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 12345 &lt;settings&gt; &lt;!--标准的日志工厂实现--&gt;&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; Log4j的使用！直接测试运行刚才的查询 简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 123logger.info(&quot;info:进入了testLog4j&quot;);logger.debug(&quot;debug:进入了testLog4j&quot;);logger.error(&quot;error:进入了testLog4j&quot;); 7、分页思考：为什么要分页？ 减少数据的处理量 7.1、使用Limit分页123语法:SELECT * FORM lIMIT startIndex,pageSize;select *from user limit 2,2; 笔记： 0,3 意思是每页显示 3 个从第0个开始查询 使用Mybatis实现分页，核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!--分页--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 这里返回的为resultMap结果集映射，其中的UserMap为对应的章节的映射，我这里就出错了。 测试 12345678910111213141516@Testpublic void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,0); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userByLimit = mapper.getUserByLimit(map); for (User user : userByLimit) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.2、RowBounds分页不再使用SQL实现分页 接口 12//分页2List&lt;User&gt; getUserByRowBounds(); mapper.xml 1234&lt;!--分页2--&gt;&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 123456789101112131415@Testpublic void getUserByRowBounds()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.wang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.3、分页插件 了解即可，万一以后公司的架构师，说要使用，你需要知道它是什么东西！ 8、使用注解开发8.1、面向接口编程大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因：==解耦==，可扩展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得很容易，规范性很好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现租户的，对系统来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体（abstract class） 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface） 一个体有可能有多个抽象面。抽象面与抽象面是由区别的。 三个面向区别 面向对象是指，我们考虑问题是，以对象为单位，考虑它的属性及方法。 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现。 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题。更多的体现就是对系统整体的构架。 8.2、使用注解开发 注解在接口上实现 12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口！ 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ 8.3、注解的CRUD我们可以在工具类创建的时候实现自动提交事务！(util里） 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注解 123456789101112131415161718public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解 @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserByID(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name = #&#123;name&#125;,pwd=#&#123;password&#125; where id = &#123;#id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);&#125; 测试类 【注意：我们必须要将接口注册绑定到我们的核心配置文件中！】 8.4、关于@Param（）注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的@Param（）中设定的属性名！ #{} ${}区别 9、Lombok12Project Lombok is a java library that automatically plugs插件 into your editor（在你的代码里面） and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs 插件 build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 12345&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;version&gt;1.18.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 在实体类上加注解 123@Data@AllArgsConstructor@NoArgsConstructor 12345678910111213141516@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows 说明： 123456@Data：无参构造、get、set、tostring、hashcode、equals@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode@ToString@Getter 10、多对一处理多对一： 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 对于老师而言，集合，一个老师，有很多学生 SQL： 123456789101112131415161718192021222324252627CREATE TABLE &#96;teacher&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INDELETE FROM &#96;mybatis&#96;.&#96;user&#96; WHERE &#96;id&#96; &#x3D; &#39;id&#39; ;TO teacher(&#96;id&#96;, &#96;name&#96;) VALUES (1, &#39;秦老师&#39;); CREATE TABLE &#96;student&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, &#96;tid&#96; INT(10) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;fktid&#96; (&#96;tid&#96;), CONSTRAINT &#96;fktid&#96; FOREIGN KEY (&#96;tid&#96;) REFERENCES &#96;teacher&#96; (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;); 测试环境搭建 导入 lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或文件！【方式很多，随心选】 测试查询是否能够成功！ 按照查询嵌套处理12345678910111213141516171819&lt;!-- 思路： 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 按照结果嵌套处理1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 回顾Mysql多对一查询方式： 子查询 连表查询 11、一对多处理比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系 环境搭建，和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结构嵌套处理1234567891011121314151617181920&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection javatype=&quot;&quot; 指定属性的类型！ 集合中的泛型信息，我们使用oftype获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理1234567891011&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudents2&quot;&gt; select * from mybatis.teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudents2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志，建议使用Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ 12、动态SQL==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态SQL这一特性可以彻底摆脱这种痛苦 1234ifchoose (when, otherwise)trim (where, set)foreach 搭建环境1234567CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口 和 Mapper.XML文件 if123456789&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; choose(when, otherwise)1234567891011121314select * from mybatis.blog&lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; trim(where,set)123456789select * from mybatis.blog&lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/where&gt; ==所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码== if where，set，choose，when SQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 1234select * from mybatis.blog&lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;&lt;/where&gt; 在需要使用的地方使用 Include 标签引用即可 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 注意事项： 最好基于单表来定义SQL片段！ 不要存在 where 标签 Foreach1234567891011&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map，这map中可以存在一个集合！ --&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and(&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 现在 Mysql 中写出完整的SQL，在对应的去修改成为我们的动态SQL实现通用即可！ 13、缓存13.1、简介12查询 ： 连接数据库 ， 耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--》内存：缓存 什么是缓存【cache】？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地指定和配置缓存。缓存可以极大的提高查询效率。 Mybatis系统中默认定义了二级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.3、一级缓存 一级缓存也交本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库； 测试步骤： 开启日志！ 测试在一个Session中查询两次记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于 namspace 级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存指定数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 12&lt;!--在当前Mapper.xml中开启二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题：如果只写&lt;cache/&gt;会出现序列化缓存的问题，如果开启了eadOnly=&quot;true&quot;就可以了 1Caused by: java.io.NotSerializableException: com.wang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ 13.5、缓存原理 13.6、自定义缓存-ehcache1Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用 ehcache，先要导包！ 在 mapper 中指定使用我们的Ehcache 缓存实现！ Redis 数据库来做缓存！","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"}]},{"title":"pat1002","date":"2021-03-12T05:23:22.295Z","path":"2021/03/12/pat1002/","text":"1002. 写出这个数 (20) [字符串处理]读⼊⼀个⾃然数n，计算其各位数字之和，⽤汉语拼⾳写出和的每⼀位数字。 输⼊格式：每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。这⾥保证n⼩于10100。 输出格式： 在⼀⾏内输出n的各位数字之和的每⼀位，拼⾳数字间有1 空格，但⼀⾏中最后⼀个拼⾳数字后没有空 格。 输⼊样例： 11234567890987654321123456789 输出样例： 1yi san wu 分析：⽤string接收输⼊，string的每⼀位数字累加到sum⾥⾯，再将sum转化为string类型的num，对 num的每⼀位输出对应中⽂拼⾳～ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1001","date":"2021-03-11T15:01:17.326Z","path":"2021/03/11/pat1001/","text":"1001. 害死⼈不偿命的(3n+1)猜想(15) [模拟]卡拉兹(Callatz)猜想： 对任何⼀个⾃然数n，如果它是偶数，那么把它砍掉⼀半；如果它是奇数，那么把(3n+1)砍掉⼀半。这 样⼀直反复砍下去，最后⼀定在某⼀步得到n=1。卡拉兹在1950年的世界数学家⼤会上公布了这个猜 想，传说当时耶鲁⼤学师⽣⻬动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学⽣们⽆⼼学 业，⼀⼼只证(3n+1)，以⾄于有⼈说这是⼀个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题⽬不是证明卡拉兹猜想，⽽是对给定的任⼀不超过1000的正整数n，简单地数⼀下，需要 多少步（砍⼏下）才能得到n=1？ 输⼊格式： 每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。 输出格式： 输出从n计算到1需要的步数。 输⼊样例： 13 输出样例： 15 分析：count从0开始统计需要的步数，(n % 2 != 0) 表示n为奇数，当n为奇数，就令n = 3*n+1；之后将 其砍掉⼀半，步数count+1，直到n == 1为⽌，最后输出count～ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int num=0,n; cin &gt;&gt;n; while(n!=1)&#123; if(n%2)n=(3*n+1); n=n/2; num++; &#125; cout&lt;&lt;num; return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"数据库学习之《mysql必知必会》","date":"2021-02-28T03:32:20.437Z","path":"2021/02/28/数据库学习之《mysql必知必会》/","text":"之前买了一本《MySQL必知必会》，最终拖拖拉拉用来一个星期的时间才把它看完，关于此书我觉得前面没有多大的难度，和《计算机网络自顶向下》 比起 还是很简单的，在我觉得比较困难的是存储过程，触发器的那几章，还有的是懂得了一门语言不是重点，重要的是要会使用和经常使用，这两点我还不行。下面我说说学习《MySQL必知必会》遇到的几个问题。 关于导入《MySQL必知必会》样例表的问题。一开始我并不打算使用这本书的数据库，后来发现有些知识点比较难懂于是又开始去寻找如何下载，下面是我的总结。 首先去网页下载两个SQL脚本文件，所需要获得和运行的一切东西都可以在https://forta.com/books/0672327120 上找到。 之后会有这个 点击自己选择一个名字 如text，则底下会出现一个这个 再接下来点击进入其中选择schemas 创建一个数据源，这一步和简单，你可以选择在命令行中进行，根据MySQL必知必会，选择名字crashcourse比较好， 然后再在菜单栏中，选择File-&gt;Open SQL Script，分别找到create.sql脚本，点击下图位置运行 对于populate.sql文件，重复导入脚本以及运行步骤即可 最后选中数据源并右键，选择Refresh All！！！（很重要） 今天学到了MySQL第十四章，对子查询这一步感到惊叹，能想出这样的方法— 真是老牛下蛋，牛逼坏了。","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://example.com/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"用故事讲解md","date":"2021-02-28T03:27:14.304Z","path":"2021/02/28/用故事讲解Markdown/","text":"Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬 John Gruber 和 Aaron Swartz 。2010年，确定了其标准语法 CommonMark，2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站… 人人都应学Markdown1.1Markdown是什么​ Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬John Gruber和 Aaron Swartz。Makedown本质是一个标记语言，与HTML非常相似，兼容HTML。起初用于网络写作，现在记笔记，写文档，写README.md。2010年，确定了其标准语法 CommonMark，虽然有了定义但是标准语法的核心功能还是太少了，于是不断扩展，知道2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站。 1.2推荐使用​ 需要文字排版但无特殊要求 ​ 可以很方便的转换位Word 1.3如何学习使用Markdown 编写Markdown源码 &gt; 编辑器 &gt; 各种样式 语法学习 2.1基础语法所有标记符号都必须是半角标点符号 标题 语法：”# + 空格 + 标题内容” 行首插入 # “#”的个数=标题的等级 建议在#后面加个空格 支持最多六个标题 粗体和斜体 粗体，由两个*或两个_包裹 斜体，由一个*或一个_包裹 列表 有序列表，数字符号 + 英文句号 + 空格 + 列表内容 有序列表1 有序列表2 无序列表，-*/+/- + 空格 + 列表内容 无序列表1 无序列表2 嵌套列表，下层列表前按Tab键 有序列表和无序列表可以互相嵌套 分割线 三个或三个以上的_来标记 图片 语法，！[图片代替文字](图片地址) 图片替代文字不是必须，可以为空 图片地址，可以是本地路径，也可以是网络路径 本地图片支持相对路径和绝对路径两种 链接 文字链接 语法，[链接文字](链接地址) 链接过多后，可读性变差 引用链接 语法，[链接文字] [链接标记][链接标记]: 链接地址 链接标记可以是字母，数字，空格和标点符号 链接标记不区分大小写 定义的链接可任意位置放置，建议放在页尾 链接地址为网络地址需以http/https开头 网址链接 语法，&lt;url 或邮箱地址&gt; 无需以 http/https 开头 行内代码与代码块 行内代码：用包裹 代码块：以tab键或4个空格开头 1echo &quot;hello word&quot; 引用 语法，&gt; + 引用内容 在引用中可以嵌套引用 在引用中可以使用其他的 Markdown 语法 扩展语法2.1删除线 语法，~~被删除的文字~~ 2.2表情符号 语法，使用:包裹表情代码，:表情代码 表情符号代码，请参考webpagefx，或搜索Markdown emoji code 2.3表格 语法 1234|表头1|表头2|表头3||-|--|---||内容1|内容2|内容3||内容1|内容2|内容3| 表头1 表头2 表头3 内容1 内容2 内容3 内容1 内容2 内容3 2.4任务列表 语法，- + 空格 + [空格] + 空格 +文字内容 未勾选，-[] 已勾选，-[X/x] 语法说明 x可大写或小写，但有些编辑器不支持大写，故推荐使用小写的x 2.5围栏代码块 使用规范 使用连续的3个` 行内代码使用`包裹 1echo &#x27;hello word&#x27; 2.6锚点[锚点描述](#锚点名) 2.7内联数学公式 语法，$数学公式$ 快捷键，control + M $f(x,y)=\\frac{x}{y}$","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"使用命令窗口发送邮件","date":"2021-02-28T03:18:13.645Z","path":"2021/02/28/使用命令窗口发送邮件/","text":"学习笔记之前建立了一个hexo的博客，但是两个月没用出现了，结果出现了’使用子域名作为Github Pages的域名导致访问不了’的问题,对于才接触的我也没有解决的办法，只好重新安装了一个，以后如果再出现这个问题要解决掉，最近正在学计算机网络的应用层感觉用命令窗口发送qq邮箱很有趣，于是打算写一篇关于如何用命令窗口进行与邮件服务器进行链接的文章。我是使用win10 用qq邮箱进行发送的，如果以后有机会用163进行一次。 开启邮箱服务首先先开启qq邮箱的独立密码，进入设置-账户-独立密码，使邮箱开启POP3/SMTP，进入设置-账户-开启服务 接下来打开windows计算机上的telnet服务，打开控制面板-打功选中Telnet客户端、Telnet服务器，然后确定，等待完成 开始发送先打开命令窗口，输入 telnet smtp.qq.com 25,回复220，如果不是查看telnet服务是否开启 接着输入helo qq(后缀.com有时加有时不用)如果成功，服务器返回 250 ，不成功换一下 登录认证输入auth login，，会返回类似于：334 VXNlcm5hbWU6 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车回复334成功，其他失败 如果不知道可以 进行简单的代码运行得到1234import sun.misc.BASE64Encoder;public static void main(String[] args)&#123; System.out.println(Base64.encodeBase(&quot;xxxxx@qq.com&quot;.getBytes())); &#125; 输出即为。输入时如果太麻烦鼠标右键的话会直接粘贴，比较方便。 接下来输入独立密码的base64编码之后的字符串然后回车 回复235 Authentication successful成功，如果失败可能是因为独立密码失效 编写邮件输入 mail from:&lt;你自己的邮箱@qq.com&gt; 回车，成功返回250ok 输入 rcpt to:&lt;收件人邮箱，xxx@xxx.xxx&gt; 回车，成功返回250ok 输入 data 回车，回车后就可以开始写邮件内容了 输入 from：发件人名称 (可任意填) 输入 to：收件人名称(可任意填) 输入 subject：信件主题 在正文输入结束时输入一个.(英文)回车 服务器返回 250 Ok: queues as,表示邮件已经发送","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"翻墙(下)","date":"2021-02-28T02:08:16.679Z","path":"2021/02/28/翻墙(下)/","text":"3、域名劫持 Domain name hijacking一般情况下, 使用浏览器去连接互联网站点时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来。当使用翻墙软件时, 各种翻墙软件是采用在境外服务器和境内服务器之间建立一条安全隧道的方式，借助代理服务器对敏感数据进行加密访问。此时, 浏览器先向代理服务器发出请求, 再由代理服务器取回浏览器所需信息并传送给浏览器。摘自：典型翻墙软件的网络通信特征研究在中国知网查看：点击跳转 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 目的是无法访问目标网站，限制在特定的被劫持的网络范围内，是互联网攻击的一种方式。 DNS（Domain Name System，域名bai系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简介定义域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。 域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 原理：域名解析 (DNS) 的基本原理是把网络地址（域名，以一个字符串的形式）对应到真是计算机能够识别的网络地址（IP地址，比如216.239.53.99 这样的形式），以便计算机能够进一步通信，传递网址和内容等。 由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。 过程由于域名劫持只能在特定的网络范围内进行，所以范围外的域名服务器(DNS)能返回正常IP地址。攻击者正是利用此点在范围内封锁正常DNS的IP地址，使用域名劫持技术，通过冒充原域名以E-MAIL方式修改公司的注册域名记录，或将域名转让到其他组织，通过修改注册信息后在所指定的DNS服务器加进该域名记录，让原域名指向另一IP的服务器，让多数网民无法正确访问，从而使得某些用户直接访问到了恶意用户所指定的域名地址，其实施步骤如下： 一、获取劫持域名注册信息：首先攻击者会访问域名查询站点，通过MAKE CHANGES功能，输入要查询的域名以取得该域名注册信息。 二、控制该域名的E-MAIL帐号：此时攻击者会利用社会工程学或暴力破解学进行该E-MAIL密码破解，有能力的攻击者将直接对该E-MAIL进行入侵行为，以获取所需信息。 三、修改注册信息：当攻击者破获了E-MAIL后，会利用相关的MAKE CHANGES功能修改该域名的注册信息，包括拥有者信息，DNS服务器信息等。 四、使用E-MAIL收发确认函：此时的攻击者会在信件帐号的真正拥有者之前，截获网络公司回馈的网络确认注册信息更改件，并进行回件确认，随后网络公司将再次回馈成功修改信件，此时攻击者成功劫持域名。 缺点它不是很稳定，在某些网络速度快的地方，真实的IP地址返回得比窃持软件提供的假地址要快，因为监测和返回这么巨大的数据流量也是要花费一定时间的。 在网上查询域名的正确IP非常容易。一个是利用海外的一些在线IP地址查询服务，可以查找到网站的真实IP地址。在Google上搜索”nslookup”，会找到更多类似的服务。 4、流量限制流量限制是一个名词，指直接限制网络流量。 地位：最严厉的一种流量限制。 限制分类当前的虚拟主机主要分为三类流量限制: 一:流量限制 就是直接限制网络流量,这种限制通常是最严厉的一种流量限制,10个g的流量大体支持50人在线以内.当月流量超过后,在一个月内网站都不能正常访问了,解决办法是升级空间或加大流量! 假设一个网页的大小是10K Byte，那么访问这个网页一次就要产生10K的流量，1G流量就可以访问这个网页 1G/10K=100,000 次。 二:CPU限制 CPU限制看起来没有限IIS或网络流量,但由于每一个程序运行都需要一定的CPU配额,也是变相的流量限制,通常网页显示在线过多都是由于CPU限额过小引起的!通过刷新或15秒后可以得到暂时的正常运行,通常1%的CPU限额相当于20个IIS连接!这对于论坛空间很重要,论坛的CPU限额一旦过小就会不能正常运行! 三:IIS限制 IIS限制是现在用的最多的,也是被大多用户或主机商认可,是唯一宽松的流量限制,通常20个IIS就相当于1%CPU占用! 选择建议虚拟主机实际上没有不限流量的,总的可以分为以上三种方式,您如何选择,要看您的需要,如果您的程序占用CPU很少,是优化的程序可以选择限CPU的,这样您的在线就可以得到最大的发挥,如果您是初学者,或是论坛用户,或网站程序中有BBS,选择IIS限制或直接流量限制是一个好的选择!","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"科幻小说死亡开关在数据方面真的能实现吗？","date":"2021-02-25T05:32:58.542Z","path":"2021/02/25/科幻小说死亡开关在数据方面真的能实现吗？/","text":"每个人的生命只有一次，没人能说清死后的世界是什么样的。 作者 戴维·伊格尔曼（大卫·伊格曼）David Eagleman，生于1971年，美国神经科学家，斯坦福大学副教授，NeoSensory（似乎是一家植入传感器设备公司）的CEO。本篇《死亡开关》选自作者2009年出版的图书《死亡的故事》（Sum: Forty Tales from the afterlives）第二十五章，也曾在《Nature》上发表过（是的，Nature也会接收一些科普和科幻小说），严格来说——这篇与其说是科幻小说，倒不如说是一篇科幻随笔——可以看作是科幻小说的构思，大刘、韩松、吴岩等国内科幻大佬也出版过类似的科幻随笔。 总的来说看了一下，也就是他所写的《死亡的故事》中的一个随笔故事，篇幅几百字左右。里面讲了死亡开关，电脑每周会向你发出密码提示，确认你还活着，如果一段时间过去了，你却一直没有输入密码，那么电脑就会做出你已经死亡的推断，并自动将密码发送给第二号负责人。 人们利用死亡开关将瑞士银行的账号转交给自己的继承人，在争论中强辩到底，或是坦诚道出有生之年无法开口说出的秘密。 我感觉吧，根本不可能实现，信息的积累只会是越来越大，虽然现在是大数据时代，将来将会是巨大数据时代，但是数据的存储也是有限的，如果人们死后会进行数据的积累，那么数据只会越来越大，而且是叠加增长，先前拥有的死亡人的数据会增加，新来的也增加。现如今，世界人口已经增长到75亿人次。根据联合国公布z、的数字，现在的每秒出生的人数平均有5人次，死亡的人数每秒为2人次。也就是说世界人口每秒就增加3人次，那么一分钟就是增加180人次，一小时也就是增加10800人次，以此类推的话，一年大概要增加将近1亿人次。接下来我们再算算死亡人数，每秒2人次，一分钟就是120人次，一小时就是7200人次，同样以此类推，每年死亡的人口大概在6400万人次。一个人只保留1Mb的数据，一年存储数据为64000000MB，64000GB，64T。 计算机报上看到荷兰银行的20个数据中心有大约7PB磁盘和超过20PB的磁带存储，而且每年50%~70%存储量的增长，计算一下27PB大约为 500个64TB的大小，也就是500个第一年开始进行死亡开关这场游戏的数据。 由于是叠加增长，第一年会产生一个64TB 第二年会是第一年产生的，加上新产生的总和，2+1=3 第三年3+2+1=6 第四年4+3+2+1=10 这里我用Java写了一个测试代码，看看500个64TB能够几年使用完 12345678910111213public class HelloWorld &#123; public static void main(String []args) &#123; int num=0; for(int i = 0;;i++)&#123; num = num + i; if(num&gt;500)&#123; System.out.println(i); break; &#125; &#125; &#125;&#125;结果：32 也就是用了32年会将荷兰银行的这些数据存储完，但之后的数据存储会持续叠加上升，为无线等差数列和 等差数列和的函数为n^2，之后看看第二个荷兰银行数据存储会多久存满，结果是第45年，也就是用了13年就会存满，之后会越来越少，等到有一天，n=500的时候，也就会是每天将会存储一个荷兰银行的20个数据中心。 综上所述，我觉得这是一个不现实的问题。 mobi文件mobi是亚马逊的私有格式，目前市面上的 mobi 文件大部分是来自两种途径：epub、pdf 或者 txt 转换成的 mobi，从 Amazon 商店流出来的 mobi。","categories":[],"tags":[{"name":"死亡开关","slug":"死亡开关","permalink":"http://example.com/tags/%E6%AD%BB%E4%BA%A1%E5%BC%80%E5%85%B3/"},{"name":"兴趣","slug":"兴趣","permalink":"http://example.com/tags/%E5%85%B4%E8%B6%A3/"}]},{"title":"翻墙(上)","date":"2021-02-25T02:03:23.942Z","path":"2021/02/25/翻墙(上）/","text":"科普所谓翻墙，是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问。境外公司曾发布几款突破网络封锁以访问海外敏感网站或邮件的翻墙软件。由于此类软件不断升级，要实现对该类软件行为的监测或封锁就显得尤为困难和重要，如果能够在网关处将数据截获，分析数据包的行为特征，将部分数据包进行劫持还原，这将对公安机关的调查取证起到积极的作用。 该解释引自《典型翻墙软件的网络通信特征研究》，作者官国静，此外我还会讲解一下它的这篇文章 由于内容过多下半部分放在了下一篇，想了解关于软件和caj文件解释的可以看看，以下定义摘抄自百度，为了是能够自己了解所以写在了下面，觉得不够详细的可以百度搜索。 1、ip 封锁（IP Block）ip 封锁是指防火墙维护一张 ip 黑名单，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。 缺点：采用黑名单禁止模式有一定的漏洞 目的：屏蔽对目的主机的访问 提供服务的服务器亦可能使用类似的方法，以控制可存取的范围，通常可设定白名单只允许某个网段或某个国家的 ip 存取，也可设定黑名单以禁止某网段或某些国家的 ip 存取。例如一些线上游戏营运商或线上影片服务为确保本国玩家的权益及版权限制，只允许本国的 ip 连线。 缺点这种对被封禁的网站采用黑名单而不是对被允许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在。 常见情况封锁 ip — 当计算机或系统受到外部攻击时，管理员可以通过屏蔽攻击源 ip 地址来抵御攻击。通过防火墙和路由器配置，可以封锁某个 ip，禁止与其连接，从而达到抵御攻击的作用。但事实上大多数的攻击，管理员根本没有时间反应，一般在反应过来后系统已经崩溃。 1、多次发布谩骂、侮辱言论； 2、发布大量商业广告、或无用废帖（即 “爆吧” ） 3、其他严重违反贴吧规定的情况。 2、内容过滤content filter内容过滤是对网络内容进行监控，防止某些特定内容在网络上进行传输的技术。主要实现有 软件(点击跳转)和硬件两种。 性质为非营利性，开始启用时间为1995年，含义为对网络内容进行监控。 解释在因特网上，内容过滤（content filtering），也被称作信息过滤（information filtering），是将Web网页或电子邮件中令人讨厌的信息屏蔽和拒绝存取或使用的技术。内容过滤被公司或家用电脑拥有者用作网络防火墙的一部分，尤其是父母可以为他们的孩子屏蔽掉那些不想让其访问的内容。 内容过滤通常使用特征字符串进行工作，如果内容和字符串相符，则会把这部分内容屏蔽掉。被过滤的典型是那些带有色情、暴力、仇恨倾向的内容，==内容过滤程序的批评者指出，它可能在无形中将想要的内容同时过滤掉。== 内容过滤和提供这项服务的产品分为网页过滤——屏蔽网站或页面的信息、邮件过滤——屏蔽电子邮件中的垃圾信息或其它令人讨厌的信息。 方法简介（先软件后硬件）软件过滤方式内容过滤的软件方式主要是一项1995年开始启用的技术标准“Internet内容选择平台”，它是由一家非营利性Internet开放商联盟――万维网联盟(W3C)为解除1995年年末出台的美国《通讯正派条例》(该条例于1997年被否决)的威胁而推出的。Internet内容选择平台的设计理念是鼓励自由表达、保护未成年人的权益，把工具交给父母或其他人，让他们为自己和自己的孩子过滤内容。 这类工具同时还可以将孩子或雇员送出的不恰当信息滤掉，比如家庭地址、信用卡号码、或机密的公司信息等等。 软件过滤主要使用关键词匹配的方式，将特定内容移除。随着互联网应用的开展，软件过滤无法处理飞速增长的流量，于是硬件过滤应运而生。 硬件过滤方式硬件过滤方式就是将关键词匹配功能集成在控制有大量流量的交换机或路由器中，以对网络中的流量进行监控。 目的为防止暴力、恐怖、色情、颠覆主义等内容在互联网上传播，维护网络安全，净化网络，为广大网民提供绿色上网环境。 软件指按照特定顺序组织的计算机数据和指令的集合 软件（中国大陆及香港用语，台湾称作软体，英文：software）是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。软件并不只是包括可以在计算机（这里的计算机是指广义的计算机）上运行的电脑程序，与这些电脑程序相关的文档一般也被认为是软件的一部分。简单的说软件就是程序加文档的集合体。另也泛指社会结构中的管理系统、思想意识形态、思想政治觉悟、法律法规等等。 开发语言为Java、C/C++、Basic、python等 应用类别系统软件、应用软件等 定义国标中对软件的定义为：与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。 其它定义： 1．运行时，能够提供所要求功能和性能的指令或计算机程序集合。 2．程序能够满意地处理信息的数据结构。 3．描述程序功能需求以及程序如何操作和使用所要求的文档。 以开发语言作为描述语言，可以认为：软件=程序+数据+文档 特点1、无形的，没有物理形态，只能通过运行状况来了解功能、特性、和质量 2、软件渗透了大量的脑力劳动，人的逻辑思维、智能活动和技术水平是软件产品的关键 3、软件不会像硬件一样老化磨损，但存在缺陷维护和技术更新 4、软件的开发和运行必须依赖于特定的计算机系统环境，对于硬件有依赖性，为了减少依赖，开发中提出了软件的可移植性 5、软件具有可复用性，软件开发出来很容易被复制，从而形成多个副本 分类应用类别按应用范围划分，一般来讲软件被划分为==系统软件==、==应用软件==和==介于这两者之间的中间件==。 系统软件 系统软件为计算机使用提供最基本的功能，可分为操作系统和支撑软件，其中操作系统是最基本的软件。 系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。 1．操作系统是一管理计算机硬件与软件资源的程序，同时也是计算机系统的内核与基石。操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统交互的操作接口。 2．支撑软件是支撑各种软件的开发与维护的软件，又称为软件开发环境（SDE）。它主要包括环境数据库、各种接口软件和工具组。著名的软件开发环境有IBM公司的Web Sphere,微软公司的等。 包括一系列基本的工具（比如编译器、数据库管理、存储器格式化、文件系统管理、用户身份验证、驱动管理、网络连接等方面的工具）。 应用软件 系统软件并不针对某一特定应用领域，而应用软件则相反，不同的应用软件根据用户和所服务的领域提供不同的功能。 应用软件是为了某种特定的用途而被开发的软件。它可以是一个特定的程序，比如一个图像浏览器。也可以是一组功能联系紧密，可以互相协作的程序的集合，比如微软的Office软件。也可以是一个由众多独立程序组成的庞大的软件系统，比如数据库管理系统。 如今智能手机得到了极大的普及，运行在手机上的应用软件简称手机软件。所谓手机软件就是可以安装在手机上的软件，完善原始系统的不足与个性化。随着科技的发展，手机的功能也越来越多，越来越强大。不是像过去的那么简单死板,发展到了可以和掌上电脑相媲美。手机软件与电脑一样，下载手机软件时还要考虑你购买这一款手机所安装的系统来决定要下相对应的软件。手机主流系统有以下：[Windows Phone](https://baike.baidu.com/item/Windows Phone)、Symbian、iOS、Android。 授权类别不同的软件一般都有对应的软件授权，软件的用户必须在同意所使用软件的许可证的情况下才能够合法的使用软件。从另一方面来讲，特定软件的许可条款也不能够与法律相违背。 依据许可方式的不同，大致可将软件区分为几类： 专属软件：此类授权通常不允许用户随意的复制、研究、修改或散布该软件。违反此类授权通常会有严重的法律责任。传统的商业软件公司会采用此类授权，例如微软的Windows和办公软件。专属软件的源码通常被公司视为私有财产而予以严密的保护。 自由软件：此类授权正好与专属软件相反，赋予用户复制、研究、修改和散布该软件的权利，并提供源码供用户自由使用，仅给予些许的其它限制。以Linux、Firefox 和OpenOffice 可做为此类软件的代表。 共享软件：通常可免费的取得并使用其试用版，但在功能或使用期间上受到限制。开发者会鼓励用户付费以取得功能完整的商业版本。根据共享软件作者的授权，用户可以从各种渠道免费得到它的拷贝，也可以自由传播它。 免费软件：可免费取得和转载，但并不提供源码，也无法修改。 公共软件：原作者已放弃权利，著作权过期，或作者已经不可考究的软件。使用上无任何限制。 相关概念开发流程软件开发是根据用户要求建造出软件系统或者系统中的软件部分的过程。软件开发是一项包括需求捕捉，需求分析，设计，实现和测试的系统工程。软件一般是用某种程序设计语言来实现的。通常采用软件开发工具可以进行开发。 软件开发流程即Software development process。 软件设计思路和方法的一般过程，包括设计软件的功能和实现的算法和方法、软件的总体结构设计和模块设计、编程和调试、程序联调和测试以及编写、提交程序。 1 相关系统分析员和用户初步了解需求，然后列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。 2 系统分析员深入了解和分析需求，根据自己的经验和需求做出一份文档系统的功能需求文档。这次的文档会清楚例用系统大致的大功能模块，大功能模块有哪些小功能模块，并且还例出相关的界面和界面功能。 3 系统分析员和用户再次确认需求。 4 系统分析员根据确认的需求文档所例用的界面和功能需求，用迭代的方式对每个界面或功能做系统的概要设计。 5 系统分析员把写好的概要设计文档给程序员，程序员根据所例出的功能一个一个的编写。 6 测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能，然后验收。 软件工程师一般指从事软件开发职业的人。软件工程师10余年来一直占据高薪职业排行榜的前列，作为高科技行业的代表，技术含量很高，职位的争夺也异常激烈。软件开发是一个系统的过程，需要经过市场需求分析、软件代码编写、软件测试、软件维护等程序。软件开发工程师在整个过程中扮演着非常重要的角色，主要从事根据需求开发项目软件工作。 法律保护计算机软件作为一种知识产品，其要获得法律保护，必须具备以下必要条件： （一）原创性。即软件应该是开发者独立设计、独立编制的编码组合。 （二）可感知性。受保护的软件须固定在某种有形物体上，通过客观手段表达出来并为人们所知悉。 （三）可再现性。即把软件转载在有形物体上的可能性。 著作权归属根据《计算机软件保护条例》第10条的规定，计算机软件著作权归属软件开发者。因此，确定计算机著作权归属的一般原则是“谁开发谁享有著作权”。软件开发者指实际组织进行开发工作，提供工作条件完成软件开发，并对软件承担责任的法人或者非法人单位，以及依靠自己具有的条件完成软件开发，并对软件承担责任的公民。 载体软件的载体可以是硬盘、光盘、U盘、软盘等数据存储设备。 使用许可不同的软件一般都有对应的软件授权，软件的使用者必须在同意所使用软件的许可证的情况下才能够合法的使用软件。 依据许可方式的不同，大致可将软件区分为几类： 专属软件、自由软件、共享软件、免费软件、公共软件。 生命周期软件生命周期是指从软件定义、开发、使用、维护到报废为止的整个过程，一般包括问题定义、可行性分析、需求分析、总体设计、详细设计、编码、测试和维护。 问题定义就是确定开发任务到底“要解决的问题是什么”，系统分析员通过对用户的访问调查，最后得出一份双方都满意的关于问题性质、工程目标和规模的书面报告。 可行性分析就是分析上一个阶段所确定的问题到底“可行吗”，系统分析员对系统要进行更进一步的分析，更准确、更具体地确定工程规模与目标，论证在经济上和技术上是否可行，从而在理解工作范围和代价的基础上，做出软件计划。 需求分析即使对用户要求进行具体分析，明确“目标系统要做什么”，把用户对软件系统的全部要求以需求说明书的形式表达出来。 总体设计就是把软件的功能转化为所需要的体系结构，也就是决定系统的模块结构，并给出模块的相互调用关系、模块间传达的数据及每个模块的功能说明。 详细设计就是决定模块内部的算法与数据结构，也是明确“怎么样具体实现这个系统”。 编码就是选取适合的程序设计语言对每个模板进行编码，并进行模块调试。 测试就是通过各种类型的测试使软件达到预定的要求。 维护就是软件交付给用户使用后，对软件不断查错、纠错和修改，使系统持久地满足用户的需求。 软件的生命周期也可以分为3个大的阶段，分别是计划阶段、开发阶段和维护阶段。 软件生命周期模型软件生命周期模型也称为软件过程模型，反映软件生存周期各个阶段的工作如何组织、衔接，常用的有瀑布模型、原型模型、螺旋模型、增量模型、喷泉模型，还有建造-修补模型、MSF过程模型、快速原型模型。 [1] 常见的软件生命周期模型瀑布模型 有时也称为V模型，它是一种线型顺序模型，是项目自始至终按照一定顺序的步骤从需求分析进展到系统测试直到提交用户使用，它提供了一种结构化的、自顶向下的软件开发方法，每阶段主要工作成果从一个阶段传递到下一个阶段，必须经过严格的评审或测试，以判定是否可以开始下一阶段工作，各阶段相互独立、不重叠。瀑布模型是所有软件生命周期模型的基础。 [1] 原型+瀑布模型 原型模型本身是一个迭代的模型，是为了解决在产品开发的早期阶段存在的不确定性、二义性和不完整性等问题，通过建立原型使开发者进一步确定其应开发的产品，使开发者的想象更具体化，也更易于被客户所理解。原型只是真实系统的一部分或一个模型，完全可能不完成任何有用的事情，通常包括抛弃型和进化型两种，抛弃型指原型建立、分析之后要扔掉，整个系统重新分析和设计；进化型则是对需求的定义较清楚的情形，原型建立之后要保留，作为系逐渐增加的基础，采用进化型一定要重视软件设计的系统性和完整性，并且在质量要求方面没有捷径，因此，对于描述相同的功能，建立进化型原型比建立抛弃型原型所花的时间要多。原型建立确认需求之后采用瀑布模型的方式完成项目开发。 [1] 增量模型 与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 一些大型系统往往需要很多年才能完成或者客户急于实现系统，各子系统往往采用增量开发的模式，先实现核心的产品，即实现基本的需求，但很多补充的特性(其中一些是已知的，另外一些是未知的)在下一期发布。增量模型强调每一个增量均发布一个可操作产品，每个增量构建仍然遵循设计-编码-测试的瀑布模型。 [1] 迭代模型 早在20世纪50年代末期，软件领域中就出现了迭代模型。最早的迭代过程可能被描述为“分段模型”。迭代，包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。所以，在某种程度上，开发迭代是一次完整地经过所有工作流程的过程：（至少包括）需求工作流程、分析设计工作流程、实施工作流程和测试工作流程。 实质上，它类似小型的瀑布式项目。所有的阶段（需求及其它）都可以细分为迭代。每一次的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 [1] 开发语言O语言O语言是一款中文计算机语言（或称套装：O汇编语言、O中间语言、O高级语言） Java语言作为跨平台的语言，可以运行在Windows和Unix/Linux下面，长期成为用户的首选。自JDK6.0以来，整体性能得到了极大的提高，市场使用率超过20%。可能已经达到了其鼎盛时期了，不知道后面能维持多长时间。 易语言（E语言）易语言是一个自主开发，适合国情，不同层次不同专业的人员易学易用的汉语编程语言。易语言降低了广大电脑用户编程的门槛，尤其是根本不懂英文或者英文了解很少的用户，可以通过使用本语言极其快速地进入Windows程序编写的大门。 [2] C/C++语言以上2个作为传统的语言，一直在效率第一的领域发挥着极大的影响力。像Java这类的语言，其核心都是用C/C++写的。在高并发和实时处理，工控等领域更是首选。 习语言习语言即中文版的C语言 Basic美国计算机科学家约翰·凯梅尼和托马斯·库尔茨于1959年研制的一种“初学者通用符号指令代码”，简称BASIC。由于BASIC语言易学易用，它很快就成为流行的计算机语言之一。 PHP同样是跨平台的脚本语言，在网站编程上成为了大家的首选，支持PHP的主机非常便宜，PHP+Linux+MySQL+Apache的组合简单有效。 Perl脚本语言的先驱，其优秀的文本处理能力，特别是正则表达式，成为了以后许多基于网站开发语言(比如PHP,Java,C#)的这方面的基础。 PythonPython是一种面向对象的解释性的计算机程序设计语言，也是一种功能强大而完善的通用型语言，已经具有十多年的发展历史，成熟且稳定。Python 具有脚本语言中最丰富和强大的类库，足以支持绝大多数日常应用。 这种语言具有非常简捷而清晰的语法特点，适合完成各种高层任务，几乎可以在所有的操作系统中运行。 基于这种语言的相关技术正在飞速的发展，用户数量急剧扩大，相关的资源非常多。 C#C#是微软公司发布的一种面向对象的、运行于NET Framework之上的高级程序设计语言，并定于在微软职业开发者论坛(PDC)上登台亮相。C#是微软公司研究员Anders Hejlsberg的最新成果。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、界面，与Java几乎同样的语法，和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM(组件对象模型)是直接集成的，而且它是微软公司.NET Windows网络框架的主角。 JavaScriptJavaScript是一种由Netscape的LiveScript发展而来的脚本语言，主要目的是为了解决服务器终端语言，比如Perl，遗留的速度问题。当时服务端需要对数据进行验证，由于网络速度相当缓慢，只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。 Ruby一种为简单快捷面向对象编程（面向对象程序设计）而创的脚本语言，由日本人松本行弘（まつもとゆきひろ，英译：Yukihiro Matsumoto，外号matz）开发，遵守GPL协议和Ruby License。Ruby的作者认为Ruby &gt; (Smalltalk + Perl) / 2，表示Ruby是一个语法像Smalltalk一样完全面向对象、脚本执行、又有Perl强大的文字处理功能的编程语言。 Fortran在科学计算软件领域，Fortran曾经是最主要的编程语言。比较有代表性的有Fortran 77、Watcom Fortran、NDP Fortran等。 Objective C这是一种运行在苹果公司的[Mac OS X](https://baike.baidu.com/item/Mac OS X/470629)，iOS操作系统上的语言。这两种操作系统的上层图形环境，应用程序编程框架都是使用该语言实现的。随著iPhone,iPad的流行，这种语言也开始在全世界流行。 PascalPascal是一种计算机通用的高级程序设计语言。Pascal的取名是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal。它由瑞士Niklaus Wirth教授于六十年代末设计并创立。Pascal语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。 SwiftSwift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C共同运行于[Mac OS](https://baike.baidu.com/item/Mac OS)和iOS平台，用于搭建基于苹果平台的应用程序。 caj文件caj文件是中国期刊网提供的一种文件格式,现在网络的很多文献都采用了 caj 文件格式。在浏览 caj 格式文件的时候,你也必须使用相应的阅读器才可以,通用的caj阅读器为CAJViewer。","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"日记","date":"2021-02-24T07:59:00.706Z","path":"2021/02/24/时间管理法/","text":"每月小结，看看自己这个月用于什么的时间是多少，如上课，认真学习，玩 同时年度总结，对自己本月进行反思 记录尽可能准确的记录时间被用在了哪里， 统计以每周每个月或每年为单位，统计每件事情用了多少时间 分析，分析在过去这段时间里，哪些运用时间的方法是高效的，哪些是可以改进的 反馈根据自己分析得出的结论做出改变，让自己更加有效的利用时间 记录–》统计–》分析–》反馈要点： 首先是记录的及时性，不要连续做了好几件事情再回过头来一件一件的记，要一事一记，同时要保持时间记录的真实性、准确性。要保证记录的误差不要大于15分钟就可以了。 其次，选择记录的时间段要相对固定并且有代表性，如果你要记录自己在某项相对重复的工作上花费了多少时间，最好是每天固定的时间段来做这项工作，人在固定时段的状态是相对稳定的。 最后你还要根据记录情况，及时调整时间分配计划，在每周或每月总结的时候要找出上一段计划当中实际消耗时间与计划消耗时间之间的差额，然后结合自己的工作效率重新分配下一时间段。 坚持是在时间管理方面必不可少的品质。 时间管理法的五大法则：恰当运用这五大法则，可以让时间管理法不会成为你的一种镣铐，而是成为运用自如的乐器。 不要为了完成工作而放弃自己的兴趣爱好。对作者而说，不论工作有多困难，任务有多繁重，只要他愿意，就一定能在自己预估的时间里按部就班的完成，但事实上，作者并不是像我们想象中的那么从一而终，很多时候它的本质工作，是要为兴趣让路的。没有什么比满足自己的求知欲和好奇重要，与其被迫在完成工作和满足好奇心之间做出选择，不如索性大方拒绝那些必须完成的任务而选择兴趣。 不接受紧急的任务。因为接受紧急的任务可能会因为由于时间仓促而无法做到尽善其美，更重要的是，它会打破你原有的节奏，引起一系列的连锁反应，最后反而是更费时间的。 一累了就马上停止工作去休息。 保证睡眠时间，每天10小时左右。没有这条守则，时间管理方法将永远是纸上谈兵。作者认为，休息是需要规划、记录、安排再规划的，因为这种方法并不是一种间歇性的方法，而是一种长期性的计划，这是一种很容易让人产生压迫感的方法，如果睡的不好，没有足够的休息，当你面对一张慢慢当当的计划表的时候，很容易陷入被计划牵着鼻子走的恶训循环，一旦陷入这样的恶训循环，就离放弃不远了。 把累人的工作和愉快的工作结合在一起。","categories":[],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"}]},{"title":"搭建博客以及优化","date":"2021-02-23T09:09:39.356Z","path":"2021/02/23/搭建博客以及优化/","text":"不会吧不会吧，难道你还没有属于自己的博客？ 目录不显示文章标题，tags标签怎么加，文章截断 标签这个东西可以在我们写完一个博客文章之后在最上方添加，这样比较方便，对应 yilia 主题你会发现没有这个你的文章没有标题，是空白的。 还有一个是文章截断问题，默认是主页显示整篇的文章，写完文章后，用记事本打开，再需要的地方加上截断代码 &lt;!--more--&gt; 图片加载-采用 lazyload 图片懒加载 图片加载只需要两步 配置，在hexo目录下，执行以下命令，插入模块 1npm install hexo-lazyload-image --save 然后在你的 hexo 目录的配置文件 _config.xml 中添加配置： 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片. loadingImg - 图片未加载时的代替图 不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes\\next\\source\\images 目录下, 然后引用时: loadingImg: /images/图片文件名 借鉴的有简书的这位好友，很感谢带给我的帮助，帮我处理了很多日常写博客的问题https://www.jianshu.com/p/f6f19b02c661 还有就是新手们怎么搭建博客，这里推荐一位好友www.codesheep.cn","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]