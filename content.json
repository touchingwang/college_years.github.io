[{"title":"TreadLocal","date":"2021-06-20T15:55:19.156Z","path":"2021/06/20/ThreadLocal/","text":"1、使用场景当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。 2、ThreadLocal简介多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。 ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一乐ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本 3、ThreadLocal的实现原理set方法源码获取当前线程，以当前线程作为key值，如果已将有了就改变值，如果没有就初始化一个key为当前线程，并将当前线程的本地变量value赋为null get方法源码在get方法的实现中，首先获取当前调用者线程，如果当前线程的threadLocals不为null，就直接返回当前线程绑定的本地变量值，否则执行setInitialValue方法初始化threadLocals变量。在setInitialValue方法中，类似于set方法的实现，都是判断当前线程的threadLocals变量是否为null，是则添加本地变量（这个时候由于是初始化，所以添加的值为null），否则创建threadLocals变量，同样添加的值为null。 remove方法的实现remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量 内存溢出问题每个线程内部有一个名为threadLocals的成员变量，该变量的类型为ThreadLocal.ThreadLocalMap类型（类似于一个HashMap），其中的key为当前定义的ThreadLocal变量的this引用，value为我们使用set方法设置的值。每个线程的本地变量存放在自己的本地内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量就会一直存在（所以可能会导致内存溢出），因此使用完毕需要将其remove掉。 4、使用方法123456789101112131415161718192021222324252627282930313233343536373839404142package test;public class ThreadLocalTest &#123; static ThreadLocal&lt;String&gt; localVar = new ThreadLocal&lt;&gt;(); static void print(String str) &#123; //打印当前线程中本地内存中本地变量的值 System.out.println(str + &quot; :&quot; + localVar.get()); //清除本地内存中的本地变量 localVar.remove(); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; //设置线程1中本地变量的值 localVar.set(&quot;localVar1&quot;); //调用打印方法 print(&quot;thread1&quot;); //打印本地变量 System.out.println(&quot;after remove : &quot; + localVar.get()); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; //设置线程1中本地变量的值 localVar.set(&quot;localVar2&quot;); //调用打印方法 print(&quot;thread2&quot;); //打印本地变量 System.out.println(&quot;after remove : &quot; + localVar.get()); &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 5、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题1、基础概念 首先我们先看看ThreadLocalMap的类图，在前面的介绍中，我们知道ThreadLocal只是一个工具类，他为用户提供get、set、remove接口操作实际存放本地变量的threadLocals（调用线程的成员变量），也知道threadLocals是一个ThreadLocalMap类型的变量，下面我们来看看ThreadLocalMap这个类。在此之前，我们回忆一下Java中的四种引用类型，相关GC只是参考前面系列的文章JVM相关 ①强引用：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。 ②软引用：简言之，如果一个对象具有弱引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中 ③弱引用（这里讨论ThreadLocalMap中的Entry类的重点）：如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收期回收掉，JVM会将这个引用加入到与之关联的引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用的对象呗回收掉之后，再调用get方法就会返回null ④虚引用：虚引用是所有引用中最弱的一种引用，其存在就是为了将关联虚引用的对象在被GC掉之后收到一个通知。（不能通过get方法获得其指向的对象） 2、分析ThreadLocalMap内部实现查看到Entry extends WeakReference，当前ThreadLocal的引用k被传递给WeakReference的构造函数，所以ThreadLocalMap中的key为ThreadLocal的弱引用。当一个线程调用ThreadLocal的set方法设置变量的时候，当前线程的ThreadLocalMap就会存放一个记录，这个记录的key值为ThreadLocal的弱引用，value就是通过set设置的值。如果当前线程一直存在且没有调用该ThreadLocal的remove方法，如果这个时候别的地方还有对ThreadLocal的引用，那么当前线程中的ThreadLocalMap中会存在对ThreadLocal变量的引用和value对象的引用，是不会释放的，就会造成内存泄漏。 考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在的这就可能造成内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。 “内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。” 总结：THreadLocalMap中的Entry的key使用的是ThreadLocal对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉，但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项，这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。 原文https://www.cnblogs.com/fsmly/p/11020641.html，稍做删改；相关https://www.cnblogs.com/dreamroute/p/5034726.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1030","date":"2021-06-20T15:01:56.574Z","path":"2021/06/20/pat1030/","text":"1030. 完美数列(25) [two pointers]给定⼀个正整数数列，和正整数p，设这个数列中的最⼤值是M，最⼩值是m，如果M &lt;= m * p，则称这个数列是完美数列。 现在给定参数p和⼀些正整数，请你从中选择尽可能多的数构成⼀个完美数列。 输⼊格式： 输⼊第⼀⾏给出两个正整数N和p，其中N（&lt;= 105）是输⼊的正整数的个数，p（&lt;= 109）是给定的参数。第⼆⾏给出N个正整数，每个数不超过109。 输出格式： 在⼀⾏中输出最多可以选择多少个数可以⽤它们组成⼀个完美数列。 1210 82 3 20 4 5 1 6 7 8 9 输出样例： 18 分析：⾸先将数列从⼩到⼤排序，设当前结果为result = 0，当前最⻓⻓度为temp = 0；从i = 0～n，j从i + result到n，【因为是为了找最⼤的result，所以下⼀次j只要从i的result个后⾯开始找就⾏了】每次计 算temp若⼤于result则更新result，最后输出result的值 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; long long p; scanf(&quot;%d%lld&quot;, &amp;n, &amp;p); vector&lt;int&gt; v(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v.begin(), v.end()); int result = 0, temp = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + result; j &lt; n; j++) &#123; if (v[j] &lt;= v[i] * p) &#123; temp = j - i + 1; if (temp &gt; result) result = temp; &#125; else &#123; break; &#125; &#125; &#125; cout &lt;&lt; result; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#x32;&#x33;&#48;&#52;&#55;&#x30;&#51;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1029","date":"2021-06-20T15:01:56.572Z","path":"2021/06/20/pat1029/","text":"1029. 旧键盘(20) [Hash散列]旧键盘上坏了⼏个键，于是在敲⼀段⽂字的时候，对应的字符就不会出现。现在给出应该输⼊的⼀段⽂字、以及实际被输⼊的⽂字，请你列出肯定坏掉的那些键。 输⼊格式： 输⼊在2⾏中分别给出应该输⼊的⽂字、以及实际被输⼊的⽂字。每段⽂字是不超过80个字符的串，由字⺟A-Z（包括⼤、⼩写）、数字0-9、以及下划线“_”（代表空格）组成。题⽬保证2个字符串均⾮空。 输出格式： 按照发现顺序，在⼀⾏中输出坏掉的键。其中英⽂字⺟只输出⼤写，每个坏键只输出⼀次。题⽬保证⾄少有1个坏键。 输⼊样例： 127_This_is_a_test_hs_s_a_es 输出样例： 17TI 分析：这一题用c++写的看不懂了，于是用自己粗糙的java写了一下 12345678910111213141516171819202122232425262728package com.wang.random;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.Scanner;import java.util.Set;public class test1 &#123; public static void main(String[] args) &#123; Set&lt;Character&gt; s1 = new LinkedHashSet&lt;&gt;(); Set&lt;Character&gt; s2 = new LinkedHashSet&lt;&gt;(); Scanner sc = new Scanner(System.in); String str1 = sc.nextLine().toUpperCase(); for (int i = 0; i &lt; str1.length(); i++) &#123; s1.add(str1.charAt(i)); &#125; String str2 = sc.nextLine().toUpperCase(); for (int i = 0; i &lt; str2.length(); i++) &#123; s2.add(str2.charAt(i)); &#125; System.out.println(s1); System.out.println(s2); for (Character character : s1) &#123; if(!s2.contains(character)) System.out.printf(&quot;%c&quot;,character); &#125; &#125;&#125;","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1031","date":"2021-06-20T15:01:56.567Z","path":"2021/06/20/pat1031/","text":"1031.查验身份证(15) [字符串处理]⼀个合法的身份证号码由17位地区、⽇期编号和顺序编号加1位校验码组成。校验码的计算规则如下： ⾸先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4， 2}； 然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： Z：0 1 2 3 4 5 6 7 8 9 10 M：1 0 X 9 8 7 6 5 4 3 2 现在给定⼀些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输⼊格式： 输⼊第⼀⾏给出正整数N（&lt;= 100）是输⼊的身份证号码的个数。随后N⾏， 每⾏给出1个18位身份证号码。 输出格式： 按照输⼊的顺序每⾏输出1个有问题的身份证号码。这⾥并不检验前17位是否合理， 只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常， 则输出“All passed”。 输⼊样例1： 12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1： 12312010X19890101123411010819671130186637070419881216001X 输⼊样例2： 1232320124198808240056110108196711301862 输出样例2： All passed 分析：isTrue函数判断身份证号是否正常，如果不正常返回false，判断每⼀个给出的身份证号，如果不正常，就输出这个身份证号，并且置flag=1表示有不正常的号码，如果所有的号码都是正常，即flag依旧等于0，则输出All passed～在isTrue函数中，先判断前17位是否是数字，如果不是，直接return false，如果是，就将当前字符转化为数字并与a[i]相乘，累加在sum中，对于第18位，如果是X要转化为10～⽐较b[sum%11]和第18位是否相等，如果相等就返回true，不相等就返回false～ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;int b[11] = &#123;1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2&#125;;string s;bool isTrue() &#123; int sum = 0; for (int i = 0; i &lt; 17; i++) &#123; if (s[i] &lt; &#x27;0&#x27; || s[i] &gt; &#x27;9&#x27;) return false; sum += (s[i] - &#x27;0&#x27;) * a[i]; &#125; int temp = (s[17] == &#x27;X&#x27;) ? 10 : (s[17] - &#x27;0&#x27;); return b[sum%11] == temp;&#125;int main() &#123; int n, flag = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; if (!isTrue()) &#123; cout &lt;&lt; s &lt;&lt; endl; flag = 1; &#125; &#125; if (flag == 0) cout &lt;&lt; &quot;All passed&quot;; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#x32;&#51;&#x30;&#52;&#x37;&#48;&#51;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis发布订阅","date":"2021-06-16T18:59:43.044Z","path":"2021/06/17/Redis发布订阅/","text":"Redis发布订阅1234567891011127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuoReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;kuangshenshuo&quot;3) (integer) 11) &quot;message&quot;2) &quot;kuangshenshuo&quot;3) &quot;hello,kuangshen&quot;1) &quot;message&quot;2) &quot;kuangshenshuo&quot;3) &quot;hello,redis&quot; 通信 队列 发送者 订阅者 Redis 发布订阅(pub/sub) 是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis 客户端可以订阅任意数量的频道 订阅/发布消息图： 第一个：消息发送者 第二个：频道 第三个：消息订阅者！ 命令这些命令被管饭用于构建即时通信应用，比如网络聊天室(chatroom)和实时直播、实时提醒等。 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 UNSUBSCRIBE channel [channel..] 退订一个或多个频道 测试订阅端： 123456789101112127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo #订阅一个频道 狂神说Reading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;kuangshenshuo&quot;3) (integer) 1# 等待读取推送的消息1) &quot;message&quot; #消息2) &quot;kuangshenshuo&quot; #那个频道的消息3) &quot;hello,kuangshen&quot; #消息的具体内容1) &quot;message&quot;2) &quot;kuangshenshuo&quot;3) &quot;hello,redis&quot; 发送端： 1234127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,kuangshen&quot; #发布者发布消息到频道！(integer) 1127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,redis&quot; #发布者发布消息到频道！(integer) 1 原理Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7SB","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"Redis持久化","date":"2021-06-16T18:59:43.044Z","path":"2021/06/17/Redis持久化/","text":"Redis持久化Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会小时。所以Redis提供了持久化功能！ 什么是RDB（Redis DataBase）在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshop快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 我们默认的就是RDB，一般情况下不需要修改这个配置！ 有时候在生产绘卷我们会将这个文件进行备份！ ==rdb保存的文件是 dump.rdb==都是在我们的配置文件中快照中进行配置的！ 1save 60 5 #60秒内修改了5次key会触发rdb操作 触发机制1、save的规则满足的情况下，会自动触发rdb规则 2、执行 flushall 命令，也会触发我们的rdb规则！ 3、退出redis，也会产生 rdb 文件！ 备份就会自动生成一个dump.rdb 如何恢复rdb文件！1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！ 2、查看需要存放的位置 123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/usr/local/bin&quot; 几乎就它自己默认的配置就够用了，但是我们还是需要去学习！优点： 1、适合大规模的数据恢复！ 2、对数据的完整性要求不高！ 缺点： 1、需要一定的时间间隔进行操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！ 2、fork 进程的时候，会占用一定的内存空间 AOF（Append Only File）将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部执行一遍！ 是什么在主从复制中，rdb就是备用的！从机上面！ 以日志的形式去记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就更具日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 ==Aof保存的是 appendonly.aof 文件== 1234567891011# AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: &quot;appendonly.aof&quot;)appendfilename &quot;appendonly.aof&quot; 默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为 yes就开启了aof！ 重启，redis 就可以生效了！ 如果这个 aof 文件有错误，这时候 redis 是启动不起来的，我们需要修复这个 aof 文件 redis 给我们提供了这样一个工具 redis-check-aof，使用redis-check-aof --fix appendonly.aof 如果文件正常，重启就可以直接恢复了！ 一种是全丢，只丢弃错误的部分 重写规则说明aof默认就是文件的无限制追加，文件会越来越大！ 123no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 如果 aof 文件大于 64m，太大了！fork一个新的进程来将我们的文件进行重写！ 优点和缺点！123456appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下mrdb完全够用！appendfilename &quot;appendonly.aof&quot; #持久化文件的名字# appendfsync always #每次修改都会 sync 消耗性能appendfsync everysec #每秒执行一次 sync，可能会丢失这1s的数据！# appendfsync no #不执行sync，这个时候操作系统自己同步数据，速度最快！ 优点： 1、每一次修改都同步，文件的完整会更加好！ 2、每秒同步一次，可能会丢失这1s的数据！ 3、从不同步，效率最高的！ 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 2、Aof运行效率也要比 rdb 慢，所以我们redismore默认的配置就是rdb持久化！ 扩展1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 4、同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。 如何选择使用哪种持久化方式？一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7SB","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"Redis.conf 详解","date":"2021-06-16T18:59:43.034Z","path":"2021/06/17/Redisconf详解/","text":"Redis.conf详解启动的时候，就通过配置文件来启动！ 基于redis-6.2.1讲解 单位123456789101112131415161718# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same. 1、配置文件 unit单位 对大小写不敏感！ 包含1234567891011121314151617################################## INCLUDES #################################### Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf 就好比我们学些Spring、Import、include 网络123456bind 127.0.0.1 #绑定的 ipprotected-mode no #保护模式port 6379 #端口设置tcp-backlog 511 #TCP连接中已完成队列(完成三次握手之后)的长度timeout 0 #设置连接超时tcp-keepalive 300 #TCP长连接结束存活时长 通用 GENERAL123456789101112131415daemonize yes #以守护线程的方式运行，默认是no，我们需要自己开始为yes!pidfile /var/run/redis_6379.pid #如果以后台的方式运行，我们就需要指定一个pid文件!# 日志# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably) 生产环境# warning (only very important / critical messages are logged)loglevel noticelogfile &quot;&quot; #日志的文件位置名databases 16 #数据库的数量，默认16个数据库always-show-logo no #是否总是显示logo，开启服务的时候 快照持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof redis 是内存数据库，如果没有持久化，那么数据断电即失！ 1234567891011121314151617181920# 如果3600s内，如果至少有一个1 key进行了比较，我们就进行持久化操作# save 3600 1# 如果300s内，如果至少有一个100 key进行了比较，我们就进行持久化操作# save 300 100# 如果6000s内，如果至少有一个10000 key进行了比较，我们就进行持久化操作# save 60 10000# 我们之后学习持久化，会自己定义这个测试！stop-writes-on-bgsave-error yes #持久化如果出错，是否还需要继续工作rdbcompression yes #是否压缩rdb文件，需要消耗一些cpu资源！rdbchecksum yes #保存rdb文件的时候，进行错误的检查校验！dbfilename dump.rdb #保存数据文件名rdb-del-sync-files nordb-del-sync-files no #rdb文件是否删除同步锁dir ./ #文件保存的目录！ 复制 REPLICATION我们后面讲解主从复制的时候再进行讲解 安全 SECURITY可以在这里设置redis的密码，默认是没有密码！ 登录服务 123config get requirepass #获取redis的密码config set requirepass &quot;123&quot; #修改redis的密码为123auth 123 #登录输入密码123 限制 CLIENTS12345678910111213maxclients 10000 #设置能连接上redis的最大客户端数量maxmemory &lt;bytes&gt; #redis配置最大的存储容量maxmemory-policy noeviction #内存到达上限之后的处理策略 # 移除一些过期的 key # 报错 # ......# 在内存达到上限后的处理策略# volatile-lru：只对设置了过期时间的key进行LRU# allkeys-lru ： 删除lru算法的key # volatile-random：随机删除即将过期key # allkeys-random：随机删除 # volatile-ttl ： 删除即将过期的 # noeviction ： 永不过期，返回错误 APPEND ONLY 模式 aof配置123456appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下mrdb完全够用！appendfilename &quot;appendonly.aof&quot; #持久化文件的名字# appendfsync always #每次修改都会 sync 消耗性能appendfsync everysec #每秒执行一次 sync，可能会丢失这1s的数据！# appendfsync no #不执行sync，这个时候操作系统自己同步数据，速度最快！ 具体的配置，我们在Redis持久化中去给大家详细讲解 redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7SB","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"Redis主从复制","date":"2021-06-16T18:59:43.034Z","path":"2021/06/17/Redis主从复制/","text":"Redis主从复制概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader），后者称为从结点（slave/follower）；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。 默认情况下，每台Redis服务器都是主节点；且一个节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制的作用主要包括： 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 2、故障恢复：当主节点出现问题时，可以有从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下： 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大； 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，==单台Redis最大使用内存不应该超过20G。== 电商网站上的商品，一般都是上传一次，无数次浏览的，说专业点也就是”多读少写“。 主从复制，读写分离！80%的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！一主二从！ 只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！ 环境配置只配置从库，不用配置主库！ 12345678910111213127.0.0.1:6379&gt; info replication #查看当前库的信息# Replicationrole:master #角色 masterconnected_slaves:0 #没有从机master_failover_state:no-failovermaster_replid:e4e5976379b4565f9782d8458c1b7d7781d0857amaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 复制3个配置文件，然后修改对应的信息 1、端口 2、pid 名字 3、log文件名字 4、dump.rdb 名字 5、如果主机有密码，从机中修改masterauth 密码 修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！ 1234[root@touchingwang bin]# ps -ef|grep redisroot 22085 1 0 22:45 ? 00:00:00 redis-server 0.0.0.0:6379root 22149 1 0 22:46 ? 00:00:00 redis-server 0.0.0.0:6380root 22169 1 0 22:46 ? 00:00:00 redis-server 0.0.0.0:6381 一主二从默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 123456789101112131415161718192021222324252627282930313233343536373839127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 #找谁当自己的老大！OK127.0.0.1:6380&gt; info replication# Replicationrole:slave #当前角色是从机master_host:127.0.0.1 #可以看到主机的信息master_port:6379master_link_status:upmaster_last_io_seconds_ago:5master_sync_in_progress:0slave_repl_offset:14slave_priority:100slave_read_only:1connected_slaves:0master_failover_state:no-failovermaster_replid:10e847cde021d4d79f24313ec4196efad06b3a39master_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14# 在主机中查看！127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:1 #多了从机的配置slave0:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1 #多了从机的配置master_failover_state:no-failovermaster_replid:10e847cde021d4d79f24313ec4196efad06b3a39master_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14 如果两个都配置完了，就是有两个从机的 真实的主从配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！ 细节主机可以写，从机不能写只能读！注解中的所有信息和数据，都会自动被从机保存！ 主机写： 从机只能读取内容！ 测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！ 如果是使用命令行，来配置的主从，这个时候如果重启了，就会变成主机！只要变回从机，立马就会从主机中获取值！ 复制原理Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到这个命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到slave，并完成一次完全同步。 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给salve，完成同步 但是只是要重新连接master，一次完全同步（全量复制）将被自动执行 层层链路上一个M连接下一个S！ 这个时候也可以完成我们的主从复制！ 如果没有老大了，这个时候能不能选择一个老大出来呢？手动！==谋朝篡位== 如果主机断开了连接，我们可以使用slaveof no one让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了 哨兵模式（自动选举老大的模式） 概述：主从切换基数的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务器不可用。这不是一种推荐的方式，很多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。 谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。 这里的哨兵有两个作用 通过发送命令，让Redis服务器返回运行状态，包括主服务器和从服务器。 当哨兵检测到master宕机，会自动将slave切换为master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题。为此，我们可以使用多个哨兵模式进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 假设主服务器宕机，哨兵1先检测到这个结构，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover故障转移操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 测试！我们目前的状态是一主二从 1、配置哨兵配置文件 sentinel.conf 12# sentinel monitor 被监控的名称 host port 1sentinel monitor myredis 127.0.0.1 6379 1 后面的这个数字1，是有多少个哨兵认为挂了，master 才算真的挂了 2、启动哨兵！ 1[root@touchingwang bin]# redis-sentinel wangconfig/sentinel.conf 如果Master节点断开了，这个时候就会从从机中随机选择一个服务器 如果主机此时回来了，只能归并到新的主机下，当作从机，这就是哨兵模式的规则！ 哨兵模式优点： 1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全由 2、主从可以切换，故障可以转移，系统的可用性就会更好 3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！ 缺点： 1、Redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦！ 2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择 redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7S","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"redis基础","date":"2021-06-16T18:59:43.034Z","path":"2021/06/17/redis/","text":"Nosql概述为什么要用Nosql 单机MySQL的年代 90年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！ 那个时候，更多的去使用静态网页 Html ~ 服务器根本没有太大的压力！ 思考一下，这种情况下：整个网站的瓶颈是什么？ 数据量如果太大，一个机器放不下了！ 数据的索引（B+tree），一个机器内存也放不下 访问量（读写混合），一个服务器承受不了~ 如果你开始出现以上的三种情况之一，那么你就必须要晋级！ Memcached（缓存）+MySQL+垂直拆分 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力，我们可以使用缓存来保存效率！ 发展过程：优化数据结构和索引–》文件缓存（IO）–》Memcached（当时最热门的技术！） 分库分表+水平拆分+MySQL集群 技术和业务在发展的同时，对人的要求也越来越高！ 如今最近的年代 为什么要用NoSQL！用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，NoSQL可以很好的处理以上的情况！ 什么是NoSQLNoSQL = non-relational（非关系型数据库），随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速。Redis是发展最快的，而且是我们当下必须要掌握的一个技术！ NoSQL特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了！） 传统的EDBMS和NoSQL 12345678传统的 RDBMS- 结构化组织- SQL- 数据和关系都存在单独的表中 row col- 操作，数据定义语言- 严格的一致性- 基础的事务- ...... 12345678NoSQL- 不仅仅是数据- 没有固定的查询语言- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性- CAP定理和BASE（异地多活）初级架构师！- 高性能，高可用，高可扩- .... 了解：3V+3高大数据时代的3V：主要是描述问题的 海量Volume 多样Variety 实时Velocity 大数据时代的3高：主要是对程序的要求 高并发 高可扩（随时水平拆分） 高性能（保证用户体验和性能） 真实的公司中的时间：NoSQL+RDBMS一起使用才是最强的，阿里巴巴的架构 阿里巴巴演进分析大型互联网应用问题： 数据类型太多了！ 数据源繁多，经常重构！ 数据要改造，大面积改造！ 解决问题： UDSL热点缓存设计 NoSQL的四大分类KV键值对： 新浪：Redis 美团：Redis+Tair 阿里、百度：Redis+memcache 文档型数据库（bson格式和json一样）： MongoDB（一般必须要掌握） MongoDB是一个基于分布式的文件存储的数据库，C++编写，主要用来处理大量的文档！ MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的！ ConthDB 列存储数据库 HBase 分布式文件系统 图形关系数据库 它不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！ Neo4j，Graph Redis入门概述Redis是什么？Redis（Remote Dictionary Server），即远程字典服务！ 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。免费和开源！是放下最热门的NoSQL技术之一！也被人们称之为结构化数据库！ Redis能干嘛？ 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量！） … 特性 多样的数据类型 持久化 集群 事务 Windows安装 下载安装包 下载完毕得到压缩包 解压到自己电脑上的环境目录下的就可以的！ 开启 redis，运行服务即可！ Windows下使用确实简单，但是Redis推荐我们使用Linux去开发使用！ Linux安装 下载安装包！redis-6.2.1.tar.gz 解压Redis的安装包！程序 /opt 进入解压后的文件，可以看到 redis 的配置文件 基本的环境安装 12345yum install gcc-c++makemake install #确认 redis 的默认安装路径usr/local/bin 将 redis 配置文件复制到我们当前目录下，可以创建一个配置文件夹如wangconfig redis 默认不是后台启动的，修改自定义配置redis文件 1daemonize yes //守护进程模式启动 启动 redis 服务！ 1redis-server wangconfig/redis.conf 使用Redis客户端进行连接 123redis-cli -p 6379#查看所有的keykeys * 查看redis的进程是否开启 1234[root@touchingwang ~]# ps -ef|grep redisroot 20985 1 0 14:47 ? 00:00:00 redis-server 127.0.0.1:6379root 21058 15176 0 14:48 pts/0 00:00:00 redis-cli -p 6379root 21263 21221 0 14:51 pts/1 00:00:00 grep --color=auto redis 如何关闭redis服务呢？ 12127.0.0.1:6379&gt; shutdownnot connected&gt; exit 再次查看进程是否存在 12[root@touchingwang ~]# ps -ef|grep redisroot 21323 21221 0 14:53 pts/1 00:00:00 grep --color=auto redis 后面我们会使用单机多redis启动集群测试！ 测试性能redis-benchmark是一个压力测试工具！ 官方自带的性能测试工具！ 我们来简单测试下： 123456# 测试：100个并发连接 100000请求redis-benchmark -h localhost -p 6379 -c 100 -n 100000# -h 远程号# -p 端口号# -c 指定并发连接数# -n 指定请求数 如何查看这些分析呢！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#测试的每一个请求格式都如下====== MSET (10 keys) ====== 100000 requests completed in 1.42 seconds #对我们的10万个请求进行写入测试 100 parallel clients #100个并发客户端 3 bytes payload #每次写入3个字节 keep alive: 1 #只有一台服务器来处理这些请求，单机性能 host configuration &quot;save&quot;: 3600 1 300 100 60 10000 host configuration &quot;appendonly&quot;: no multi-thread: noLatency by percentile distribution:# 按百分比分布的延迟0.000% &lt;= 0.343 milliseconds (cumulative count 2)50.000% &lt;= 0.735 milliseconds (cumulative count 51031)75.000% &lt;= 0.959 milliseconds (cumulative count 75002)87.500% &lt;= 1.255 milliseconds (cumulative count 87689)93.750% &lt;= 1.471 milliseconds (cumulative count 93861)96.875% &lt;= 1.679 milliseconds (cumulative count 96876)98.438% &lt;= 1.927 milliseconds (cumulative count 98438)99.219% &lt;= 2.175 milliseconds (cumulative count 99232)99.609% &lt;= 2.439 milliseconds (cumulative count 99616)99.805% &lt;= 2.655 milliseconds (cumulative count 99806)99.902% &lt;= 22.735 milliseconds (cumulative count 99903)99.951% &lt;= 23.823 milliseconds (cumulative count 99952)99.976% &lt;= 24.367 milliseconds (cumulative count 99976)99.988% &lt;= 24.623 milliseconds (cumulative count 99988)99.994% &lt;= 24.879 milliseconds (cumulative count 99994)99.997% &lt;= 24.943 milliseconds (cumulative count 99997)99.998% &lt;= 24.991 milliseconds (cumulative count 99999)99.999% &lt;= 25.007 milliseconds (cumulative count 100000)100.000% &lt;= 25.007 milliseconds (cumulative count 100000)# 所有请求在25.007毫秒内处理完成Cumulative distribution of latencies: # 延迟的累积分布0.000% &lt;= 0.103 milliseconds (cumulative count 0)0.039% &lt;= 0.407 milliseconds (cumulative count 39)0.375% &lt;= 0.503 milliseconds (cumulative count 375)2.434% &lt;= 0.607 milliseconds (cumulative count 2434)40.337% &lt;= 0.703 milliseconds (cumulative count 40337)64.008% &lt;= 0.807 milliseconds (cumulative count 64008)72.043% &lt;= 0.903 milliseconds (cumulative count 72043)77.357% &lt;= 1.007 milliseconds (cumulative count 77357)82.076% &lt;= 1.103 milliseconds (cumulative count 82076)86.227% &lt;= 1.207 milliseconds (cumulative count 86227)89.055% &lt;= 1.303 milliseconds (cumulative count 89055)91.997% &lt;= 1.407 milliseconds (cumulative count 91997)94.650% &lt;= 1.503 milliseconds (cumulative count 94650)96.189% &lt;= 1.607 milliseconds (cumulative count 96189)97.076% &lt;= 1.703 milliseconds (cumulative count 97076)97.797% &lt;= 1.807 milliseconds (cumulative count 97797)98.324% &lt;= 1.903 milliseconds (cumulative count 98324)98.767% &lt;= 2.007 milliseconds (cumulative count 98767)99.088% &lt;= 2.103 milliseconds (cumulative count 99088)99.888% &lt;= 3.103 milliseconds (cumulative count 99888)99.900% &lt;= 4.103 milliseconds (cumulative count 99900)99.920% &lt;= 23.103 milliseconds (cumulative count 99920)99.964% &lt;= 24.111 milliseconds (cumulative count 99964)100.000% &lt;= 25.103 milliseconds (cumulative count 100000)Summary: throughput summary: 70422.54 requests per second #每秒进行70422.54次请求 latency summary (msec): avg min p50 p95 p99 max 0.892 0.336 0.735 1.519 2.071 25.007 基础的知识redis 默认有16个数据库，可以在redis.conf中看到databases 16 可以使用 select 进行切换数据库 12345127.0.0.1:6379&gt; select 3OK127.0.0.1:6379[3]&gt; dbsize(integer) 0keys * #查看数据库所有的key 清空当前数据库flushdb 清空全部数据库的内容flushall 思考：为什么 redis 是6379？（了解一下即可！） redis 是单线程的！明白Redis是很快的，官方表示，Redis是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所以就使用了单线程！ Redis 是C 语言写道，官方提供的数据为 100000+ 是QPS，完全不比同样是使用 key-value 的Mamecache差！ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文切换！）一定比单线程效率低！ 先去CPU》内存》硬盘的速度要有所了解！ 核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！ 五大数据类型Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 我们现在讲解的命令大家一定要全部记住，后面我们使用SpringBoot。Redis，所有的方法就是这些命令！单点登录 Redis-Key123456keys * #查看所有的keyEXIST name #判断当前的key是否存在move name 1 #移除当前的keyEXPIRE name 10 #设置key的过期时间，单位是秒ttl name #查看当前key的剩余时间type name #查看当前key的类型 后面如果遇到不会的命令，可以去官网查看帮助文档 String（字符串）90%的Java程序员 redis 只会使用一个String类型！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990set key1 v1 #设置值get key1 #获得值keys * #获得所有的keyEXISTS key1 #判断某一个key是否存在APPEND key1 #追加字符串，如果当前key不存在，就相当于setkeyget key1STRING key1 #获取字符串的长度#####################################################步长 i++127.0.0.1:6379&gt; set views 0 #初始浏览量为0OK127.0.0.1:6379&gt; incr views #自增1(integer) 1127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; get views&quot;2&quot;127.0.0.1:6379&gt; decr views #自减1(integer) 1127.0.0.1:6379&gt; decr views(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views&quot;-1&quot;127.0.0.1:6379&gt; INCRBY views 10 #可以设置步长，指定增量！(integer) 9127.0.0.1:6379&gt; INCRBY views 10(integer) 19127.0.0.1:6379&gt; DECRBY views 5 #可以设置步长，指定减量！(integer) 14######################################################字符串范围 range127.0.0.1:6379&gt; GETRANGE key1 0 4 #截取字符串[0-3]&quot;v1sss&quot;127.0.0.1:6379&gt; GETRANGE key1 0 -1 #获取全部的字符串和get key一样&quot;v1ssshelloworld&quot;#####################################################127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; SETRANGE key2 1 xx #替换指定位置开始的字符串！(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;###################################################### setex (set with expire) #设置过期时间# setnx (set if not exist) #不存在再设置（在分布式锁中会常常使用！）setex key3 30 hello #设置key3的值为hello，30秒后过期setnx mykey redis #如果mykey不存在，创建mykeystenx mykey mogodb #如果mykey存在，创建失败！#####################################################msetmget127.0.0.1:6379&gt; mset k1 v1 k2 v1 k3 v3 #同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k1&quot;3) &quot;k2&quot;127.0.0.1:6379&gt; mget k1 k2 k3 #同时获取多个值1) &quot;v1&quot;2) &quot;v1&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 #msetnx 是一个原子性的操作，要么一起成功，要么一起失败(integer) 0127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k1&quot;3) &quot;k2&quot;127.0.0.1:6379&gt; get k4(nil)# 对象set user:1&#123;name:zhangsan,age:3&#125; #设置一个user:1对象 值为json字符来保存一个对象！# 这里的key是一个巧妙的设计：user：&#123;id&#125;：&#123;field&#125;，如此设计在Redis中是完全OK了！127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;##############################################################getset # 先get在set127.0.0.1:6379&gt; getset db redis #如果不存在值，则返回 nil(nil)127.0.0.1:6379&gt; getset db mogodb #如果存在值，获取原来的值，并设置新的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mogodb&quot; 数据结构是相同的！ String类似的使用常见：value除了是我们的字符串还可以是我们的数字！ 计数器 统计多单位的数量 uid:829797897:follow 0 粉丝数 对象缓存存储 List基本的数据类型，列表 在redis里面，我们可以把list玩成，栈，队列，阻塞队列！ 所有的list命令都是用l开头的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156###################################################127.0.0.1:6379&gt; LPUSH list one #将一个值或者多个值，插入到列表头部(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -1 #获取list中的值1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; LRANGE list 0 1 #通过区间获取具体的值1) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; RPUSH list four #将一个值或者多个值，插入到列表尾部（右）(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;four&quot;###################################################LPOPRPOP127.0.0.1:6379&gt; LPOP list #移除列表的第一个元素&quot;three&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;four&quot;127.0.0.1:6379&gt; RPOP list #移除list的最后一个元素&quot;four&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;###################################################Lindex127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; LINDEX list 0 #通过下标获得list中的某一个值！&quot;two&quot;127.0.0.1:6379&gt; LINDEX list 1&quot;one&quot;###################################################Llen127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; LLEN list #返回列表的长度(integer) 4###################################################移除指定的值！取关 uid127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;four&quot;2) &quot;four&quot;3) &quot;three&quot;4) &quot;two&quot;5) &quot;one&quot;127.0.0.1:6379&gt; lrem list 1 one #移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; lrem list 2 four(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;###################################################trim 修剪：list 截断127.0.0.1:6379&gt; RPUSH mylist hello(integer) 1127.0.0.1:6379&gt; RPUSH mylist hello1(integer) 2127.0.0.1:6379&gt; RPUSH mylist hello2(integer) 3127.0.0.1:6379&gt; RPUSH mylist hello3(integer) 4127.0.0.1:6379&gt; LTRIM mylist 1 2 #通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;###################################################rpoplpush #移除列表的最后一个元素，将他移动到新的列表中！127.0.0.1:6379&gt; rpush mylist hello(integer) 1127.0.0.1:6379&gt; rpush mylist hello1(integer) 2127.0.0.1:6379&gt; rpush mylist hello12(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist #移除列表的最后一个元素，将他移动到新的列表中！&quot;hello12&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1 #查看原来的列表1) &quot;hello&quot;2) &quot;hello1&quot;127.0.0.1:6379&gt; keys *1) &quot;mylist&quot;2) &quot;myotherlist&quot;127.0.0.1:6379&gt; LRANGE myotherlist 0 -1 #查看目标列表中，确实存在该值1) &quot;hello12&quot;###################################################lset #将列表中只当下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; EXISTS list #判断这个列表是否存在(integer) 0127.0.0.1:6379&gt; lset list 0 item #如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379&gt; lpush list vvlue1(integer) 1127.0.0.1:6379&gt; LRANGE list 0 01) &quot;vvlue1&quot;127.0.0.1:6379&gt; lset list 0 item #如果存在，更新当前下标的值OK127.0.0.1:6379&gt; LRANGE list 0 01) &quot;item&quot;127.0.0.1:6379&gt; lset list 1 other #如果不存在，则会报错！(error) ERR index out of range###################################################linsert #将某个具体的value插入到列表中某个元素的前面或者后面127.0.0.1:6379&gt; RPUSH mylist hello(integer) 1127.0.0.1:6379&gt; RPUSH mylist world(integer) 2127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; LINSERT mylist before &quot;world&quot; &quot;other&quot;(integer) 3127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; LINSERT mylist after world new(integer) 4127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;4) &quot;new&quot; 小结 它实际上是一个链表，before Node after，left，right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增乃荣 弱国移除了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点~ 消息排列！消息队列 （Lpush Rpop），栈（Lpush Lpop）！ Set（集合）set中的值是不能重复的！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#####################################################127.0.0.1:6379&gt; sadd myset &quot;hello&quot; #set集合中添加元素(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;touchingwang&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset #查看指定set的所有值1) &quot;hello&quot;2) &quot;touchingwang&quot;3) &quot;world&quot;127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot; #判断某一个值是不是在set集合中！(integer) 1127.0.0.1:6379&gt; SISMEMBER myset &quot;worlds&quot;(integer) 0#####################################################127.0.0.1:6379&gt; SCARD myset #获取set集合中的内容元素个数！(integer) 3#####################################################127.0.0.1:6379&gt; SREM myset hello #移除set集合中的指定元素(integer) 1#####################################################set 无序不重复集合。抽随机！127.0.0.1:6379&gt; SMEMBERS myset1) &quot;touchingwang&quot;2) &quot;world&quot;127.0.0.1:6379&gt; SRANDMEMBER myset #随机抽选出一个元素&quot;touchingwang&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;touchingwang&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;world&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 2 #随机抽选出指定个数的元素#####################################################删除指定的key，随机删除key！127.0.0.1:6379&gt; spop myset #随机删除一些set集合中的元素！&quot;world&quot;127.0.0.1:6379&gt; SMEMBERS myset1) &quot;touchingwang&quot;#####################################################将一个指定的值移动到另外一个set集合中127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;touchingwang&quot;(integer) 1127.0.0.1:6379&gt; SMOVE myset myset2 touchingwang(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;touchingwang&quot;#####################################################微博，B站，共同关注！（并集）数字集合类： - 差集 - 交集 - 并集 127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2 #差集1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; SINTER key1 key2 #交集 共同好友就可以这样实现1) &quot;c&quot;127.0.0.1:6379&gt; SUNION key1 key2 #并集1) &quot;d&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;a&quot;5) &quot;e&quot; 微博，A用户将所有关注的人放到一个set集合中！将它的粉丝也放在一个集合中！ 共同关注，共同爱好，二度好友，推荐好友！（六度分割理论） Hash（哈希）Map集合，key-map！这时候这个值是一个mao集合！本质和String类型没有太大区别，还是一个简单的key-value！ set myhash field touchingwang 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364127.0.0.1:6379&gt; hset myhash field kuangshen #set一个具体key-value(integer) 1127.0.0.1:6379&gt; HGET myhash field #获取一个字段值&quot;kuangshen&quot;127.0.0.1:6379&gt; hmset myhash field hello field2 world #set多个key-valueOK127.0.0.1:6379&gt; HMGET myhash field field2 #获取多个字段值1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; HGETALL myhash #获取全部的数据1) &quot;field&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; HDEL myhash field #删除hash指定的key字段，对应的value值也就消失了！(integer) 1127.0.0.1:6379&gt; HGETALL myhash1) &quot;field2&quot;2) &quot;world&quot;#####################################################################hlen127.0.0.1:6379&gt; HGETALL myhash1) &quot;field2&quot;2) &quot;zhangsan&quot;3) &quot;field1&quot;4) &quot;hello&quot;5) &quot;field&quot;6) &quot;world&quot;127.0.0.1:6379&gt; hlen myhash #获取hash表的字段数量(integer) 3#####################################################################127.0.0.1:6379&gt; HEXISTS myhash field1 #判断hash中指定字段是否存在！(integer) 1127.0.0.1:6379&gt; HEXISTS myhash field3(integer) 0######################################################################只获取所有field#只获取所有value127.0.0.1:6379&gt; hkeys myhash #只获取所有field1) &quot;field2&quot;2) &quot;field1&quot;3) &quot;field&quot;127.0.0.1:6379&gt; hvals myhash #只获取所有value1) &quot;zhangsan&quot;2) &quot;hello&quot;3) &quot;world&quot;#####################################################################incr decr127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field3 1(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field3 -1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field4 hello #如果不存在则可以设置(integer) 1127.0.0.1:6379&gt; hsetnx myhash field4 world #如果存在则不能设置(integer) 0 hash变更的数据 user name age，尤其是用户信息之类的，经常变动的信息！hash更适合于对象的存储。String更适合字符串存储！ hset user:1 name kuangshen Zset（有序集合）在set的基础上，增加了一个值，set k1 v1 zset k1 score v1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364127.0.0.1:6379&gt; zadd myset 1 one #添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three #添加多个值(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;#####################################################排序如何实现127.0.0.1:6379&gt; zadd salary 2500 xiaohong #添加三个用户(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 500 kuangshen(integer) 1127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf #显示全部的用户 从小到大！1) &quot;kuangshen&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 #从大到小进行排序1) &quot;zhangsan&quot;2) &quot;kuangshen&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary 0 -1(empty array)127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores #显示全部的用户兵器附带成绩1) &quot;kuangshen&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;zhangsan&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores #显示工资小于2500员工的升序排序！1) &quot;kuangshen&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;###################################################### 移除rem中的元素127.0.0.1:6379&gt; zrange salary 0 -11) &quot;kuangshen&quot;2) &quot;zhangsan&quot;3) &quot;xiaohong&quot;127.0.0.1:6379&gt; zrem salary xiaohong #移除有序集合中的指定元素(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) &quot;kuangshen&quot;2) &quot;zhangsan&quot;127.0.0.1:6379&gt; ZCARD salary #获取有序集合中的个数(integer) 2#####################################################127.0.0.1:6379&gt; zadd myset 1 hello(integer) 1127.0.0.1:6379&gt; zadd myset 2 world 3 kuangshen(integer) 2127.0.0.1:6379&gt; ZCOUNT myset 1 3 #获取指定区间的成员数量(integer) 3127.0.0.1:6379&gt; ZCOUNT myset 1 2(integer) 2 其余的一些API，通过我们的学习，剩下的如果工作中有需要，这个时候你可以去查查看官方文档！ 案例思路：set 排序 存储班级成绩表，工资表排序！ 普通消息，1，重要消息，2，带权重进行判断！ 排行榜应用实现，取Top N 三种特殊数据类型geospatial地理位置朋友的定位，附近的人，打车举例计算? Redis的Geo在Redis3.2版本就推出了！这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！ 只有六个命令 getadd 1234567891011# getadd 添加地理位置# 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入# 参数 key 值（经度、纬度、地名）127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijin(integer) 1127.0.0.1:6379&gt; geoadd china:city 120.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shenzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2 geopos 获得当前定位：一定是一个坐标镇！ 123456127.0.0.1:6379&gt; GEOPOS china:city chongqi #获取指定的城市的经度，纬度！1) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; GEOPOS china:city xian1) 1) &quot;108.96000176668167114&quot; 2) &quot;34.25999964418929977&quot; geodist 两人之间的距离 单位： m：表示单位为米 km：表示单位为千米 mi：表示单位为英里 ft：表示单位为英尺 12345678127.0.0.1:6379&gt; GEODIST china:city beijin shanghai&quot;1031922.7612&quot;127.0.0.1:6379&gt; GEODIST china:city beijin shanghai km #查看北京到上海的直线距离&quot;1031.9228&quot;1) 1) &quot;chongqi&quot; 2) &quot;341.9374&quot; 3) 1) &quot;106.49999767541885376&quot; 2) &quot;29.52999957900659211&quot; georadius 以给定的经度为中心，找出某一半径内的元素 找附近的人？（获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人，200 12345127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord [count 1] #以110，30这个经纬度为中心，寻找方圆500km的城市 #withdist显示到中间距离的位置 #withcoord显示他人的定位信息 #count 2筛选出指定的结果 georadiusbymember 1234567# 找出位于指定元素周围的其他元素！127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1000 km1) &quot;beijin&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km1) &quot;hangzhou&quot;2) &quot;shanghai&quot; geohash命令 - 返回一个或多个位置的geohash表示 该命令将返回11个字符的geohash字符串！ 123127.0.0.1:6379&gt; GEOHASH china:city beijin chongqi1) &quot;wx4fbxxfke0&quot;2) &quot;wm5xzrybty0&quot; GEO 底层的实现原理其实就是Zset！我们可以使用Zset命令来操作geo！ 123456789101112131415127.0.0.1:6379&gt; ZRANGE china:city 0 -1 #查看地图中全部的元素1) &quot;chongqi&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijin&quot;127.0.0.1:6379&gt; zrem china:city beijin #移除指定元素(integer) 1127.0.0.1:6379&gt; ZRANGE china:city 0 -11) &quot;chongqi&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot; Hyperloglog 什么是基数？ A{1，3，5，7，8，7} B{1，3，5，7，8} 基数（不重复的元素） A为5，可以接收误差！ 简介 Redis2.8.9版本就更新了Hyperloglog数据结构！ Redis Hyperloglog 基数统计的算法！ 优点：占用的内存是固定的，2^64 不同的元素的技术，只需要费 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选 网页的UV（一个人访问一个网站多次，但是还是算作一个人！） 传统的方式，set 保存用户的 id，然后就可以统计 set 中的元素数量作为标准判断！ 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了技术，而不是保存用户id； 0.81%错误率！统计UV任务，可以忽略不计的！ 测试使用 1234567891011121314127.0.0.1:6379&gt; PFADD mykey a b c d e f g h i j #创建第一组元素 mykey(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey #统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m #创建第一组元素 mykey2(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey(integer) 10127.0.0.1:6379&gt; PFCOUNT mykey2(integer) 9127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 #合并两组 mykey mykey2 =&gt; mykey3 并集OK127.0.0.1:6379&gt; PFCOUNT mykey3 #查看并集的数量！(integer) 15 如果允许容错，那么一定可以使用 Hyperloglog！ 如果不允许容错，就使用 set 或者自己的数据类型即可！ Bitmaps 位存储 统计用户信息，活跃，不活跃！登录、未登录！打卡，365打卡！两个状态的，都可以使用Bitemaps！ Bitmaps 位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态！ 使用bitmap 来记录周一到周日的打卡! 周一：1 周二：0 周三：0 周四：1…… 1234567891011121314151617181920127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 0(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0127.0.0.1:6379&gt; getbit sign 3 #查看某一天是否打卡！(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0127.0.0.1:6379&gt; BITCOUNT sign #统计操作，统计打卡的天数！(integer) 3 事务Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！ 一次性、顺序性、排他性！执行一系列的命令！ 1--- 队列 set set set 执行--- ==Redis事务没有隔离级别的概念== 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec Redis单条命令是保存原子性的，但是事务不保证原子性！ redis 的事务： 开启事务（multi） 命令入队（） 执行事务（） 正常执行事务！ 12345678910111213141516127.0.0.1:6379&gt; multi #开启事务OK# 命令入队127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec #执行事务1) OK2) OK3) &quot;v2&quot;4) OK 放弃事务! 123456789101112127.0.0.1:6379&gt; MULTI #开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; DISCARD #取消事务OK127.0.0.1:6379&gt; get k4 #事务队列中的命令都不会被执行！(nil) 编译型异常（代码有问题！），事务中所有的命令都不会被执行！ 12345678910127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; getset k3 #错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379(TX)&gt; set k5 v5QUEUED127.0.0.1:6379(TX)&gt; exec #执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 #所有的命令都不会被执行！(nil) 运行时异常（1/0），如果事务队列中存在语法性错误，那么执行命令的时候，其他命令可以正常执行的 123456789101112131415161718192021127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; incr k1 #会执行的时候失败！QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; exec1) (error) ERR value is not an integer or out of range #虽然第一条命令报错了，但是依旧正常执行成功了！2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot; 监控！ 悲观锁： 很悲观，什么时候都不会出问题，无论做什么都会加锁！ 乐观锁： 很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！ 获取version 更新的时候比较 version redis 测监视测试 123456789101112131415127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; WATCH money #监视 money 对象OK127.0.0.1:6379&gt; MULTI #事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！OK127.0.0.1:6379(TX)&gt; DECRBY money 20QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 20QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 802) (integer) 20 测试多线程修改值，使用watch 可以当作redis的乐观锁操作！ 1234567891011121314151617181920212223127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; DECRBY money 10QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10QUEUED127.0.0.1:6379(TX)&gt; exec #执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！(nil)127.0.0.1:6379&gt; unwatch #如果发现事务执行失败，就先解锁OK127.0.0.1:6379&gt; watch money #获取最新的值，再次监视，select versionOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; DECRBY money 10QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10QUEUED127.0.0.1:6379(TX)&gt; exec #比对监视的值是否发生了变化，如果没有变化，那么可以执行成功，如果变化就执失败！1) (integer) 9902) (integer) 30 Jedis我们要使用Java来操作 Redis 什么是jedis 是Redis官方推荐的java连接开发工具！使用 java 操作 Redis 中间件！ 如果你要使用java操作redis，那么一定要对jedis十分的熟悉！ 测试 1、导入对应的依赖 1234567891011121314&lt;!--导入jedis的包--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.76&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、编码测试： 连接数据库 操作命令 断开连接！ 12345678910111213package com.wang;import redis.clients.jedis.Jedis;public class TestPing &#123; public static void main(String[] args) &#123; //1/ new Jedis 对象即可 Jedis jedis = new Jedis(&quot;**.**.**.**&quot;, 6379); jedis.auth(&quot;**&quot;); //jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！ System.out.println(jedis.ping()); &#125;&#125; 远程连接可能会出现的问题 开启安全组策略6379，bing注释只留一个，受保护的设置为no，防火墙关掉，重启 设置requirepass密码，登录查看是否修改成功 常用的API对一些常用命令的操作 1234567891011121314151617181920212223242526272829public class TestPing &#123; public static void main(String[] args) &#123; //1. new Jedis 对象即可 Jedis jedis = new Jedis(&quot;**.**.**.**&quot;, 6379); jedis.auth(&quot;**&quot;); //jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！ System.out.println(jedis.ping()); System.out.println(&quot;清空数据库：&quot;+jedis.flushDB()); System.out.println(&quot;判断某个键是否存在：&quot;+jedis.exists(&quot;k1&quot;)); System.out.println(&quot;新增k1,v1键值对：&quot;+jedis.set(&quot;k1&quot;,&quot;v1&quot;)); System.out.println(&quot;新增k2,v2键值对：&quot;+jedis.set(&quot;k2&quot;,&quot;v2&quot;)); System.out.println(&quot;获得k1键的值：&quot;+jedis.get(&quot;k1&quot;)); System.out.println(&quot;系统中所有的键如下：&quot;); Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); System.out.println(keys); System.out.println(&quot;删除键k2：&quot;+jedis.del(&quot;k2&quot;)); System.out.println(&quot;判断键k2是否存在：&quot;+jedis.exists(&quot;k2&quot;)); System.out.println(&quot;查看键 k1 所存储的数据类型：&quot;+jedis.type(&quot;k1&quot;)); System.out.println(&quot;随机返回 key 空间的一个：&quot;+jedis.randomKey()); System.out.println(&quot;重命名 key ：&quot;+jedis.rename(&quot;k1&quot;,&quot;newk1&quot;)); System.out.println(&quot;取出改后的 newk1 ：&quot;+jedis.get(&quot;newk1&quot;)); System.out.println(&quot;按索引查询：&quot;+jedis.select(0)); System.out.println(&quot;删除当前选择数据库中的所有键：&quot;+jedis.flushDB()); System.out.println(&quot;返回当前数据库中 key 的数量：&quot;+jedis.dbSize()); System.out.println(&quot;删除所有数据库中的所有 key ：&quot;+jedis.flushAll()); &#125;&#125; 对 String 操作的命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TestPing &#123; public static void main(String[] args) &#123; //1. new Jedis 对象即可 Jedis jedis = new Jedis(&quot;**.**.**.**&quot;, 6379); jedis.auth(&quot;**&quot;); //jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！ System.out.println(jedis.ping()); jedis.flushDB(); System.out.println(&quot;=========增加数据========&quot;); System.out.println(jedis.set(&quot;k1&quot;,&quot;v1&quot;)); System.out.println(jedis.set(&quot;k2&quot;,&quot;v2&quot;)); System.out.println(jedis.set(&quot;k3&quot;,&quot;v3&quot;)); System.out.println(&quot;删除键k2：&quot;+jedis.del(&quot;k2&quot;)); System.out.println(&quot;获取键k2：&quot;+jedis.del(&quot;k2&quot;)); System.out.println(&quot;修改k1：&quot;+jedis.set(&quot;k1&quot;,&quot;v1changed&quot;)); System.out.println(&quot;获取k1的值：&quot;+jedis.get(&quot;k1&quot;)); System.out.println(&quot;在k3后面加入值：&quot;+jedis.append(&quot;k3&quot;,&quot;End&quot;)); System.out.println(&quot;获取k3的值：&quot;+jedis.get(&quot;k3&quot;)); System.out.println(&quot;增加多个键值对：&quot;+jedis.mset(&quot;k01&quot;,&quot;v01&quot;,&quot;k02&quot;,&quot;v02&quot;,&quot;k03&quot;,&quot;v03&quot;)); System.out.println(&quot;获取多个键值对：&quot;+jedis.mget(&quot;k01&quot;,&quot;k02&quot;,&quot;k03&quot;)); System.out.println(&quot;删除多个键值对：&quot;+jedis.del(&quot;k01&quot;,&quot;k02&quot;)); System.out.println(&quot;获取多个键值对：&quot;+jedis.mget(&quot;k01&quot;,&quot;k02&quot;,&quot;k03&quot;)); jedis.flushDB(); System.out.println(&quot;=========增加键值对防止覆盖原先值========&quot;); System.out.println(jedis.setnx(&quot;k1&quot;,&quot;v1&quot;)); System.out.println(jedis.setnx(&quot;k1&quot;,&quot;v2&quot;)); System.out.println(jedis.setnx(&quot;k1&quot;,&quot;v2-new&quot;)); System.out.println(jedis.get(&quot;k1&quot;)); System.out.println(jedis.get(&quot;k2&quot;)); System.out.println(&quot;=========增加键值对并设置有效时间========&quot;); System.out.println(jedis.setex(&quot;k3&quot;,2,&quot;v3&quot;)); System.out.println(jedis.get(&quot;k3&quot;)); try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(jedis.get(&quot;k3&quot;)); System.out.println(&quot;=========获取原值，更新为新值========&quot;); System.out.println(jedis.getSet(&quot;k2&quot;,&quot;k2GetSet&quot;)); System.out.println(jedis.get(&quot;k2&quot;)); System.out.println(&quot;获得k2的值的字符串：&quot;+jedis.getrange(&quot;k2&quot;,2,4)); &#125;&#125; 对 List 操作的命令 对 Set操作的命令 对 Hash操作的命令 对 Zset操作的命令 所有的API命令就是我们对应的上面学习的指令，一个都没有变化！ 事务 12345678910111213141516171819202122232425262728Jedis jedis = new Jedis(&quot;**.**.**.**&quot;, 6379);jedis.auth(&quot;**&quot;);JSONObject jsonObject = new JSONObject();jsonObject.put(&quot;hello&quot;,&quot;world&quot;);jsonObject.put(&quot;name&quot;,&quot;touchingWang&quot;);jedis.flushDB();//开始事务Transaction multi = jedis.multi();String result = jsonObject.toJSONString();try &#123; multi.set(&quot;user1&quot;,result); multi.set(&quot;user2&quot;,result); int i = 1/0;//代码抛出异常，事务执行失败 multi.exec(); //执行事务&#125; catch (Exception e) &#123; multi.discard(); //放弃事务 e.printStackTrace();&#125; finally &#123; System.out.println(jedis.get(&quot;user1&quot;)); System.out.println(jedis.get(&quot;user2&quot;)); jedis.close(); //关闭连接&#125;jedis.close(); SpringBoot整合SpringBoot 操作数据：Spring-data jdbc monodb redis！ SpringData 也是和 SpringBoot齐名的项目！ 说明：在Springboot2.x之后，原来使用的jedis被替换为了lettuce？ jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！BIO lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据，更像NIO模式 整合测试一下 1、导入依赖 12345&lt;!--操作redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置连接 123# 配置redisspring.redis.host=127.0.0.1spring.redis.port=6379 3、测试 123456789101112131415161718192021222324252627@SpringBootTestclass Redis02SpringbootApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() &#123; //redisTemplate 操作不同的数据类型，api和我们的指令是一样的 //opsForValue 操作字符串 类似String //opsForList 操作List 类似List //opsForSet //opsForHash //opsForZSet //opsForGeo //opsForHyperLogLog //除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;touchingWang&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;)); &#125;&#125; 所有的对象，都需要序列化 默认的序列化方式是JDK序列，我们可能会使用json来序列化！ 关于对象的保存：在企业中，所有的 pojo 都会序列化！我们来编写一个自己的RedisTemplate 123456789101112131415161718192021222324252627282930313233@Configurationpublic class RedisConfig &#123; //编写我们自己的 redisTemplate @Bean// @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123; //我们为了自己开发方便，一般直接使用&lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); //序列化配置 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); //hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); //hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; 所有的redis操作，其实对于java开发人员来说，更重要的是去理解redis的思想和每一种数据结构的用户和作用场景！ redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7SB","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"Redis缓存穿透和雪崩","date":"2021-06-16T18:59:42.994Z","path":"2021/06/17/Redis缓存穿透和雪崩/","text":"Redis缓存穿透和雪崩Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。 缓存穿透（查不到）缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 解决方案： 布隆过滤器布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力； 缓存空对象当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源 但是这种方法会存在两个问题： 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键； 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一直一致性的业务会有影响。 缓存击穿（量太大，缓存过期）这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，这就像一个屏障上凿开一个洞。 当某个key的过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。 解决方案： 设置热点数据永不过期从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。 加互斥锁分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考研很大。 缓存雪崩缓存雪崩，是指在某一个时间段，缓存其中过期失效。Redis宕机！ 产生雪崩的原因之一，比如在写文本的时候，马上就要到双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时间，这批商品的缓存就都勾起了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会到达存储曾，存储层的调用量会暴增，造成存储层也会挂掉的情况。 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。 双十一：停掉一些服务，（保证主要的服务） 解决方案： redis高可用这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活） 限流降级这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 redis系列来自b站up主狂神说Java https://www.bilibili.com/video/BV1S54y1R7SB","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"pat1028","date":"2021-06-13T02:03:38.463Z","path":"2021/06/13/pat1028/","text":"1028. ⼈⼝普查(20) [查找元素]某城镇进⾏⼈⼝普查，得到了全体居⺠的⽣⽇。现请你写个程序，找出镇上最年⻓和最年轻的⼈。这⾥确保每个输⼊的⽇期都是合法的，但不⼀定是合理的——假设已知镇上没有超过200岁的⽼⼈，⽽今天是2014年9⽉6⽇，所以超过200岁的⽣⽇和未出⽣的⽣⽇都是不合理的，应该被过滤掉。 输⼊格式： 输⼊在第⼀⾏给出正整数N，取值在(0, 10^5]；随后N⾏，每⾏给出1个⼈的姓名（由不超过5个英⽂字⺟组成的字符串）、以及按“yyyy/mm/dd”（即年/⽉/⽇）格式给出的⽣⽇。题⽬保证最年⻓和最年轻的⼈没有并列。 输出格式： 在⼀⾏中顺序输出有效⽣⽇的个数、最年⻓⼈和最年轻⼈的姓名，其间以空格分隔。 输⼊样例： 1234565John 2001/05/12Tom 1814/09/06Ann 2121/01/30James 1814/09/05Steve 1967/11/20 输出样例： 13 Tom John 分析：⽤字符串接收name和birth，如果当前birth &gt;= “1814/09/06″且&lt;= “2014/09/06″，则是有效⽣⽇， 有效个数cnt++，如果birth &gt;= maxbirth，则更新maxname和maxbirth的值；如果birth &lt;= minbirth，则更新minname和minbirth的值，这⾥的max和min是指数值上的⼤⼩～最后输出cnt，minname和 maxname，minname表示最年⻓的（⽣⽇的数值⼤⼩最⼩的），maxname表示最年轻的（⽣⽇的数值 ⼤⼩最⼤的）～ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; string name, birth, maxname, minname, maxbirth = &quot;1814/09/06&quot;, minbirth = &quot;2014/09/06&quot;; //用字符串存储这一步太牛了 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; birth; if (birth &gt;= &quot;1814/09/06&quot; &amp;&amp; birth &lt;= &quot;2014/09/06&quot;) &#123; cnt++; if (birth &gt;= maxbirth) &#123; maxbirth = birth; maxname = name; &#125; if (birth &lt;= minbirth) &#123; minbirth = birth; minname = name; &#125; &#125; &#125; cout &lt;&lt; cnt; if (cnt != 0) cout &lt;&lt; &quot; &quot; &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; maxname; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#50;&#x33;&#48;&#52;&#55;&#48;&#51;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1027","date":"2021-06-13T02:01:41.297Z","path":"2021/06/13/pat1027/","text":"1027. 打印沙漏(20) [图形打印]本题要求你写个程序把给定的符号打印成沙漏的形状。 例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每⾏输出奇数个符号；各⾏符号中⼼对⻬； 相邻两⾏符号数差2；符号数先从⼤到⼩顺序递减到1，再从⼩到⼤顺序递增；⾸尾符号数相等。 给定任意N个符号，不⼀定能正好组成⼀个沙漏。要求打印出的沙漏能⽤掉尽可能多的符号。 输⼊格式： 输⼊在⼀⾏给出1个正整数N（&lt;=1000）和⼀个符号，中间以空格分隔。 输出格式： ⾸先打印出由给定符号组成的最⼤的沙漏形状，最后在⼀⾏中输出 剩下没⽤掉的符号数。 输⼊样例： 119 * 输出样例： 123456*****************2 分析：n保存E后⾯的字符串所对应的数字，t保存E前⾯的字符串，不包括符号位。当n&lt;0时表示向前移 动，那么先输出0. 然后输出abs(n)-1个0，然后继续输出t中的所有数字；当n&gt;0时候表示向后移动，那 么先输出第⼀个字符，然后将t中尽可能输出n个字符，如果t已经输出到最后⼀个字符(j == t.length())那 么就在后⾯补n-cnt个0，否则就补充⼀个⼩数点. 然后继续输出t剩余的没有输出的字符～ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; int N, row = 0; char c; cin &gt;&gt; N &gt;&gt; c; for (int i = 0; i &lt; N; i++) &#123; if ((2 * i * (i + 2) + 1) &gt; N) &#123; row = i - 1; break; &#125; &#125; for (int i = row; i &gt;= 1; i--) &#123; for (int k = row - i; k &gt;= 1; k--) cout &lt;&lt; &quot; &quot;; for (int j = i * 2 + 1; j &gt;= 1; j--) cout &lt;&lt; c; cout &lt;&lt; endl; &#125; for (int i = 0; i &lt; row; i++) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; c &lt;&lt; endl; for (int i = 1; i &lt;= row; i++) &#123; for (int k = row - i; k &gt;= 1; k--) cout &lt;&lt; &quot; &quot;; for (int j = i * 2 + 1; j &gt;= 1; j--) cout &lt;&lt; c; cout &lt;&lt; endl; &#125; cout &lt;&lt; (N - (2 * row * (row + 2) + 1)); return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#51;&#x30;&#52;&#55;&#48;&#51;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux上java环境安装","date":"2021-06-03T07:58:39.393Z","path":"2021/06/03/Linux上java环境安装/","text":"Linux上java环境安装安装软件一般有三种方式：rpm（jdk）、解压缩（tomcat）、yum在线安装（docker）！ rpm（jdk：在线发布一个springboot项目） 解压缩：（tomcat，启动并通过外网风闻，发布网站） yum在线安装（docker：直接安装运行排气量docker就可以！） JDK安装我们开发java程序必须要的环境！ 下载JDK rpm。去oracle官网下载即可！ 安装 java 环境 1234567# 检测当前系统是否存在java环境！java -version# 如果有的话就需要卸载# rpm -qa|grep jak # 检测JDK版本信息# rpm -e --nodeps jdk_# 卸载完毕后即可安装jdk# rpm -ivh jdk** 配置环境变量：/etc/profile在文件的最后面增加 java 的配置 1234JAVA_HOME=/usr/java/jdk1.8.0_291-amd64PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 让这个配置文件生效！source /etc/profile 我们来发布一个项目试试！ 123456# 开启防火墙端口firewall-cmd --zone=public --add-port=9000/tcp --permanent# 重启防火墙systemctl restart firewalld.service# 查看所有开启的端口，如果是阿里云，需要配置安全组规则！firewall-cmd --lsit-ports Tomcat安装ssm war 就需要放到 tomcat 中运行 下载tomcat。官网下载即可tomcat9. apache-tomcat-9.0.46.tar.gz 解压这个文件 1tar -zxvf apache-tomcat-9.0.46.tar.gz 启动 tomcat 测试！./xxx.sh 脚本即可运行 12#执行 ./startup.sh#停止 ./shutdown.sh 如果防火墙 8080 端口开了并且阿里云安全组也开放了这个时候就可以直接访问远程了！ 1234567891011121314151617181920212223# 查看firewall服务状态systemctl status firewalld# 开启，重启，关闭firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 查看端口信息# 开启端口开端口命令： firewall-cmd --zone=public --add-port=8080/tcp --permanent重启防火墙： systemctl restart firewalld.service# 命令含义--zone # 作用域--add-port=80/tcp # 添加端口，格式为：端口/通讯协议--permanent # 永久生效，没有此参数重启后失效 上传完毕的项目直接购买自己的域名，备案解析过去即可！1 年级都会 域名解析后，如果端口是80 -http 或者 443-https，如果是9000 8080，就需要通过Apache或者Nginx做一个反向代理即可，配置文件即可，十分简单，大家如果想要上线自己的网站，到目前为之，那么你可以如愿以偿了！ Docker（yum安装）官网安装参考手册 我们现在是在Linux下执行，一定要联网，yum在线安装！ 安装 检测CentOS 7 12[root@touchingwang bin]# cat /etc/redhat-releaseCentOS Linux release 7.7.1908 (Core) 安装我们的准备环境 123yum -y install 包名 # yum install 安装命令 -y 所有的提示都为 yyum -y install gccyum -y install gcc-c++ 清除以前的版本！后面根据官网安装即可，我就不在这里写了 宝塔面板","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"pat1023","date":"2021-06-01T13:56:53.902Z","path":"2021/06/01/pat1023/","text":"1023. 组个最⼩数 (20) [贪⼼算法]给定数字0-9各若⼲个。你可以以任意顺序排列这些数字，但必须全部使⽤。⽬ 标是使得最后得到的数尽可能⼩（注意0不能做⾸位）。例如：给定两个0， 两个1，三个5，⼀个8，我们得到的最⼩的数就是10015558。 现给定数字，请编写程序输出能够组成的最⼩的数。 输⼊格式： 每个输⼊包含1个测试⽤例。每个测试⽤例在⼀⾏中给出10个⾮负整数，顺序表示我们拥 有数字0、数字1、……数字9的个数。整数间⽤⼀个空格分隔。10个数字的总个数不超过50， 且⾄少拥有1个⾮0的数字。 输出格式： 在⼀⾏中输出能够组成的最⼩的数。 输⼊样例： 12 2 0 0 0 3 0 0 1 0 输出样例： 110015558 分析：将数字0、数字1、……数字9的个数分别保存在数组a[i]中，因为0不能做⾸位，所以⾸先将i从1 到9输出第⼀个a[i]不为0的数字 i ，并将这个 i 保存在变量 t 中，接着输出a[0]个0，最后输出a[t]-1个 t（因为⼀个 t 已经被放在⾸位输出过⼀次了～） ，最后 i 从 t+1 到 9 输出 a[i] 个 i ～ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int a[10], t; for (int i = 0; i &lt; 10; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt; 10; i++) &#123; if (a[i] != 0) &#123; cout &lt;&lt; i; t = i; break; &#125; &#125; for (int i = 0; i &lt; a[0]; i++) cout &lt;&lt; 0; for (int i = 0; i &lt; a[t] - 1; i++) cout &lt;&lt; t; for (int i = t + 1; i &lt; 10; i++) for (int k = 0; k &lt; a[i]; k++) cout &lt;&lt; i; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#48;&#x32;&#x33;&#48;&#x34;&#55;&#x30;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1024","date":"2021-06-01T13:56:53.902Z","path":"2021/06/01/pat1024/","text":"1024. 科学计数法 (20) [字符串处理]科学计数法是科学家⽤来表示很⼤或很⼩的数字的⼀种⽅便的⽅法，其满⾜正则表达式[+-][1-9]”.”[0- 9]+E[+-][0-9]+，即数字的整数部分只有1位，⼩数部分⾄少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，并保证所有有效位都被保留。 输⼊样例： 每个输⼊包含1个测试⽤例，即⼀个以科学计数法表示的实数A。该数字的存储⻓度不超过9999字节， 且其指数的绝对值不超过9999。 输出格式： 对每个测试⽤例，在⼀⾏中按普通数字表示法输出A，并保证所有有效位都被保留，包括末尾的0。 输⼊样例1： 1+1.23400E-03 输出样例1： 10.001234001103 输⼊样例2： 1-1.2E+10 输出样例2： 1-12000000000 分析：n保存E后⾯的字符串所对应的数字，t保存E前⾯的字符串，不包括符号位。当n&lt;0时表示向前移 动，那么先输出0. 然后输出abs(n)-1个0，然后继续输出t中的所有数字；当n&gt;0时候表示向后移动，那 么先输出第⼀个字符，然后将t中尽可能输出n个字符，如果t已经输出到最后⼀个字符(j == t.length())那 么就在后⾯补n-cnt个0，否则就补充⼀个⼩数点. 然后继续输出t剩余的没有输出的字符～ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int i = 0; while (s[i] != &#x27;E&#x27;) i++; string t = s.substr(1, i-1); int n = stoi(s.substr(i+1)); if (s[0] == &#x27;-&#x27;) cout &lt;&lt; &quot;-&quot;; if (n &lt; 0) &#123; cout &lt;&lt; &quot;0.&quot;; for (int j = 0; j &lt; abs(n) - 1; j++) cout &lt;&lt; &#x27;0&#x27;; for (int j = 0; j &lt; t.length(); j++) if (t[j] != &#x27;.&#x27;) cout &lt;&lt; t[j]; &#125; else &#123; cout &lt;&lt; t[0]; int cnt, j; for (j = 2, cnt = 0; j &lt; t.length() &amp;&amp; cnt &lt; n; j++, cnt++) cout &lt;&lt; t[j]; if (j == t.length()) &#123; for (int k = 0; k &lt; n - cnt; k++) cout &lt;&lt; &#x27;0&#x27;; &#125; else &#123; cout &lt;&lt; &#x27;.&#x27;; for (int k = j; k &lt; t.length(); k++) cout &lt;&lt; t[k]; &#125; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#50;&#51;&#48;&#52;&#x37;&#x30;&#x33;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1026","date":"2021-06-01T13:56:35.712Z","path":"2021/06/01/pat1026/","text":"1026. 程序运⾏时间(15) [模拟]要获得⼀个C语⾔程序的运⾏时间，常⽤的⽅法是调⽤头⽂件time.h，其中提供了clock()函数， 可以捕捉从程序开始运⾏到clock()被调⽤时所耗费的时间。这个时间单位是clock tick， 即“时钟打点”。同时还有⼀个常数CLK_TCK，给出了机器时钟每秒所⾛的时钟打点数。于是为了 获得⼀个函数f的运⾏时间，我们只要在调⽤ f 之前先调⽤clock()，获得⼀个时钟打点数C1； 在f执⾏完成后再调⽤clock()，获得另⼀个时钟打点数C2；两次获得的时钟打点数之差(C2-C1)就是f运⾏所消耗的时钟打点数，再除以常数CLK_TCK，就得到了以秒为单位的运⾏时间。 这⾥不妨简单假设常数CLK_TCK为100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运⾏的时间。 输入格式： 输⼊在⼀⾏中顺序给出2个整数C1和C2。注意两次获得的时钟打点数肯定不相同，即C1 &lt; C2， 并且取值在[0, 10^7]。 输出格式： 在⼀⾏中输出被测函数运⾏的时间。运⾏时间必须按照“hh:mm:ss”（即2位的“时:分:秒”） 格式输出；不⾜1秒的时间四舍五⼊到秒。 输⼊样例： 1123 4577973 输出样例： 112:42:59 分析：n表示运⾏的时间，n为(b-a)/100，因为常数CLK_TCK为100，题⽬要求不⾜1秒的时间四舍五⼊到秒，所以先给(b-a)加上50，这样如果(b-a)/100的⼩数位⼤于等于0.5则会进位，⼩于等于0.5则会舍 去，所以n = ((b – a) + 50) / 100，因为要把秒数n化为时:分:秒的格式，⼀⼩时等于3600秒，所以hour = n / 3600，此时将n % 3600即为剩下的分钟和秒数；因为⼀分钟等于60秒，所以minute = n / 60，则n % 60剩下的就是秒，最后⽤printf的%02d格式⾃动为不⾜2位的整数在前⾯补上0，保证能够按照格式输出～ 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int n = ((b - a) + 50) / 100; int hour = n / 3600; n = n % 3600; int minute = n / 60, second = n % 60; printf(&quot;%02d:%02d:%02d&quot;, hour, minute, second); return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#48;&#x32;&#51;&#48;&#x34;&#x37;&#x30;&#51;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1025","date":"2021-06-01T13:46:53.390Z","path":"2021/06/01/pat1025/","text":"1025. 反转链表 (25) [链表]给定⼀个常数K以及⼀个单链表L，请编写程序将L中每K个结点反转。 例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4； 如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。 输⼊格式： 每个输⼊包含1个测试⽤例。每个测试⽤例第1⾏给出第1个结点的地址、 结点总个数正整数N(&lt;= 10^5)、以及正整数K(&lt;=N)， 即要求反转的⼦链结点的个数。结点的地址是5位⾮负整数，NULL地址⽤-1表示。 接下来有N⾏，每⾏格式为： Address Data Next 其中Address是结点地址，Data是该结点保存的整数数据，Next是下⼀结点的地址。 输出格式： 对每个测试⽤例，顺序输出反转后的链表，其上每个结点占⼀⾏，格式与输⼊相同。 输⼊样例： 123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例： 12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 分析：这道题看了还是比较难的，不太理解他怎么定义 list 的，从给出的代码可以看出，list 起到了给链表自动连接起来，之后就是反转 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int first, k, n, temp; cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; int data[100005], next[100005], list[100005]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; cin &gt;&gt; data[temp] &gt;&gt; next[temp]; &#125; int sum = 0;//不⼀定所有的输⼊的结点都是有⽤的，加个计数器 while (first != -1) &#123; list[sum++] = first; first = next[first]; &#125; for (int i = 0; i &lt; (sum - sum % k); i += k) reverse(begin(list) + i, begin(list) + i + k); for (int i = 0; i &lt; sum - 1; i++) printf(&quot;%05d %d %05d\\n&quot;, list[i], data[list[i]], list[i + 1]); printf(&quot;%05d %d -1&quot;, list[sum - 1], data[list[sum - 1]]); return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#x30;&#x32;&#51;&#x30;&#x34;&#55;&#x30;&#x33;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux磁盘管理进程管理","date":"2021-06-01T04:45:46.566Z","path":"2021/06/01/Linxu磁盘管理继进程管理/","text":"磁盘管理Linux磁盘管理好换直接关系到整个系统的性能问题 Linux磁盘管理常用三个命令为 df、du 和 fdisk. df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 dfdf 命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 1df [-ahikHTm] [目录或文件名] 选项与参数： -a：列出所有的文件系统，包括系统特有的/proc等文件系统； -k：以KBytes的容量显示各文件系统； -m：以MBytes的容量显示各文件系统； -h：以人们较易阅读的GBytes, MBytes, KBytes等格式自行显示； -H：以 M=1000K 取代 M=1024K 的进位方式； -T：显示文件系统类型, 连同该partition的filesystem名称 (例如 ext3) 也列出； -i：不用硬盘容量，而以inode的数量来显示 123456789[root@touchingwang ~]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 858M 0 858M 0% /devtmpfs 868M 0 868M 0% /dev/shmtmpfs 868M 640K 867M 1% /runtmpfs 868M 0 868M 0% /sys/fs/cgroup/dev/vda1 40G 2.0G 36G 6% /tmpfs 174M 0 174M 0% /run/user/0tmpfs 174M 0 174M 0% /run/user/1000 duLinux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的，这里介绍了 Linux du 命令 1du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。 12345678910# 检查根目录底下每个目录所占用的容量[root@www ~]# du -sm /*7 /bin6 /boot.....中间省略....0 /proc.....中间省略....1 /tmp3859 /usr &lt;==系统初期最大就是他了啦！77 /var fdiskfdisk 是 Linux 的磁盘分区表操作工具。 语法： 1fdisk [-l] 装置名称 选项与参数： -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 123456789101112# 列出所有分区信息[root@touchingwang ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0002b49c Device Boot Start End Blocks Id System/dev/vda1 * 2048 83886046 41941999+ 83 Linux 进程管理对于我们开发人员来说，其实Linux更多偏向于使用即可！ 什么是进程 在Linux中，每一个进程都是有自己的一个进程，每一个进程都有一个 id 号！ 每一个进程都会有一个父进程！ 进程可以有两种存在方式：前台！后台运行！ 一般的话服务都是后台运行的，基本的程序都是前台运行的！ 命令ps 查看当前系统中正在执行的各种进程的信息！ ps -xx： -a：显示当前终端运行的所有的进程信息 -u：以用户的信息显示进程 -x：显示后台运行进程的参数！ 123456ps -aux # 查看所有的进程ps -aux |grep mysql ps -aux |grep redis # | 在Linux这个叫做管道符 A|B # grep 查找文件中符合条件的字符串！ 对于我们来说，这里只需要记住一个命令即可，ps -xx|grep 进程名字！过滤进程信息！ ps -ef：可以查看到父进程的信息 123456ps -ef|grep mysql #看父进程我们一般可以通过目录结构来查看！# 进程树pstree -p 显示父id -u 显示用户组 结束进程：杀掉进程，等价于 window 结束任务！ kill -9 进程id 我们平时写的一些java代码死循环了，可以选择结束进程。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"pat1021","date":"2021-05-09T07:44:16.111Z","path":"2021/05/09/pat1021/","text":"1021. 个位数统计 (15) [字符串处理]给定⼀个k位整数N = dk-110k-1 + … + d1101 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如： 给定N = 100311，则有2个0，3个1，和1个3。 输⼊格式： 每个输⼊包含1个测试⽤例，即⼀个不超过1000位的正整数N。 输出格式： 对N中每⼀种不同的个位数字，以D:M的格式在⼀⾏中输出该位数字D及其在N中出现的次数M。 要求按D的升序输出。 输⼊样例： 1100311 输出样例： 1230:21:33:1 分析：因为N为不超过1000位的正整数，所以⽤字符串s来接收N，遍历字符串中的每个字符，将每个数字出现的次数保存在数组a中，a[i]表示数字i出现的次数，最后将数组a的下标0-9中所有a[i]不为0的 输出即可～ 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int a[10] = &#123;0&#125;; for (int i = 0; i &lt; s.length(); i++) a[s[i] - &#x27;0&#x27;]++; for (int i = 0; i &lt; 10; i++) &#123; if (a[i] != 0)printf(&quot;%d:%d\\n&quot;, i, a[i]); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#51;&#x30;&#52;&#55;&#48;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1020","date":"2021-05-09T07:44:16.063Z","path":"2021/05/09/pat1020/","text":"1020. ⽉饼 (25) [贪⼼算法]⽉饼是中国⼈在中秋佳节时吃的⼀种传统⻝品，不同地区有许多不同⻛味的⽉饼。现给定所有种类⽉ 饼的库存量、总售价、以及市场的最⼤需求量，请你计算可以获得的最⼤收益是多少。 注意：销售时允许取出⼀部分库存。样例给出的情形是这样的：假如我们有3种⽉饼，其库存量分别为 18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最⼤需求量只有20万吨，那么我们最⼤ 收益策略应该是卖出全部15万吨第2种⽉饼、以及5万吨第3种⽉饼，获得 72 + 45/2 = 94.5（亿元）。 输⼊格式： 每个输⼊包含1个测试⽤例。每个测试⽤例先给出⼀个不超过1000的正整数N表示⽉饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最⼤需求量。随后⼀⾏给出N个正数表示每种⽉饼的库存量（以万吨为单位）；最后⼀⾏给出N个正数表示每种⽉饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： 对每组测试⽤例，在⼀⾏中输出最⼤收益，以亿元为单位并精确到⼩数点后2位。 输⼊样例： 1233 2018 15 1075 72 45 输出样例： 194.50 分析：⾸先根据⽉饼的总价和数量计算出每⼀种⽉饼的单价，然后将⽉饼数组按照单价从⼤到⼩排序，根据需求量need的⼤⼩，从单价最⼤的⽉饼开始售卖，将销售掉这种⽉饼的价格累加到result中， 最后输出result即可～ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct mooncake&#123; //相当于定义了一个静态类 float mount, price, unit;&#125;;int cmp(mooncake a, mooncake b) &#123; return a.unit &gt; b.unit;&#125;int main() &#123; int n, need; cin &gt;&gt; n &gt;&gt; need; vector&lt;mooncake&gt; a(n); for (int i = 0; i &lt; n; i++) scanf(&quot;%f&quot;, &amp;a[i].mount); for (int i = 0; i &lt; n; i++) scanf(&quot;%f&quot;, &amp;a[i].price); for (int i = 0; i &lt; n; i++) a[i].unit = a[i].price / a[i].mount; sort(a.begin(), a.end(), cmp); float result = 0.0; for (int i = 0; i &lt; n; i++) &#123; if (a[i].mount &lt;= need) &#123; result = result + a[i].price; &#125; else &#123; result = result + a[i].unit * need; break; &#125; need = need - a[i].mount; &#125; printf(&quot;%.2f&quot;,result); return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#51;&#48;&#x34;&#55;&#48;&#51;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1022","date":"2021-05-09T07:44:16.054Z","path":"2021/05/09/pat1022/","text":"1022. D进制的A+B (20) [进制转换]输⼊两个⾮负10进制整数A和B(&lt;=2^30-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。 输⼊格式： 输⼊在⼀⾏中依次给出3个整数A、B和D。 输出格式： 输出A+B的D进制数。 输⼊样例： 1123 456 8 输出样例： 11103 分析：设t = A + B，将每⼀次t % d的结果保存在int类型的数组s中，然后将t / d，直到 t 等于 0为⽌，此 时s中保存的就是 t 在 D 进制下每⼀位的结果的倒序，最后倒序输出s数组即可～ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; int t = a + b; if (t == 0) &#123; cout &lt;&lt; 0; return 0; &#125; int s[100]; int i = 0; while (t != 0) &#123; s[i++] = t % d; t = t / d; &#125; for (int j = i - 1; j &gt;= 0; j--) cout &lt;&lt; s[j]; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#x33;&#48;&#52;&#x37;&#48;&#x33;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Lambda表达式","date":"2021-05-05T11:45:33.903Z","path":"2021/05/05/Lamda/","text":"笔记来自于狂神说琴疆老师 b站up主 Lambda 表达式为什么要使用 lambda 表达式 避免匿名内部类定义过多 可以让你的代码看起来更简洁 去掉了一堆没有意义的代码，只留下核心的逻辑 也许你会说，我看了 Lambda 表达式，不但不觉得简洁，反而觉得更乱，看不懂了。那是因为我们还没有习惯，用的多了，看习惯了，就好了。 理解 Functional Interface ( 函数式接口 ) 是学习Java8 lambda 表达式的关键所在。 函数式接口的定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。 123public interface Runnable&#123; public abstract void run();&#125; 对于函数式接口，我们可以通过 lambda 表达式来创建该接口的对象。 推导 lambda 表达式定义一个函数式接口 实现类 123456789101112131415161718public class TestLambda&#123; public static void main(String[] args) &#123; ILike like = new Like(); like.lambda(); &#125;&#125;//定义一个函数式接口interface ILike&#123; void lambda();&#125;//实现类class Like implements ILike&#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda&quot;); &#125;&#125; 进行优化，使用静态内部类 123456789101112131415161718public class TestLambda&#123; static class Like implements ILike&#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda&quot;); &#125; &#125; public static void main(String[] args) &#123; Like like = new Like(); like.lambda(); &#125;&#125;//定义一个函数式接口interface ILike&#123; void lambda();&#125; 进行优化，使用局部内部类 123456789101112131415161718public class TestLambda&#123; public static void main(String[] args) &#123; class Like implements ILike&#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda&quot;); &#125; &#125; ILike like = new Like(); like.lambda(); &#125;&#125;//定义一个函数式接口interface ILike&#123; void lambda();&#125; 再简化，使用匿名内部类 123456789101112public class TestLambda&#123; public static void main(String[] args) &#123; //匿名内部类，没有类的名称，必须借助于接口或者父类 ILike like = new ILike()&#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda&quot;); &#125; &#125;; like.lambda(); &#125;&#125; JDK1.8，用 lambda 简化 1234567891011public class TestLambda&#123; public static void main(String[] args) &#123; like = () -&gt;&#123; System.out.println(&quot;I like lambda&quot;); &#125;; like.lambda(); like = () -&gt;System.out.println(&quot;I like lambda5&quot;); like.lambda(); &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"注解反射","date":"2021-05-05T11:45:33.901Z","path":"2021/05/05/注解反射/","text":"笔记来自于狂神说琴疆老师 b站up主 1、注解什么是注解 介绍 Annotation Annotation的作用： 不是程序本身，可以对程序作出解释。( 这一点和注释 comment 没什么区别 ) 可以被其他程序 ( 比如：编辑器等 ) 读取 Annotation 的格式： 注解是以“ @注释名” 在代码中存在的，还可以添加一些参数值，例如： 1@SuppressWarnings(value=&quot;unchecked&quot;) Annotation 在哪里使用？ ​ 可以附加在 Package，class，method，field 等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制便编程实现对这些元数据的访问 内置注解 @Override：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated：定义在 java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或则存在更好的选择 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息–需要添加一个参数才能正确使用 123456789101112131415161718192021222324//什么是注解public class Test01 extends Object &#123; //@Override 重写的注解 @Override public String toString() &#123; return super.toString(); &#125; //Deprecated 不推荐程序员使用，但是可以使用，或者存在更好的方式 @Deprecated public static void test()&#123; System.out.println(&quot;Deprecated&quot;); &#125; @SuppressWarnings(&quot;all&quot;) public void test02()&#123; List list = new List(); &#125; public static void main(String[] args) &#123; test(); &#125;&#125; 元注解 元注解的作用就是负责注解其他注解，java 定义了 4 个标准的 meta-annotation 类型，他们被用来提供对其他 annotation 类型做说明 这些类型和它们所支持的类在java.lang.annotation包中可以找到 ( @Target, @Retention, @Documented, @Inherited ) @Target: 用于描述注解的使用范围 ( 即被描述的注解可以用在什么地方 ) @Retention: 表示需要在什么级别保存该注释信息，用于描述注解的声明周期 ( SOURCE &lt; CLASS &lt; RUNTIME ) @Documented: 说明该注解将被包含在javadoc中 @Inherited: 说明子类可以继承父类中的该注解 12345678910111213141516171819202122232425import java.lang.annotation.*;//测试元注解@Myannotationpublic class Test02 &#123; public void test()&#123; &#125;&#125;//定义一个注解//Target 表示我们的注解可以用在哪些地方@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 表示我们的注解在什么地方有效//RUNTIME &gt; CLASS &gt; SOURCE@Retention(RetentionPolicy.RUNTIME)//Documented 表示是否将我们的注解生成在JAVAdoc中@Documented//Inherited 子类可以继承父类的注解@Inherited@interface Myannotation&#123;&#125; 自定义注解 使用 @interface 自定义注解时，自动继承了java.lang.annotation.Anntation接口 分析： @interface 用来声明一个注解，格式: public @interface 注解名{} 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的类型 ( 返回值只能是 Class，String，enum ) 可以通过 default 来声明参数的默认值 如果只有一个参数成员，一般参数名为 value 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 1234567891011121314151617181920212223242526//自定义注解public class Teste03 &#123; //注解可以显示默认值，如果没有默认值，我们就必须给注解赋值 @Myanntation2 public void test1()&#123; &#125; @Myanntation3(&quot;你好&quot;) public void test2()&#123;&#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface Myanntation2&#123; //注解的参数 参数类型 + 参数名 + () String name() default &quot;&quot;; int id() default -1; //如果默认值为-1,代表不存在 String[] school() default &quot;&quot;;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface Myanntation3&#123; String value();&#125; 反射机制静态 VS 动态语言动态语言 是一类在运行时可以改变其结构的语言：例如新的函数，对象，甚至代码可以被引进，已有的函数可以被删除或是结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构 主要动态语言：ObjectC、C#、JavaScript、PHP、Python 等 静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 Java 不是动态语言，但 Java 可以称之为‘’ 准动态语言 ‘’。即 Java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java 的动态性让编程的时候更加灵活！ Java Reflection Reflection ( 反射 ) 是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 1Class c = Class.forName(&quot;java.lang.String&quot;); 加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象 ( 一个类只有一个 Class 对象 )，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为：反射 Java 反射机制研究及应用java 反射机制提供的供能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生产动态代理 ········ Java 反射优点和缺点优点: 可以实现动态创建对象和编译，体现出很大的灵活性 缺点: 对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于执行相同的操作 反射相关的主要 API java.lang.Class: 代表一个类 java.lang.reflect.Method: 代表一个类的方法 java.lang.reflect.Field: 代表类的成员变量 java.lang.reflect.Constructor: 代表类的构造器 ········ Class类在 Object 类中定义了以下的方法，此方法将被所有子类继承 1public final Class getClass() 以上的方法返回值的类型是一个 Class 类，此类是 Java 反射的源头，实际上所反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Test02 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class c1 = Class.forName(&quot;com.reflection.User&quot;); System.out.println(c1); Class c2 = Class.forName(&quot;com.reflection.User&quot;); Class c3 = Class.forName(&quot;com.reflection.User&quot;); Class c4 = Class.forName(&quot;com.reflection.User&quot;); //一个类在内存中只有一个Class对象 //一个类被加载后，类的整个结构都会被封装在Class对象中 System.out.println(c2.hashCode()); System.out.println(c3.hashCode()); System.out.println(c4.hashCode()); &#125;&#125;//实体类：pojo,entityclass User&#123; String name; int age; int id; public User(String name, int age, int id) &#123; this.name = name; this.age = age; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; 获取 Class 类的实例 若一直具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高 1Class class = Person.class; 已知每个类的实例，调用该实例的 getClass() 方法获取 class 类对象 1Class class = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName() 获取 1Class class = Class.forName(&quot;demo01.Student&quot;); 内置基本数据类型可以直接用类名 .Type 还可以利用 ClassLoader 我们之后讲解 哪些类型可以有 Class 对象 class：外部类，成员 ( 成员内部类，静态内部类)，局部内部类，匿名内部类 interface：接口 [ ]：数组 enum：枚举 annotation：注解@interface primirtive type：基本数据类型 void 1234567891011121314151617181920212223242526272829public class Test04 &#123; public static void main(String[] args) &#123; Class c1 = Object.class;//类 Class c2 = Comparable.class;//接口 Class c3 = String[].class;//一维数组 Class c4 = int[][].class;//二维数组 Class c5 = ElementType.class;//枚举 Class c6 = Override.class;//注解 Class c7 = Integer.class;//基本数据类型 Class c8 = void.class;//void Class c9 = Class.class;//Class int[] a =new int[10]; int[] b =new int[100]; System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); System.out.println(a.getClass().hashCode()); System.out.println(b.getClass().hashCode()); &#125;&#125; 类的加载与 ClassLoad 的理解 加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象 链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程 验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题 准备：正式为类变量 (static) 分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 分解：虚拟机常量池内的符号引用 ( 常量名) 替换为直接引用 ( 地址) 的过程 初始化： 执行类构造器 &lt;clinit()&gt;方法的过程 什么时候会发生类初始化类的主动引用 ( 一定会发生类的初始化 ) 当虚拟机启动，先初始化 main 方法所在的类 new 一个类的对象 调用类的静态成员 ( 除了 final 常量) 和静态方法 使用 Java.lang.reflect 包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类 类的被动引用 ( 不会发生类的初始化 ) 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化 ( 常量在链接阶段就存入调用类的常量池了 ) 12345678910111213141516171819202122232425262728293031323334public class Test05 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; System.out.println(&quot;Main类被加载&quot;); //1.主动引用,会先加载main类再加载son类，发现其父类没有被加载,加载父类再加载子类// Son son = new Son(); //反射也会引起主动引用// Class.forName(&quot;com.reflection.Son&quot;); //类的被动访问第一条:通过子类调用父类的静态变量，子类不会加载,自己刚才测试出错才发现粗心发现没有调用父类的静态变量// System.out.println(Son.a); //类的被动引用第二条,因为这里只定义了一片空间和名字，不会进行子类和父类的加载// Son[] array = new Son[2]; //类的被动引用第二条,对于常量在类的链接阶段就已经进入了常量池，通过子类引用不会发生子类和父类的加载 System.out.println(Son.c); &#125;&#125;class Father&#123; static int a = 1; static &#123; System.out.println(&quot;父类被加载&quot;); &#125;&#125;class Son extends Father&#123; static int b = 2; static &#123; System.out.println(&quot;子类被加载&quot;); &#125; //常量池里的常量 static final int c = 10;&#125; 类加载器的作用类加载器作用是用来把类 ( class) 装载进内存的。JVM 规范定义了如下类型的类的加载器。 引导类加载器：用 C++ 编写的，是 JVM 自带的类加载器，负责 java 平台核心库，用来装载核心类库。该加载器无法直接获取 扩展类加载器：负责 jre/lib/ext 目录下的 jar 包或 D java.ext.dirs 指定目录下的 jar 包装入工作库 系统类加载器：负责 java-classpath 或 -D java.ext.dirs 所指的目录下的类与 jar 包装入工作，是最常用的加载器 123456789101112131415161718192021222324252627public class Test06 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类加载器的父类加载器--&gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器--&gt;根加载器(C/C++) ClassLoader parent1 = parent.getParent(); System.out.println(parent1); //测试当前类是哪个类加载器加载的 ClassLoader classLoader = Class.forName(&quot;com.reflection.Test06&quot;).getClassLoader(); System.out.println(classLoader); //测试JDK内置的类是谁加载的 ClassLoader classLoader1 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classLoader1); //如何获取系统类加载器可以加载的路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); &#125;&#125; 创建运行时类的对象获取运行时类的完整结构 - 通过反射Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的 Field 注解 ········ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//获取类的信息public class Test07 &#123; public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException &#123; User user = new User(); Class c1 = user.getClass(); //获取类的名字 System.out.println(c1.getName()); //获取包名 + 类名 System.out.println(c1.getSimpleName()); //获取类名 //获取类的属性 System.out.println(&quot;========================================&quot;); Field[] fields = c1.getFields(); //只能找到public公有属性 fields = c1.getDeclaredFields(); //找到全部的属性 for (Field field : fields) &#123; System.out.println(field); &#125; //获取指定属性的值 Field name = c1.getDeclaredField(&quot;name&quot;); System.out.println(name); //获取类的方法 System.out.println(&quot;========================================&quot;); Method[] methods = c1.getMethods(); //获得本类及其父类的全部public共有方法 for (Method method : methods) &#123; System.out.println(&quot;正常的&quot;+method); &#125; methods = c1.getDeclaredMethods(); //获取本类的所有方法，包括私有 for (Method method : methods) &#123; System.out.println(&quot;getDeclaredMethods&quot;+method); &#125; //获取指定的方法 System.out.println(&quot;=========================================&quot;); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class); System.out.println(getName); System.out.println(setName); //获取指定的构造器 System.out.println(&quot;=========================================&quot;); Constructor[] constructors = c1.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(&quot;#&quot;+constructor); &#125; Constructor declaredConstructor = c1.getDeclaredConstructor(null); System.out.println(&quot;指定：&quot;+declaredConstructor); &#125;&#125; 有了 Class 对象，能做什么？创建类的对象：调用 Class 对象的 newInstance() 方法 类必须有一个无参的构造器 类的构造器的访问权限需要足够 难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 通过 Class 类的 getDeclaredConstrutor(Class ··· parameterTypes) 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过 Constructor 实例化对象 调用指定的方法通过反射，调用类中的方法，通过 Method 类完成 通过 Class 类的 getMethod(String name, Class ··· parameterTypes) 方法获取一个 Method 对象，并设置此方法操作时所需的参数类型 之后使用 Object invoke(Object object, Object[] args) 进行调用，并向方法中传递要设置的 obj 对象的参数信息。 Object invoke(Object obj, Object ··· args) Object 对应原方法的返回值，若原方法无返回值，此时返回 null 若原方法为静态方法，此时形参为 Object obj 可为 null 若原方法形参列表为空，则 Object[] args 为 null 若原方法声明为 private，则需要在调用此 invoke() 方法前，显示调用方法对象的 setAccessible(true) 方法，将可访问 private 的方法。 setAccessible Method 和 Field、Constructor 对象都有 setAccessible() 方法。 setAccessible 作用是启动和禁用访问安全检查的开关。 参数值为 true 则只是反射的对象在使用时应该取消 Java 语言访问检查 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 True 使得原本无法访问的私有成员也可以访问 参数值为 false 则指示反射的对象应该实施 Java 语言访问检查 123456789101112131415161718192021222324252627282930313233343536import java.lang.reflect.*;//动态的创建对象，通过反射public class test08 &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; //获取Class对象 Class c1 = Class.forName(&quot;com.reflection.User&quot;); //构造一个对象// Object user1 = c1.newInstance(); //本质是调用了类的无参构造器// System.out.println(user1); //也可以通过类的构造器创建对象// User user2 = (User) c1.getDeclaredConstructor(String.class, int.class, int.class).newInstance(&quot;whitesheep&quot;, 1, 20);// System.out.println(user2); //通过反射调用普通方法 User user3 = (User)c1.newInstance(); //通过反射获取一个方法 Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class); //invoke : 激活的意思 //(对象,&quot;方法的值&quot;) setName.invoke(user3,&quot;whitesheep&quot;); System.out.println(user3.getName()); //通过反射操作属性 User user4 = (User)c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); System.out.println(&quot;===============&quot;); name.setAccessible(true); name.set(user4,&quot;whitesheep&quot;); System.out.println(user4.getName()); &#125;&#125; 分析普通方式、反射方式及反射关闭检测方式的性能问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//分析性能问题public class Test09 &#123; //普通方式调用 public static void test01()&#123; User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) &#123; user.getName(); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;普通方式执行10亿次：&quot;+(endTime-startTime)+&quot;ms&quot;); &#125; //反射方式调用 public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) &#123; getName.invoke(user,null); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;反射方式执行10亿次：&quot;+(endTime-startTime)+&quot;ms&quot;); &#125; //反射方式调用 关闭检测 public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000000; i++) &#123; getName.invoke(user,null); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;关闭检测执行10亿次：&quot;+(endTime-startTime)+&quot;ms&quot;); &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; test01(); test02(); test03(); &#125;&#125; 反射操作泛型 Java 采用泛型擦除的机制来引用泛型，Java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型相关的类型全部擦除 为了通过反射操作这些类型，java 新增了 Parameterrized Type，GenericArrayType，TypeVarible 和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型 ParameterrizedType：表示一种参数化类型，比如 Collection&lt;String&gt; GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数据类型 TypeVarible：是各种类型变量的公共父接口 WildcardType：代表一种通配符类型表达式 1234567891011121314151617181920212223242526272829303132333435//通过反射获取泛型public class Test10 &#123; public void test01(Map&lt;String,User&gt; map,User user)&#123; System.out.println(&quot;test01&quot;); &#125; public Map&lt;String,User&gt; test02()&#123; System.out.println(&quot;test02&quot;); return null; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; Method method = Test10.class.getDeclaredMethod(&quot;test01&quot;, Map.class, User.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); for (Type genericParameterType : genericParameterTypes) &#123; System.out.println(&quot;#&quot; + genericParameterType); if (genericParameterType instanceof ParameterizedType) &#123; Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125; &#125; &#125; System.out.println(&quot;==========================================&quot;); method = Test10.class.getDeclaredMethod(&quot;test02&quot;); Type genericReturnType = method.getGenericReturnType(); if (genericReturnType instanceof ParameterizedType) &#123; Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(genericReturnType); &#125; &#125; &#125;&#125; 反射操作注解 了解什么是 ORM？ Object relationship Mapping –&gt; 对象关系映射 类和表结构对应 属性和字段对应 对象和记录对应 要求：利用注解和反射完成类和表节结构的映射 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test11 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; Class c1 = Class.forName(&quot;com.reflection.Student2&quot;); //通过反射获取注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation); &#125; //获得注解的value的值. TableSheep tableSheep = (TableSheep)c1.getAnnotation(TableSheep.class); String value = tableSheep.value(); System.out.println(value); //获得类指定的注解 Field name = c1.getDeclaredField(&quot;name&quot;); FieldSheep annotation = name.getAnnotation(FieldSheep.class); System.out.println(annotation.columnName()); System.out.println(annotation.Type()); System.out.println(annotation.length()); &#125;&#125;@TableSheep(&quot;DB_student&quot;)class Student2&#123; @FieldSheep(columnName = &quot;db_id&quot;,Type = &quot;length&quot;,length = 10) private int id; @FieldSheep(columnName = &quot;db_age&quot;,Type = &quot;length&quot;,length = 10) private int age; @FieldSheep(columnName = &quot;db_name&quot;,Type = &quot;varchar&quot;,length = 3) private String name;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableSheep&#123; String value();&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FieldSheep&#123; String columnName(); String Type(); int length();&#125; 完结撒花","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"注解反射","slug":"注解反射","permalink":"http://example.com/tags/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/"}]},{"title":"ArrayList与LinkedList","date":"2021-05-04T06:46:35.566Z","path":"2021/05/04/ArrayList与LinkedList/","text":"Java ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 1234567//ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下：import java.util.ArrayList; // 引入 ArrayList 类ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化//E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。//objectName: 对象名。 ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 1、添加元素将元素插入到指定位置的 arraylist 中 arraylist.add（int index，E element） index（可选参数）- 表示元素所插入处的索引值 element - 要插入的元素 如果 index 没有传入实际参数，元素将追加至数组的最末尾。 2、访问元素访问 ArrayList 中的元素可以使用 get() 方法： 3、修改元素如果要修改 ArrayList 中的元素可以使用 set() 方法： 4、删除元素如果要删除 ArrayList 中的元素可以使用 remove() 方法： 5、计算大小如果要计算 ArrayList 中的元素数量可以使用 size() 方法： 6、迭代数组列表 我们可以使用 for 来迭代数组列表中的元素： 1234567891011121314import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int i = 0; i &lt; sites.size(); i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125; 也可以使用 for-each 来迭代元素： 1234567891011121314import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 7、ArrayList 排序Collections 类也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。 1234567891011121314151617import java.util.ArrayList;import java.util.Collections; // 引入 Collections 类public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Taobao&quot;); sites.add(&quot;Wiki&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Weibo&quot;); sites.add(&quot;Google&quot;); Collections.sort(sites); // 字母排序 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 更多使用方法：12345678910111213141516171819202122addAll(); //添加集合中的所有元素到 arraylist 中clear(); //删除 arraylist 中的所有元素contains(); //判断元素是否在 arraylistindexOf(); //返回 arraylist 中元素的索引值removeAll() //删除存在于指定集合中的 arraylist 里的所有元素isempty(); //判断 arraylist 是否为空subList(); //截取部分 arraylist 的元素sort(); //sites.sort(Comparator.[naturalOrder()|reverseOrder()]);自然排序为升序，反转为降序toArray(); //将 arraylist 转换为数组toString(); //将 arraylist 转换为字符串ensureCapacity(int minCapacity); //用于设置具有指定容量大小的动态数组。minCapacity - 动态数组的容量 //果我们在 arraylist 中添加超过容量大小的元素，它将自动调整自身大小 //既然 arraylist 可以自动调整自身大小，为什么还要使用 ensureCapacity() 方法调整 arraylist 的大小呢？ //这是因为如果我们使用 ensureCapacity() 方法来调整 arraylist 的大小，那么 arraylist 将会马上调整为指定的容量大小。否则，每次添加元素时都会调整 arraylist 的大小。trimToSize(); //将 arraylist 中的容量调整为数组中的元素个数removeRange(int fromIndex, int toIndex); //用于删除指定索引之间存在的元素。 //删除名称中带有 Tao 的元素 sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;)); //e -&gt; e.contains(&quot;land&quot;) 如果元素中包含 &quot;land&quot;，则返回 true //removeIf() 如果 e -&gt; e.contains(&quot;land&quot;) 返回 true 则删除该元素。 // 删除所有偶数元素 //numbers.removeIf(e -&gt; (e % 2) == 0);; //System.out.println(&quot;Odd Numbers: &quot; + numbers); Java LinkedList链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 继承了 AbstractSequentialList 类。 LinkedList 实现了 Queue 接口，可作为队列使用。 LinkedList 实现了 List 接口，可进行列表的相关操作。 LinkedList 实现了 Deque 接口，可作为队列使用。 LinkedList 实现了 Cloneable 接口，可实现克隆。 LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。 123456// 引入 LinkedList 类import java.util.LinkedList; LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表 如果要进行输出遍历的话，使用ArrayList更加方便，使用LinkedList主要是利用它的链表特性。 如插入开头，插入结尾，删除开头，删除结尾，获取开头元素，获取结尾元素 迭代元素 我们可以使用 for 来迭代数组列表中的元素 也可以使用 for-each 来迭代元素 123456789101112131415// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 常用方法12345678add(int index, E element); //向指定位置插入元素,默认在链表末尾添加元素addAll(int index, Collection c);//将一个集合的所有元素添加到链表的指定位置后面addFirst(E e); //元素添加到头部。addLast(E e); //元素添加到尾部。offer(E e); //向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。offerFirst(E e) //头部插入元素，返回是否成功，成功为 true，失败为 false。offerLast(E e) //尾部插入元素，返回是否成功，成功为 true，失败为 false。clear() //清空链表。 原文链接：https://www.runoob.com/java","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"旋转数组的最小数字","date":"2021-05-04T06:46:35.566Z","path":"2021/05/04/旋转数组的最小数字/","text":"旋转数组的最小数字题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路：本题的直观解法很简单，直接对数组进行一次遍历就可以找到最小值，复杂度为O(n)，但是显然这不是本题的意图所在，因为没有利用到任何旋转数组的特性。 进一步分析，如果整个数组是有序的，那我们一定会想到用折半查找来实现。对于旋转数组，我们发现，它实际上可以划分为两个排序的子数组，而且前面数组的元素都不小于后面数组的元素，并且最小值正好就是这两个数组的分界线，由此，我们可以得出以下解决方法。 首先用两个指针low和high分别指向数组的第一个元素和最后一个元素，然后可以找到中间元素mid。对于这个中间元素，有以下两种情况：（1）该元素大于等于low指向的元素，此时最小的元素说明在mid的后面，可以把low=mid；（2）中间元素小于等于high指向的元素，那么最小元素在mid之前，可以high=mid。特别注意：这里不要+1或者-1，因为只有这样才能保证low始终在第一个数组，high始终在第二个数组。依次循环，当最后low和high相差1时，low指向第一个数组的最后一个，high指向第二个数组的第一个（即为我们要找的最小值）。 除此之外，本题还有两个特殊情况： 将数组前0个元素移动到后面（相当于没有旋转，数组整体有序）。明显我们上面的分析没有包含这种情况，需要特殊处理，方法也很简单，将第一个元素和最后一个元素相比，若第一个元素小于最后一个元素，则说明最小值就是的第一个元素，可以直接返回。 首尾指针指向的数字和中间元素三者都相等时，无法判断中间元素位于哪个子数组，无法缩小问题规模。此时，只能退而求其次，进行顺序查找。 12345678910111213141516171819202122232425262728293031323334public int minNumberInRotateArray(int [] array) &#123; /* 三种情况： （1）把前面0个元素搬到末尾，也就是排序数组本身，第一个就是最小值 （2）一般情况二分查找，当high-low=1时，high就是最小值 （3）如果首尾元素和中间元素都相等时，只能顺序查找 */ int len=array.length; if(len==0) return 0; int low=0,high=len-1; if(array[low]&lt;array[high]) //排序数组本身 return array[low]; while(low&lt;high)&#123; int mid=low+(high-low)/2; if(array[low]==array[mid] &amp;&amp; array[high]==array[mid]) return minInOrder(array); if(array[mid]&gt;=array[low]) low=mid; else if(array[mid]&lt;=array[high]) high=mid; if(high-low==1) return array[high]; &#125; return -1;&#125;public int minInOrder(int [] array) &#123; //顺序查找 int min=array[0]; for(int num:array)&#123; if(num&lt;min) min=num; &#125; return min;&#125; 相关链接：https://www.cnblogs.com/gzshan/p/10735252.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"网络编程","date":"2021-05-04T06:46:35.566Z","path":"2021/05/04/网络编程/","text":"网络编程网络编程概述网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。 本教程主要讲解以下两个主题。 Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。 URL 处理：这部分会在另外的篇幅里讲，点击这里更详细地了解在 Java 语言中的 URL 处理。 Socket 编程套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。 TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。 ServerSocket 类的方法服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 ServerSocket 类有四个构造方法： 12345678public ServerSocket(int port) throws IOException//创建绑定到特定端口的服务器套接字。public ServerSocket(int port, int backlog) throws IOException//利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。public ServerSocket(int port, int backlog, InetAddress address) throws IOException//使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。public ServerSocket() throws IOException//创建非绑定服务器套接字。 创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。 这里有一些 ServerSocket 类的常用方法： 12345678public int getLocalPort()//返回此套接字在其上侦听的端口。public Socket accept() throws IOException//侦听并接受到此套接字的连接。public void setSoTimeout(int timeout)//通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。public void bind(SocketAddress host, int backlog)//将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 Socket 类的方法java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 Socket 类有五个构造方法. 12345678public Socket(String host, int port) throws UnknownHostException, IOException.//创建一个流套接字并将其连接到指定主机上的指定端口号。public Socket(InetAddress host, int port) throws IOException//创建一个流套接字并将其连接到指定 IP 地址的指定端口号。public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.//创建一个套接字并将其连接到指定远程主机上的指定远程端口。public Socket()//通过系统默认类型的 SocketImpl 创建未连接套接字 当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。 下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。 12345678910111213141516public void connect(SocketAddress host, int timeout) throws IOException//将此套接字连接到服务器，并指定一个超时值。public InetAddress getInetAddress()//返回套接字连接的地址。public int getPort()//返回此套接字连接到的远程端口public int getLocalPort()//返回此套接字绑定到的本地端口。 public SocketAddress getRemoteSocketAddress()//返回此套接字连接的端点的地址，如果未连接则返回 null。public InputStream getInputStream() throws IOException//返回此套接字的输入流。public OutputStream getOutputStream() throws IOException//返回此套接字的输出流。public void close() throws IOException//关闭此套接字。 InetAddress 类的方法这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法： 1234567891011121314static InetAddress getByAddress(byte[] addr)//在给定原始 IP 地址的情况下，返回 InetAddress 对象。static InetAddress getByAddress(String host, byte[] addr)//根据提供的主机名和 IP 地址创建 InetAddress。static InetAddress getByName(String host)//在给定主机名的情况下确定主机的 IP 地址。String getHostAddress() //返回 IP 地址字符串（以文本表现形式）。String getHostName() //获取此 IP 地址的主机名。static InetAddress getLocalHost()//返回本地主机。String toString()//将此 IP 地址转换为 String。 Socket 使用规范服务器端ServerSocket 1234567891011121314151617181920212223242526272829303132333435363738import java.net.*;import java.io.*;public class TestServerSocket&#123; public static void main(String args[]) throws Exception&#123; ServerSocket ss = new ServerSocket(6666); /*创建一个ServerSocket对象时往往会给它指定一个端口号 指定端口号的意思是这个new出来的ServerSocket对象要使用的 是哪一个端口号，通过哪一个端口号来监听客户端的连接 因此指定一个端口号的意义就是为了告诉计算机ServerSocket对象 在哪个地方监听客户端的连接*/ /*服务器端接收客户端连接的请求是不间断地接收的，所以服务器端的 编程一般都是死循环，永不休止地运行着。*/ while(true)&#123; Socket s = ss.accept(); /*在服务器端调用accept()方法接受客户端的连接对象,accept()方法是 一个阻塞式方法，一直在傻傻地等待着是否有客户端申请连接上来 然后服务器端的Socket插座就和客户端的Socket插座建立了连接了*/ /*客户端能否连接上服务器端，取决于服务器端是否接受客户端的连接请求 如果接受了客户端的连接请求，那么在服务器端就安装上一个Socket插座 通过这个插座与连接上的客户端就可以建立连接，互相通信了*/ System.out.println(&quot;A Client Connected!&quot;); /*使用InputStream流接收从客户端发送过来的信息，使用DataInputStream数据流处理接收到的信息*/ DataInputStream dis = new DataInputStream(s.getInputStream()); /*使用readUTF(方法将接收到的信息全部读取出来，存储到变量str里面 readUTF()方法也是一个阻塞式方法，会傻傻地等待客户端发送信息过来，然后将接收到的信息读取出来 如果客户端不写东西过来，它就一直在服务器端傻傻地等待着，直到客户端写东西过来为止 堵塞式的方法效率往往是不高的,比如说一个客户端连接上来了，但是它迟迟不发送信息， 那么服务器端的程序就阻塞住了，这样另外一个客户端就连接不上来了，因为另外一个客户端要想连接 上服务器端，就必须得在服务器端调用accept()方法，可accept()方法必须得在下一次循环时才能够被 调用，现在服务器端的程序运行到调用readUTF()这个方法时就阻塞住了，它要等待着已经连接上来的 那个客户端发送信息过来后将信息读取出来，如果客户端一直不发信息到服务器端，那么readUTF()方法 就一直无法读取到信息，那么服务器端的程序会阻塞在这里，无法进行下次循环，这样其他的客户端就 无法连接到服务器端了*/ String str = dis.readUTF(); System.out.println(str); &#125; &#125; &#125; 客户端Socket 123456789101112131415import java.net.*;import java.io.*;public class TestClientSocket&#123; public static void main(String args[]) throws Exception&#123; Socket s = new Socket(&quot;127.0.0.1&quot;,6666); /*Client申请连接到Server端上*/ /*连接上服务器端以后，就可以向服务器端输出信息和接收从服务器端返回的信息 输出信息和接收返回信息都要使用流式的输入输出原理进行信息的处理*/ /*这里是使用输出流OutputStream向服务器端输出信息*/ OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); Thread.sleep(30000);/*客户端睡眠30秒后再向服务器端发送信息*/ dos.writeUTF(&quot;Hello Server!&quot;); &#125;&#125; 客户端通过端口6666向服务器端请求连接，服务器端接受客户端的连接请求以后，就在服务器端上安装一个Socket，然后让这个Socket与客户端的Socket连接，这样服务器端就可以与客户端互相通信了，当有另外一个客户端申请连接时，服务器端接受了以后，又会安装另外一个Socket与这个客户端的Socket进行连接。 相关链接：https://www.runoob.com/java/java-networking.html。这里推荐两个关于网络编程的文章，一篇为https://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html，较为详细；一篇https://www.cnblogs.com/xdp-gacl/p/3631965.html，较为硬核。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO与装饰器模式的不解之缘","date":"2021-05-04T06:46:35.558Z","path":"2021/05/04/IO与装饰器模式的不解之缘/","text":"装饰器模式详解（与IO不解的情缘）定义：装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 这一个解释，引自百度百科，我们注意其中的几点。 不改变原类文件 不使用继承。 动态扩展。 从图中可以看到，我们装饰的是一个接口的任何实现类，而这些实现类也包括了装饰器本身，装饰器本身也可以再被装饰。 另外，这个类图只是装饰器模式的完整结构，但其实里面有很多可以变化的地方，LZ给出如下两条。 1，Component接口可以是接口也可以是抽象类，甚至是一个普通的父类（这个强烈不推荐，普通的类作为继承体系的超级父类不易于维护）。 2，装饰器的抽象父类Decorator并不是必须的。 那么我们将上述标准的装饰器模式，用我们熟悉的JAVA代码给诠释一下。首先是待装饰的接口Component。 1234567package com.decorator;public interface Component &#123; void method(); &#125; 接下来便是我们的一个具体的接口实现类，也就是俗称的原始对象，或者说待装饰对象。 123456789package com.decorator;public class ConcreteComponent implements Component&#123; public void method() &#123; System.out.println(&quot;原来的方法&quot;); &#125;&#125; 下面便是我们的抽象装饰器父类，它主要是为装饰器定义了我们需要装饰的目标是什么，并对Component进行了基础的装饰。 12345678910111213141516package com.decorator;public abstract class Decorator implements Component&#123; protected Component component; public Decorator(Component component) &#123; super(); this.component = component; &#125; public void method() &#123; component.method(); &#125; &#125; 再来便是我们具体的装饰器A和装饰器B。 123456789101112131415161718package com.decorator;public class ConcreteDecoratorA extends Decorator&#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; public void methodA()&#123; System.out.println(&quot;被装饰器A扩展的功能&quot;); &#125; public void method()&#123; System.out.println(&quot;针对该方法加一层A包装&quot;); super.method(); System.out.println(&quot;A包装结束&quot;); &#125;&#125; 123456789101112131415161718package com.decorator;public class ConcreteDecoratorB extends Decorator&#123; public ConcreteDecoratorB(Component component) &#123; super(component); &#125; public void methodB()&#123; System.out.println(&quot;被装饰器B扩展的功能&quot;); &#125; public void method()&#123; System.out.println(&quot;针对该方法加一层B包装&quot;); super.method(); System.out.println(&quot;B包装结束&quot;); &#125;&#125; 下面给出我们的测试类。我们针对多种情况进行包装。 12345678910111213141516171819202122package com.decorator;public class Main &#123; public static void main(String[] args) &#123; Component component =new ConcreteComponent();//原来的对象 System.out.println(&quot;------------------------------&quot;); component.method();//原来的方法 ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component);//装饰成A System.out.println(&quot;------------------------------&quot;); concreteDecoratorA.method();//原来的方法 concreteDecoratorA.methodA();//装饰成A以后新增的方法 ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(component);//装饰成B System.out.println(&quot;------------------------------&quot;); concreteDecoratorB.method();//原来的方法 concreteDecoratorB.methodB();//装饰成B以后新增的方法 concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);//装饰成A以后再装饰成B System.out.println(&quot;------------------------------&quot;); concreteDecoratorB.method();//原来的方法 concreteDecoratorB.methodB();//装饰成B以后新增的方法 &#125;&#125; 实现结果： 12345678910111213141516171819------------------------------原来的方法------------------------------针对该方法加一层A包装原来的方法A包装结束被装饰器A扩展的功能------------------------------针对该方法加一层B包装原来的方法B包装结束被装饰器B扩展的功能------------------------------针对该方法加一层B包装针对该方法加一层A包装原来的方法A包装结束B包装结束被装饰器B扩展的功能 从此可以看到，我们首先是使用的原始的类的方法，然后分别让A和B装饰完以后再调用，最后我们将两个装饰器一起使用，再调用该接口定义的方法。 上述当中，我们分别对待装饰类进行了原方法的装饰和新功能的增加，methodA和methodB就是新增加的功能，这些都是装饰器可以做的，当然两者并不一定兼有，但一般至少会有一种，否则也就失去了装饰的意义。 另外，文章开篇就说道了IO与装饰器的情缘，相信各位就算不太清楚，也都大致听说过JAVA的IO是装饰器模式实现的，再给出一个标准的模板示例以后，直接拿出IO的示例，我们真枪实弹的来。 下面直接给出IO包中的部分装饰过程，上面LZ加了详细的注释以及各个装饰器的功能演示，各位可以和上面标准的装饰器模式对比一下，不得不感叹，IO与装饰器的孽缘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class IOTest &#123; /* test.txt内容： * hello world! */ public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //文件路径可自行更换 final String filePath = &quot;E:/myeclipse project/POITest/src/com/decorator/test.txt&quot;; //InputStream相当于被装饰的接口或者抽象类，FileInputStream相当于原始的待装饰的对象，FileInputStream无法装饰InputStream //另外FileInputStream是以只读方式打开了一个文件,并打开了一个文件的句柄存放在FileDescriptor对象的handle属性 //所以下面有关回退和重新标记等操作，都是在堆中建立缓冲区所造成的假象,并不是真正的文件流在回退或者重新标记 InputStream inputStream = new FileInputStream(filePath); final int len = inputStream.available();//记录一下流的长度 System.out.println(&quot;FileInputStream不支持mark和reset：&quot; + inputStream.markSupported()); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); /* 下面分别展示三种装饰器的作用BufferedInputStream,DataInputStream,PushbackInputStream,LZ下面做了三个装饰器的功能演示 */ //首先装饰成BufferedInputStream，它提供我们mark，reset的功能 BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);//装饰成 BufferedInputStream System.out.println(&quot;BufferedInputStream支持mark和reset：&quot; + bufferedInputStream.markSupported()); bufferedInputStream.mark(0);//标记一下 char c = (char) bufferedInputStream.read(); System.out.println(&quot;LZ文件的第一个字符：&quot; + c); bufferedInputStream.reset();//重置 c = (char) bufferedInputStream.read();//再读 System.out.println(&quot;重置以后再读一个字符，依然会是第一个字符:&quot; + c); bufferedInputStream.reset(); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); //装饰成 DataInputStream,我们为了又使用DataInputStream,又使用BufferedInputStream的mark reset功能，所以我们再进行一层包装 //注意，这里如果不使用BufferedInputStream，而使用原始的InputStream，read方法返回的结果会是-1，即已经读取结束 //因为BufferedInputStream已经将文本的内容读取完毕，并缓冲到堆上，默认的初始缓冲区大小是8192B DataInputStream dataInputStream = new DataInputStream(bufferedInputStream); dataInputStream.reset();//这是BufferedInputStream提供的功能，如果不在这个基础上包装会出错 System.out.println(&quot;DataInputStream现在具有readInt，readChar,readUTF等功能&quot;); int value = dataInputStream.readInt();//读出来一个int,包含四个字节 //我们转换成字符依次显示出来，可以看到LZ文件的前四个字符 String binary = Integer.toBinaryString(value); int first = binary.length() % 8; System.out.print(&quot;使用readInt读取的前四个字符：&quot;); for (int i = 0; i &lt; 4; i++) &#123; if (i == 0) &#123; System.out.print(((char)Integer.valueOf(binary.substring(0, first), 2).intValue())); &#125;else &#123; System.out.print(((char)Integer.valueOf(binary.substring(( i - 1 ) * 8 + first, i * 8 + first), 2).intValue())); &#125; &#125; System.out.println(); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); //PushbackInputStream无法包装BufferedInputStream支持mark reset，因为它覆盖了reset和mark方法 //因为流已经被读取到末尾，所以我们必须重新打开一个文件的句柄，即FileInputStream inputStream = new FileInputStream(filePath); PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream,len);//装饰成 PushbackInputStream System.out.println(&quot;PushbackInputStream装饰以后支持退回操作unread&quot;); byte[] bytes = new byte[len]; pushbackInputStream.read(bytes);//读完了整个流 System.out.println(&quot;unread回退前的内容：&quot; + new String(bytes)); pushbackInputStream.unread(bytes);//再退回去 bytes = new byte[len];//清空byte数组 pushbackInputStream.read(bytes);//再读 System.out.println(&quot;unread回退后的内容：&quot; + new String(bytes)); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); /* 以上有两个一层装饰和一个两层装饰,下面我们先装饰成Reader，再进行其它装饰 */ //由于之前被PushbackInputStream将流读取到末尾，我们需要再次重新打开文件句柄 inputStream = new FileInputStream(filePath); InputStreamReader inputStreamReader = new InputStreamReader(inputStream,&quot;utf-8&quot;);//先装饰成InputStreamReader System.out.println(&quot;InputStreamReader有reader的功能，比如转码：&quot; + inputStreamReader.getEncoding()); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); BufferedReader bufferedReader = new BufferedReader(inputStreamReader);//我们进一步在reader的基础上装饰成BufferedReader System.out.println(&quot;BufferedReader有readLine等功能：&quot; + bufferedReader.readLine()); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); LineNumberReader lineNumberReader = new LineNumberReader(inputStreamReader);//我们进一步在reader的基础上装饰成LineNumberReader System.out.println(&quot;LineNumberReader有设置行号，获取行号等功能（行号从0开始）,当前行号：&quot; + lineNumberReader.getLineNumber()); System.out.println(&quot;---------------------------------------------------------------------------------&quot;); //此处由于刚才被readLine方法将流读取到末尾,所以我们再次重新打开文件句柄,并需要将inputstream再次包装成reader inputStreamReader = new InputStreamReader(new FileInputStream(filePath)); PushbackReader pushbackReader = new PushbackReader(inputStreamReader,len);//我们进一步在reader的基础上装饰成PushbackReader System.out.println(&quot;PushbackReader是拥有退回操作的reader对象&quot;); char[] chars = new char[len]; pushbackReader.read(chars); System.out.println(&quot;unread回退前的内容：&quot; + new String(chars)); pushbackReader.unread(chars);//再退回去 chars = new char[len];//清空char数组 pushbackReader.read(chars);//再读 System.out.println(&quot;unread回退后的内容：&quot; + new String(chars)); &#125;&#125; 上述便是IO的装饰器使用，其中InputStream就相当于上述的Component接口，只不过这里是一个抽象类，这是我们装饰的目标抽象类。FileInputstream就是一个ConcreteComponent，即待装饰的具体对象，它并不是JAVA的IO结构中的一个装饰器，因为它无法装饰InputStream。剩下BufferedInputStream，DataInputstream等等就是各种装饰器了，对比上述的标准装饰器样板，JAVA的IO中也有抽象的装饰器基类的存在，只是上述没有体现出来，就是FilterInputStream，它是很多装饰器最基础的装饰基类。 在上述过程中，其中dataInputStream是经过两次装饰后得到的，它具有了dataInputStream和bufferedInputStream的双重功能，另外，InputStreamReader是一个特殊的装饰器，它提供了字节流到字符流的桥梁，其实它除了具有装饰器的特点以外，也有点像一个适配器，但LZ还是觉得它应当算是一个装饰器。 其它的IO装饰器各位可以自行尝试或者和上述的标准的装饰器模式代码比对一下。 从上面的展示中，已经可以充分体会到装饰器模式的灵活了，我们创建的一个FileInputstream对象，我们可以使用各种装饰器让它具有不同的特别的功能，这正是动态扩展一个类的功能的最佳体现，而装饰器模式的灵活性正是JAVA中IO所需要的，不得不赞一下JAVA类库的建造者实在是强悍。 上述的XXXXInputStream的各个类都继承了InputStream，这样做不仅是为了复用InputStream的父类功能（InputStream也是一种模板方法模式，它定义了read(byte[])方法的简单算法，并将read()方法交给具体的InputStream去实现），也是为了可以重叠装饰，即装饰器也可以再次被装饰，而过渡到Reader以后，Reader的装饰器体系则是类似的 总之呢，装饰器模式就是一个可以非常灵活的动态扩展类功能的设计模式，它采用组合的方式取代继承，使得各个功能的扩展更加独立和灵活。 装饰器模式中遇到的问题：按照创建一个Component接口，之后写一个Decorator实现接口，并且Decorator重写了一下本类的构造方法，没有写无参构造。还加入了一个实现接口的方法，接着又写了一个ConcreteDecoratorA继承Decorator，为什么要去重写父类的构造方法，并且不需要去重写接口的方法。 这里我查看了一些网上的讲解https://bbs.csdn.net/topics/395825786?page=1 出处：博客园左潇龙的技术博客–http://www.cnblogs.com/zuoxiaolong","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"IO","slug":"IO","permalink":"http://example.com/tags/IO/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Iterator与ListIterator","date":"2021-05-04T06:46:35.558Z","path":"2021/05/04/Iterator 与 ListIterator/","text":"Iterator（迭代器）Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。 Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。 迭代器 it 的两个基本操作是 next 、hasNext 和 remove。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 1import java.util.Iterator; // 引入 Iterator 类 1、获取一个迭代器集合想获取一个迭代器可以使用 iterator() 方法: 1234567891011121314151617181920212223// 引入 ArrayList 和 Iterator 类import java.util.ArrayList;import java.util.Iterator;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); &#125;&#125;//输出结果Google 2、循环集合元素让迭代器 it 逐个返回集合中所有元素最简单的方法是使用 while 循环： 123while(it.hasNext()) &#123; System.out.println(it.next());&#125; 3、删除元素12345678910111213141516171819202122//实例我们删除集合中小于 10 的元素：// 引入 ArrayList 和 Iterator 类import java.util.ArrayList;import java.util.Iterator;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;(); numbers.add(12); numbers.add(8); numbers.add(2); numbers.add(23); Iterator&lt;Integer&gt; it = numbers.iterator(); while(it.hasNext()) &#123; Integer i = it.next(); if(i &lt; 10) &#123; it.remove(); // 删除小于 10 的元素 &#125; &#125; System.out.println(numbers); &#125;&#125; ListIteratorListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。 123456789101112131415161718192021//ListIterator接口定义public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e); &#125; 由以上定义我们可以推出ListIterator可以: 双向移动（向前/向后遍历）. 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引. 可以使用set()方法替换它访问过的最后一个元素. 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素. 1234567891011121314151617181920212223242526272829303132333435363738public class ListIteratorExample &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;aaa&quot;); a.add(&quot;bbb&quot;); a.add(&quot;ccc&quot;); System.out.println(&quot;Before iterate : &quot; + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println(it.next() + &quot;, &quot; + it.previousIndex() + &quot;, &quot; + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.print(it.previous() + &quot; &quot;); &#125; System.out.println(); it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println(t); if (&quot;ccc&quot;.equals(t)) &#123; it.set(&quot;nnn&quot;); &#125; else &#123; it.add(&quot;kkk&quot;); &#125; &#125; System.out.println(&quot;After iterate : &quot; + a); &#125;&#125;//输出结果：Before iterate : [aaa, bbb, ccc]aaa, 0, 1bbb, 1, 2ccc, 2, 3ccc bbb aaa bbbcccAfter iterate : [aaa, bbb, kkk, nnn] 相关链接：https://www.runoob.com/java/java-iterator.html、https://www.cnblogs.com/xiaoxi/p/6089984.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"红黑树","date":"2021-05-04T06:46:35.558Z","path":"2021/05/04/红黑树/","text":"红黑树要说的红黑树就是就是一颗非严格均衡的二叉树，均衡二叉树又是在二叉搜索树的基础上增加了自动维持平衡的性质，插入、搜索、删除的效率都比较高。红黑树也是实现TreeMap存储结构的基石。典型的用途是实现关联数组. 它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。 1、红黑树规则特点 节点分为红色或者黑色； 根节点必为黑色； 叶子节点都为黑色，且为null； 连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）； 从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点； 新加入到红黑树的节点为红色节点； 因为红黑树也是均衡二叉树，需要具备自动维持平衡的性质，上面的6条就是红黑树给出的自动维持平衡所需要具备的规则 为什么说新加入到红黑树中的节点为红色节点 从规则4中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些，下面我们也会举例来说明。 什么情况下，红黑树的结构会被破坏呢？破坏后又怎么维持平衡，维持平衡主要通过两种方式【变色】和【旋转】，【旋转】又分【左旋】和【右旋】，两种方式可相互结合。 2、红黑树节点插入一般插入红色结点进行变色不会有问题，结合红黑树的规则进行向上满足，可以完成，当出现通过变色无法维持平衡规则的问题，这是就要用到了【旋转】 旋转包括【左旋】和【右旋】，左旋：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点。右旋： 顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点。你会发现红黑树的平衡和平衡二叉树的平衡规则一样的。 插入旋转总结 无需调整 【变色】即可实现平衡 【旋转+变色】才可实现平衡 情况1： 当父节点为黑色时插入子节点 空树插入根节点，将根节点红色变为黑色 父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】 情况2： - 父节点和叔父节点都为红色 父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】 情况3： - - 父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】 情况4： - - 父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】 3、红黑树的平衡和AVL树的平衡区别1. AVL树（平衡二叉树）AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而的英文旋转非常耗时的，由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况。 由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。 2. 红黑树一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。 区别： 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。 4、红黑树节点删除相比较于红黑树的节点插入，删除节点更为复杂，我们从子节点是否为null和红色为思考维度来讨论。 4.1 子节点至少有一个为null当待删除的节点的子节点至少有一个为null节点时，删除了该节点后，将其有值的节点取代当前节点即可，若都为null，则将当前节点设置为null，当然如果违反规则了，则按需调整，如【变色】以及【旋转】。 4.2 子节点都是非null节点第一步：找到该节点的前驱或者后继 前驱：左子树中值最大的节点（可得出其最多只有一个非null子节点，可能都为null）； 后继：右子树中值最小的节点（可得出其最多只有一个非null子节点，可能都为null）； 前驱和后继都是值最接近该节点值的节点，类似于该节点.prev = 前驱，该节点.next = 后继。 第二步：将前驱或者后继的值复制到该节点中，然后删掉前驱或者后继 如果删除的是左节点，则将前驱的值复制到该节点中，然后删除前驱；如果删除的是右节点，则将后继的值复制到该节点中，然后删除后继； 这相当于是一种“取巧”的方法，我们删除节点的目的是使该节点的值在红黑树上不存在，因此专注于该目的，我们并不关注删除节点时是否真是我们想删除的那个节点，同时我们也不需考虑树结构的变化，因为树的结构本身就会因为自动平衡机制而经常进行调整。 相关链接：https://blog.csdn.net/fedorafrog/article/details/104405570、https://www.cnblogs.com/ericli-ericli/p/12873061.html、https://www.cnblogs.com/LiaHon/p/11203229.html","categories":[],"tags":[{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"集合框架","date":"2021-05-04T06:46:35.558Z","path":"2021/05/04/集合概述/","text":"Java 集合框架一、集合的由来通常，我们的程序需要根据程序运行时才知道创建多少个对象。但若非程序运行，程序开发阶段，我们根本不知道到底需要多少个数量的对象，甚至不知道它的准确类型。为了满足这些常规的编程需要，我们要求能在任何时候，任何地点创建任意数量的对象，而这些对象用什么来容纳呢？我们首先想到了数组，但是数组只能放统一类型的数据，而且其长度是固定的，那怎么办呢？集合便应运而生了！ 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。 集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于==java.util包==中， 所以当使用集合框架的时候需要进行导包。 二、集合接口看上面的框架图，先抓住它的主干，即Collection和Map。 1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。 （1）List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。 （2）Set是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 2、Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 3、接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 5、最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 三、集合实现类（集合类）Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 1.实现List接口的集合（1）ArrayList ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。 ArrayList擅长于随机访问。同时ArrayList是非同步的。 （2）LinkedList 同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…)); （3）Vector 与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 （4）Stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 2.实现Set接口的集合 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 （1）HashSet HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。 HashSet使用和理解中容易出现的误区: a.HashSet中存放null值 HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。 b.HashSet中存储元素的位置是固定的 HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。 c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 （2）LinkedHashSet LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 （3）TreeSet TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 实现Map接口的集合 Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 1.HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 2.LinkedHashMap LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。 LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 3.TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。 四、如何使用迭代器通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。 一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或 ListIterator接口。 迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。 1234567891011121314151617181920212223242526272829303132//实例//遍历 ArrayListimport java.util.*; public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) &#123; //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式 System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 &#123; System.out.println(ite.next()); &#125; &#125;&#125; 三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 12345678910111213141516171819202122232425262728293031323334353637//遍历Mapimport java.util.*; public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125;&#125; 总结Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"多线程","date":"2021-05-04T06:46:35.558Z","path":"2021/05/04/多线程/","text":"笔记来自于狂神说琴疆老师 b站up主 1、线程简介 线程就是独立的执行路径； 在程序运行时，即使没有自己创建线程，后台与会有多个线程，如主线程，gc 线程 main() 称之为主线程，为系统的入口，用于执行整个程序 在一个线程中，如果开辟了多个线程，线程的运行由调度器安排调度调度器是与操作系统紧密相关的，先后顺序是不能干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制； 线程会带来额外的开销，如 cpu 调度时间，并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 2、线程实现 ( 重点 )进程创建——三种创建方式 Tread class 继承 Tread 类 ( 重点 ) Runnable 接口 实现 Rannable 接口 ( 重点 ) Callable 接口 实现 Callable 接口 ( 了解 ) Tread 自定义线程类继承 Tread 类 重写 run() 方法，编写线程执行体 创建线程对象，调用 start() 方法启动线程 123456789101112131415161718192021public class TestThread extends Thread &#123; @Override public void run() &#123; //run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在看代码&quot;+i); &#125; &#125; public static void main(String[] args) &#123; //main线程，主线程 //创建一个线程对象 TestThread testThread1 = new TestThread(); //调用start()方法开启线程 testThread1.start(); for (int i = 0; i &lt; 2000 ; i++) &#123; System.out.println(&quot;我是主线程&quot;+i); &#125; &#125;&#125; 总结线程调度不一定立即执行，由CPU调度 练习Thread，实现多线程同步下载图片这里需要 common.io 的文件工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.kuang.demo01;import com.sun.org.apache.xalan.internal.xsltc.dom.CurrentNodeListFilter;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.URL;//练习Tread，实现多线程同步下载图片public class TestThread2 extends Thread &#123; private String url; //保存文件地址 private String name; //保存的文件名 TestThread2(String url,String name)&#123; this.url = url; this.name = name; &#125; @Override public void run() &#123; WebDownloder webDownloder = new WebDownloder(); webDownloder.downloder(url,name); System.out.println(&quot;下载了文件名为:&quot;+ name); &#125; public static void main(String[] args) &#123; TestThread2 testThread1 = new TestThread2(&quot;https://whitesheep7.github.io/images/mysql_1.png&quot;,&quot;1.jpg&quot;); TestThread2 testThread2 = new TestThread2(&quot;https://whitesheep7.github.io/images/mysql_2.png&quot;,&quot;2.jpg&quot;); TestThread2 testThread3 = new TestThread2(&quot;https://whitesheep7.github.io/images/mysql_3.png&quot;,&quot;3.jpg&quot;); testThread1.start(); testThread2.start(); testThread3.start(); &#125;&#125;//下载器class WebDownloder&#123; //下载方法 public void downloder(String url,String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(&quot;IO异常，downloder方法出现异常&quot;); &#125; &#125;&#125; Runable 定义 MyRunnable 类实现 Runnable 接口 实现run() 方法，编写线程执行体 创建线程对象，调用start() 方法启动线程 1234567891011121314151617//创建线程方式2：实现runnable()接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start方法public class TestThread3 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在看代码&quot;+i); &#125; &#125; public static void main(String[] args) &#123; TestThread3 testThread3 = new TestThread3(); new Thread(testThread3).start(); for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;我是主线程&quot;+i); &#125; &#125;&#125; 笔记补充：其实runnable和Thread没有多大区别，你去查看Thread源代码是就会发现它使用了runnable这个接口，使用第二中方法就相当于直接使用了接口，这样做也有好处，它避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。 案例：龟兔赛跑—Race 首先来个赛道距离，然后要离终点越来越近 判断比赛是否结束 打印出胜利者 龟兔赛跑开始 故事中是乌龟赢了，兔子需要睡觉，所以我们来模拟兔子睡觉 终于，乌龟赢得比赛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.kuang.demo01;public class Race implements Runnable&#123; private static String winner; @Override public void run() &#123; //模拟兔子休息 if(Thread.currentThread().getName().equals(&quot;兔子&quot;))&#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int i = 1; i &lt;= 100; i++) &#123; //判断比赛是否结束 boolean flag = gameOver(i); //如果比赛结束了，就停止程序 if(flag)&#123; break; &#125; System.out.println(Thread.currentThread().getName() + &quot;跑了&quot; + i + &quot;米&quot;); &#125; &#125; //判断是否结束比赛 private boolean gameOver(int steps)&#123; //判断是否有胜利者 if(winner!=null)&#123; //已经存在胜利者了 return true; &#125;&#123; if (steps&gt;=100) &#123; winner = Thread.currentThread().getName(); System.out.println(winner + &quot;赢得了比赛&quot;); return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; Race race = new Race(); new Thread(race,&quot;兔子&quot;).start(); new Thread(race,&quot;乌龟&quot;).start(); &#125;&#125; 实现 Callable 接口 (了解即可) 实现 Callable 接口，需要返回值类型 重写 call 方法，需要抛出异常 创建目标对象 创建执行服务： 1ExecutorService ser = Executors.newFiledThreadPool(2); 提交执行： 1Future&lt;Boolean&gt; result1 = ser.submit(t1); 获取结果： 1boolean r1 = result1.get(); 关闭服务 1ser.shutdownNow(); 3、线程状态 - 五大状态 停止线程 不推荐使用 JDK 提供的 stop(), destory() 方法。 推荐线程自己停止下来 建议使用一个标志位进行终止变量 当 flag = false，则终止线程运行。 1234567891011121314151617181920212223242526272829303132public class TestStop implements Runnable&#123; //1.设置一个标识位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag)&#123; System.out.println(&quot;run....Thread&quot;+i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标志位 private void stop()&#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;mian&quot;+i); if(i == 900)&#123; //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(&quot;线程该停止了&quot;); &#125; &#125; &#125;&#125; 线程休眠 sleep( 时间 ) 指定当前线程阻塞的毫秒数； sleep 存在异常 InterruptedException; sleep 时间达到后线程进入就绪状态； sleep 可以模拟网络时延，倒计时等； 每一个对象都有一个锁，sleep 不会释放锁； 1234567891011121314151617181920212223242526272829303132import java.text.SimpleDateFormat;import java.util.Date;//模拟倒计时public class TestSleep2&#123; public static void main(String[] args) &#123; //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis()); while (true)&#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime)); startTime = new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //模拟倒计时public static void tenDown() throws InterruptedException &#123; int num = 10; while (true)&#123; Thread.sleep(1000); System.out.println(num--); if (num &lt;= 0)&#123; break; &#125; &#125; &#125;&#125; 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行转为就绪状态 让 cpu 重新调度，礼让不一定成功！看 CPU 心情 Join Join 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 可以想象成插队 1234567891011121314151617181920212223public class TestJion implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;线程vip&quot;+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //启动线程 TestJion testJion = new TestJion(); Thread thread = new Thread(testJion); thread.start(); //主线程运行 for (int i = 0; i &lt; 500; i++) &#123; if(i==300)&#123; thread.join(); &#125; System.out.println(&quot;主线程&quot;+i); &#125; &#125;&#125; 线程状态观测 Thread.State 线程可以处于以下状态之一： NEW 尚未启动的线程处于此状态。 RUNNABLE 在 Java 虚拟机中执行的线程处于此状态 BLOCKED 被阻塞等待监视器锁定的线程处于此状态 WAITING 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITING 正在等待另一个线程执行动作到达指定等待时间的线程处于此状态 TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统状态的虚拟机状态。 123456789101112131415161718192021222324252627282930313233public class TestState &#123; public static void main(String[] args) &#123; Thread thread = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;///////&quot;); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//NEW //观察启动后 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//Run while (state!=Thread.State.TERMINATED)&#123;//只要线程不终止，就一直输出状态 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; state = thread.getState();//Run System.out.println(state); &#125; &#125;&#125; 线程优先级 Java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围是1~10. Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5; 使用以下方式改变或获取优先级 getPriority().setPriority(int xxx) 守护 ( daemon ) 线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待.. 人生不过三万天 123456789101112131415161718192021222324252627282930313233public class TestDaemon &#123; public static void main(String[] args) &#123; You you = new You(); God god = new God(); Thread thread = new Thread(god); thread.setDaemon(true); //默认是false表示是用户线程，正常的线程都是用户线程 thread.start(); //上帝守护线程启动 new Thread(you).start(); //你 用户线程启动 &#125;&#125;//上帝class God implements Runnable&#123; @Override public void run() &#123; while (true) &#123; System.out.println(&quot;上帝保佑着你&quot;); &#125; &#125;&#125;class You implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 36500; i++) &#123; System.out.println(&quot;你开心的过着每一天&quot;); &#125; System.out.println(&quot;-------goodbye,world&quot;); &#125;&#125; 4、 线程同步 ( 重点 )多个线程操作同一个资源 现实生活中，我们会遇到‘’ 同一个资源，多个人都想使用 ‘’的问题，比如食堂排队打饭，每个人都想吃饭，，最天然的解决办法就是，排队。一个一个来。 处理多线程问题是，很多线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步实际上就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 由于同一个线程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问的正确性，在访问时加入 **锁机制 synchronized **, 当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁。释放锁会导致比较多的上下文切换 和 调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级导致，引起性能问题。 并发 同一个对象被多个线程同时操作 同步方法 由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 synchronized 关键字，它包括两种方法：synchronized 方法和 synchronized 块。 1public synchronized void method(int args)&#123;&#125; synchronized 方法控制‘’ 对象 ‘’的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才会获得这个锁，继续执行。 缺陷：若将一个大的方法申明为 synchronized 将会影响效率 12345678910111213141516171819202122232425262728293031323334353637383940414243//不安全的买票public class UnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket station = new BuyTicket(); new Thread(station,&quot;可怜的我&quot;).start(); new Thread(station,&quot;牛逼的你&quot;).start(); new Thread(station,&quot;万恶的黄牛党&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; //票 private int ticketnum= 10; boolean flag = true; //外部停止方法 //买票 @Override public void run() &#123; while (flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //判断是否有票 private void buy() throws InterruptedException &#123; Thread.sleep(2); if(ticketnum&lt;=0)&#123; flag = false; return; &#125; //买票 System.out.println(Thread.currentThread().getName() + &quot;获得了&quot; + ticketnum--); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//不安全的取钱//两个人去银行取钱，账户public class UnsafeBank &#123; public static void main(String[] args) &#123; Account account = new Account(200,&quot;结婚基金&quot;); new Drawing(account,150,&quot;你&quot;).start(); new Drawing(account,100,&quot;girlFriend&quot;).start(); &#125;&#125;//账户class Account&#123; int money; //余额 String name; public Account(int money,String name)&#123; this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; Account account; //账户 int drawingMoney; //取了多少钱 int nowmoney; //现在手里有多少钱 public Drawing(Account account,int drawingMoney,String name)&#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; @Override public void run() &#123; //判断有没有钱 if (account.money-drawingMoney&lt;0)&#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够，取不到&quot;); return; &#125; //sleep可以方法问题的发生性 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额 = 余额 - 你取的钱 account.money = account.money-drawingMoney; //你手里的钱 nowmoney = nowmoney +drawingMoney; System.out.println(account.name+&quot;余额&quot;+account.money); System.out.println(this.getName()+&quot;手里的钱&quot;+nowmoney); &#125;&#125; 1234567891011121314151617//线程不安全的集合public class UnsafeList &#123; public static void main(String[] args) &#123; List&lt;String &gt; list =new ArrayList&lt;String &gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 同步块 同步块：synchronized(Obj)&#123;&#125; Obj 称之为同步监视器 Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this，就是这个对象本身，或者是 class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程范文，发现同步监视器没有锁，然后锁定并访问 JUC 的 CopyOnWriteArrayList 可以直接创建一个安全的数组，当然我们也可以手动的加 1234567891011121314151617public class TestJUC &#123; public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(list.size()); &#125;&#125; 死锁多个线程过日子占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，就停止执行的情形。某一块同时拥有‘’ 两个以上对象的锁 ‘’时，就可能会发生‘’ 死锁 ‘’的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class DeadLock &#123; public static void main(String[] args) &#123; Makeup g1 =new Makeup(0,&quot;灰姑凉&quot;); Makeup g2 =new Makeup(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123;&#125;//镜子class Mirror&#123;&#125;class Makeup extends Thread&#123; //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick =new Lipstick(); static Mirror mirror =new Mirror(); int choose;//选择 String girlName;//使用化妆品的人 Makeup(int choose,String girlName)&#123; this.choose= choose; this.girlName=girlName; &#125; @Override public void run() &#123; //化妆 try &#123; makeup(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //化妆,互相持有对方的锁,就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choose==0)&#123; synchronized (lipstick)&#123; System.out.println(girlName+&quot;获得了口红&quot;); Thread.sleep(1000); synchronized (mirror)&#123; System.out.println(girlName+&quot;又获得了镜子&quot;); &#125; &#125; &#125;else&#123; synchronized (mirror)&#123; System.out.println(girlName+&quot;获得了镜子&quot;); Thread.sleep(2000); synchronized (lipstick)&#123; System.out.println(girlName+&quot;又获得了口红&quot;); &#125; &#125; &#125; &#125;&#125; 解决方法：不要在用一个锁时再想着用另一个锁，这样很可能会出现死锁的问题，办法就是当女孩 1 用完口红时，释放口红的锁，再去拿镜子的锁，另一个女孩也是如此。将锁的嵌套改为锁的并列即可。 死锁避免方法 产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 Lock ( 锁 ) 从JDK 5.0 开始，Java 提供了更强大的线程同步机制 - 通过显示定义同步锁对象来实现同步。同步锁使用 Lock 对象充当。 java.util.concurrent.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象共享资源之前加锁，线程开始访问共享资源之前应先获得 Lock 对象。 ReentrantLock 类（可重入锁）实现了 Lock, 它拥有与synchronized 相同的并发性与内存语句，在定义线程安全的控制中，比较常用的是 ReentrantLock，可以显示加锁，释放锁。 synchronized 与 Lock 的对比 Lock 是显示锁 ( 手动开启和关闭锁，别忘记关闭锁 ) synchronized 是隐式锁，出了作用域自动释放 Lock 只有代码块锁，synchronized 有代码块锁和方法锁 使用 Lock 锁，JVM 将 胡斐较少的时间来调度线程，性能更好。并且具有更好的扩展性 ( 提供更多的子类 ) 优先使用顺序： Lock &gt; 同步代码块 ( 已经进入了方法体，分配了相应资源 ) &gt; ( 在同步方法体之外 ) 12345678910111213class A&#123; private final ReentrantLock lock = new ReentrantLock(); public void m()&#123; lock.lock(); try&#123; //保证线程安全的代码 &#125; finally&#123; lock.unlock(); //如果同步代码有异常，要将unlock()写入finally语句块 &#125; &#125;&#125; 5、线程通信问题 - 线程协作场景应用：生产者和消费者问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，知道仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有 synchronized 是不够的 synchronized 可阻止并发更新同一个共享资源，实现了同步 synchronized 不能用来实现不同线程之间的消息传递( 通信 ) Java 提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与 sleep 不同，会释放锁 wait(long time out) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用 wait() 方法的线程，优先级别高的线程优先调度 解决方式1 - 并发协作模型—&gt;管程法 生产者：负责生产数据的模块 ( 可能是方法，对象，线程，进程 ) 消费者：负责处理数据的模块 ( 可能是方法，对象，线程，进程 ) 缓冲区：消费者不能直接使用生产者的数据，他们之间有个‘’ 缓冲区 ‘’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//测试：生产者消费者模型--&gt;利用缓冲区解决:管程法//生产者，消费者，产品，缓冲区public class TestPC &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container)&#123; this.container= container; &#125; //生产 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;生产了&quot;+i+&quot;只鸡&quot;); container.push(new Chicken(i)); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container)&#123; this.container= container; &#125; //消费 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;消费了--&gt;&quot;+container.pop().id+&quot;只鸡&quot;); &#125; &#125;&#125;//产品class Chicken&#123; int id; //产品编号 public Chicken(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SynContainer&#123; //容器大小 Chicken[] chickens = new Chicken[10]; //容器计数器 int count = 0; //生产者判断 public synchronized void push(Chicken chicken)&#123; //如果产品满了 if (count==chickens.length)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; chickens[count]=chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者判断 public synchronized Chicken pop()&#123; //如果产品没有了 if(count==0)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Chicken chicken= chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; &#125;&#125; 解决方法 2 –&gt;信号灯法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//测试生产者消费者问题2：信号灯法，标志位解决public class TestPc2 &#123; public static void main(String[] args) &#123; TV tv = new TV(); new Player(tv).start(); new Watch(tv).start(); &#125;&#125;//生产者--&gt;演员class Player extends Thread&#123; TV tv; public Player(TV tv)&#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if(i%2==0)&#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125;&#123; this.tv.play(&quot;抖音，记录美好生活&quot;); &#125; &#125; &#125;&#125;//消费者--&gt;观众class Watch extends Thread&#123; TV tv; public Watch(TV tv)&#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; tv.watch(); &#125; &#125;&#125;//产品--&gt;节目class TV&#123; //演员表演，观众等待 T //观众观看，演员等待 F String voice;//表演的节目 boolean flag = true; //表演 public synchronized void play(String voice)&#123; if(!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了&quot;+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice = voice; //节目更新 this.flag = !this.flag; &#125; //观看 public synchronized void watch()&#123; if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了&quot;+voice); //通知演员表演 this.notifyAll(); this.flag = !this.flag; &#125;&#125; 6、线程池1、线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。（是什么） 2、那么，我们为什么需要用到线程池呢？每次用的时候手动创建不行吗？ 在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。（为什么） 线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快；另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。（什么用） 3、线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。 Executors：线程池创建工厂类 **public static ExecutorService newFixedThreadPool(int nThreads)**：返回线程池对象 ExecutorService：线程池类 **Future submit(Runnable task)**：获取线程池中的某一个线程对象，并执行 Future 接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用 4、使用线程池中线程对象的步骤： 1、创建线程池对象 2、创建 Runnable 接口子类对象 3、提交 Runnable 接口子类对象 4、关闭线程池 123456789101112public static void main(String[] args) &#123; //创建线程池对象 参数5，代表有5个线程的线程池 ExecutorService service = Executors.newFixedThreadPool(5); //创建Runnable线程任务对象 TaskRunnable task = new TaskRunnable(); //从线程池中获取线程对象 service.submit(task); //再获取一个线程对象 service.submit(task); //关闭线程池 service.shutdown();&#125; TaskRunnable.java 接口文件如下： 12345678public class TaskRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(&quot;自定义线程任务在执行&quot;+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"IO","date":"2021-05-04T06:46:35.550Z","path":"2021/05/04/IO/","text":"1、IO概要在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。 Java I/O主要包括如下几个层次，包含三个部分： 1.流式部分――IO的主体部分； 2.非流式部分――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类； 3.其他类–文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。 主要的类如下： File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。 InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。 OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。 Reader（文件格式操作）：抽象类，基于字符的输入操作。 Writer（文件格式操作）：抽象类，基于字符的输出操作。 RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。 对于文件类File类之前已经做了详细的介绍，下面主要讲讲IO中的流和序列化 2、流的概念和作用流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 IO流的分类根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 字符流和字节流字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别： （1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 （2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 （3）字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。 结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。 输入流和输出流对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 3、Java IO流对象1. 输入字节流InputStream定义和结构说明：InputStream 是所有的输入字节流的父类，它是一个抽象类。 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。 ObjectInputStream 和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。意思是FileInputStream类可以通过一个String路径名创建一个对象，FileInputStream(String name)。而DataInputStream必须装饰一个类才能返回一个对象，DataInputStream(InputStream in)。 实例操作演示：案例操作： 12345678910111213141516/** * 字节流 * 读文件内容 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; in.read(b); in.close(); System.out.println(new String(b)); &#125;&#125; 注意：该示例中由于b字节数组长度为1024，如果文件较小，则会有大量填充空格。我们可以利用in.read(b);的返回值来设计程序，如下案例： 1234567891011121314151617/** * 字节流 * 读文件内容 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int len=in.read(b); in.close(); System.out.println(&quot;读入长度为：&quot;+len); System.out.println(new String(b,0,len)); &#125;&#125; 注意：观察上面的例子可以看出，我们预先申请了一个指定大小的空间，但是有时候这个空间可能太小，有时候可能太大，我们需要准确的大小，这样节省空间，那么我们可以这样做： 1234567891011121314151617/** * 字节流 * 读文件内容,节省空间 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); InputStream in=new FileInputStream(f); byte[] b=new byte[(int)f.length()]; in.read(b); System.out.println(&quot;文件长度为：&quot;+f.length()); in.close(); System.out.println(new String(b)); &#125;&#125; 【案例】逐字节读 123456789101112131415161718/** * 字节流 * 读文件内容,节省空间 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); InputStream in=new FileInputStream(f); byte[] b=new byte[(int)f.length()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i]=(byte)in.read(); &#125; in.close(); System.out.println(new String(b)); &#125;&#125; 注意：上面的几个例子都是在知道文件的内容多大，然后才展开的，有时候我们不知道文件有多大，这种情况下，我们需要判断是否读到文件的末尾。 1234567891011121314151617181920/** * 字节流 *读文件 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int count =0; int temp=0; while((temp=in.read())!=(-1))&#123; b[count++]=(byte)temp; &#125; in.close(); System.out.println(new String(b)); &#125;&#125; 注意：当读到文件末尾的时候会返回-1.正常情况下是不会返回-1的。 12345678910111213141516171819202122232425test.tx 文件内容如下：runoob1runoob2runoob3runoob4runoob5=========================import java.io.*;public class Test&#123; public static void main(String args[])throws IOException&#123; DataInputStream in = new DataInputStream(new FileInputStream(&quot;test.txt&quot;)); DataOutputStream out = new DataOutputStream(new FileOutputStream(&quot;test1.txt&quot;)); BufferedReader d = new BufferedReader(new InputStreamReader(in)); String count; while((count = d.readLine()) != null)&#123; String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u + &quot; ,&quot;); &#125; d.close(); out.close(); &#125;&#125; PushBackInputStream回退流操作 1234567891011121314151617181920212223242526import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.PushbackInputStream; /** * 回退流操作 * */public class PushBackInputStreamDemo&#123; public static void main(String[] args) throwsIOException&#123; String str = &quot;hello,rollenholt&quot;; PushbackInputStream push = null; ByteArrayInputStream bat = null; bat = new ByteArrayInputStream(str.getBytes()); push = new PushbackInputStream(bat); int temp = 0; while((temp = push.read()) != -1)&#123; if(temp == &#x27;,&#x27;)&#123; push.unread(temp); temp = push.read(); System.out.print(&quot;(回退&quot; +(char) temp + &quot;) &quot;); &#125;else&#123; System.out.print((char) temp); &#125; &#125; &#125;&#125; 2. 输出字节流OutputStream定义和结构说明：OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据， ObjectOutputStream 和所有FilterOutputStream的子类都是装饰流。具体例子跟InputStream是对应的。 实例操作演示：案例： 12345678910111213141516/** * 字节流 * 向文件中写入字符串 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); OutputStream out =new FileOutputStream(f); String str=&quot;Hello World&quot;; byte[] b=str.getBytes(); out.write(b); out.close(); &#125;&#125; 你也可以一个字节一个字节的写入文件：案例： 123456789101112131415161718/** * 字节流 * 向文件中一个字节一个字节的写入字符串 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); OutputStream out =new FileOutputStream(f); String str=&quot;Hello World！！&quot;; byte[] b=str.getBytes(); for (int i = 0; i &lt; b.length; i++) &#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 向文件中追加新内容： 12345678910111213141516171819/** * 字节流 * 向文件中追加新内容： * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); OutputStream out =new FileOutputStream(f,true);//true表示追加模式，否则为覆盖 String str=&quot;Rollen&quot;; //String str=&quot;\\r\\nRollen&quot;; 可以换行 byte[] b=str.getBytes(); for (int i = 0; i &lt; b.length; i++) &#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 复制文件： 1234567891011121314151617181920212223242526import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; if(args.length!=2)&#123; System.out.println(&quot;命令行参数输入有误，请检查&quot;); System.exit(1); &#125; File file1=new File(args[0]); File file2=new File(args[1]); if(!file1.exists())&#123; System.out.println(&quot;被复制的文件不存在&quot;); System.exit(1); &#125; InputStream input=new FileInputStream(file1); OutputStream output=new FileOutputStream(file2); if((input!=null)&amp;&amp;(output!=null))&#123; int temp=0; while((temp=input.read())!=(-1))&#123; output.write(temp); &#125; &#125; input.close(); output.close(); &#125;&#125; 使用内存操作流将一个大写字母转化为小写字母 1234567891011121314151617181920/** * 使用内存操作流将一个大写字母转化为小写字母 * */import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String str=&quot;ROLLENHOLT&quot;; ByteArrayInputStream input=new ByteArrayInputStream(str.getBytes()); ByteArrayOutputStream output=new ByteArrayOutputStream(); int temp=0; while((temp=input.read())!=-1)&#123; char ch=(char)temp; output.write(Character.toLowerCase(ch)); &#125; String outStr=output.toString(); input.close(); output.close(); System.out.println(outStr); &#125;&#125; 【案例】验证管道流：进程间通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.io.*; /** * 消息发送类 * */class Send implements Runnable&#123; private PipedOutputStream out=null; public Send() &#123; out=new PipedOutputStream(); &#125; public PipedOutputStream getOut()&#123; return this.out; &#125; public void run()&#123; String message=&quot;hello , Rollen&quot;; try&#123; out.write(message.getBytes()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;try&#123; out.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; /** * 接受消息类 * */class Recive implements Runnable&#123; private PipedInputStream input=null; public Recive()&#123; this.input=new PipedInputStream(); &#125; public PipedInputStream getInput()&#123; return this.input; &#125; public void run()&#123; byte[] b=new byte[1000]; int len=0; try&#123; len=this.input.read(b); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;try&#123; input.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;接受的内容为 &quot;+(new String(b,0,len))); &#125;&#125;/** * 测试类 * */class hello&#123; public static void main(String[] args) throws IOException &#123; Send send=new Send(); Recive recive=new Recive(); try&#123;//管道连接 send.getOut().connect(recive.getInput()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; new Thread(send).start(); new Thread(recive).start(); &#125;&#125; DataOutputStream类示例 12345678910111213141516import java.io.DataOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class DataOutputStreamDemo&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); char[] ch = &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;; DataOutputStream out = null; out = new DataOutputStream(new FileOutputStream(file)); for(char temp : ch)&#123; out.writeChar(temp); &#125; out.close(); &#125;&#125; ZipOutputStream类 先看一下ZipOutputStream类的继承关系 java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.util.zip.DeflaterOutputStream 123456789101112131415161718public class ZipOutputStreamDemo1&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); File zipFile = new File(&quot;d:&quot; + File.separator +&quot;hello.zip&quot;); InputStream input = new FileInputStream(file); ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream( zipFile)); zipOut.putNextEntry(new ZipEntry(file.getName())); // 设置注释 zipOut.setComment(&quot;hello&quot;); int temp = 0; while((temp = input.read()) != -1)&#123; zipOut.write(temp); &#125; input.close(); zipOut.close(); &#125;&#125; 【案例】ZipOutputStream类压缩多个文件 12345678910111213141516171819202122232425262728/** * 一次性压缩多个文件 * */public class ZipOutputStreamDemo2&#123; public static void main(String[] args) throws IOException&#123; // 要被压缩的文件夹 File file = new File(&quot;d:&quot; + File.separator +&quot;temp&quot;); File zipFile = new File(&quot;d:&quot; + File.separator + &quot;zipFile.zip&quot;); InputStream input = null; ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream( zipFile)); zipOut.setComment(&quot;hello&quot;); if(file.isDirectory())&#123; File[] files = file.listFiles(); for(int i = 0; i &lt; files.length; ++i)&#123; input = newFileInputStream(files[i]); zipOut.putNextEntry(newZipEntry(file.getName() + File.separator +files[i].getName())); int temp = 0; while((temp = input.read()) !=-1)&#123; zipOut.write(temp); &#125; input.close(); &#125; &#125; zipOut.close(); &#125;&#125; 【案例】ZipFile类展示 12345678910/** *ZipFile演示 * */public class ZipFileDemo&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.zip&quot;); ZipFile zipFile = new ZipFile(file); System.out.println(&quot;压缩文件的名称为：&quot; + zipFile.getName()); &#125;&#125; 【案例】解压缩文件（压缩文件中只有一个文件的情况） 12345678910111213141516public class ZipFileDemo2&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.zip&quot;); File outFile = new File(&quot;d:&quot; + File.separator +&quot;unZipFile.txt&quot;); ZipFile zipFile = new ZipFile(file); ZipEntry entry =zipFile.getEntry(&quot;hello.txt&quot;); InputStream input = zipFile.getInputStream(entry); OutputStream output = new FileOutputStream(outFile); int temp = 0; while((temp = input.read()) != -1)&#123; output.write(temp); &#125; input.close(); output.close(); &#125;&#125; 【案例】ZipInputStream类解压缩一个压缩文件中包含多个文件的情况 1234567891011121314151617181920212223242526272829public class ZipFileDemo3&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; +File.separator + &quot;zipFile.zip&quot;); File outFile = null; ZipFile zipFile = new ZipFile(file); ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file)); ZipEntry entry = null; InputStream input = null; OutputStream output = null; while((entry = zipInput.getNextEntry()) != null)&#123; System.out.println(&quot;解压缩&quot; + entry.getName() + &quot;文件&quot;); outFile = new File(&quot;d:&quot; + File.separator + entry.getName()); if(!outFile.getParentFile().exists())&#123; outFile.getParentFile().mkdir(); &#125; if(!outFile.exists())&#123; outFile.createNewFile(); &#125; input = zipFile.getInputStream(entry); output = new FileOutputStream(outFile); int temp = 0; while((temp = input.read()) != -1)&#123; output.write(temp); &#125; input.close(); output.close(); &#125; &#125;&#125; 3、几个特殊的输入流类分析LineNumberInputStream主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。 PushbackInputStream其功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。 StringBufferInputStream已经被Deprecated，本身就不应该出现在InputStream部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。 SequenceInputStream可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。 【案例】将两个文本文件合并为另外一个文本文件 1234567891011121314151617181920public class SequenceInputStreamDemo&#123; public static voidmain(String[] args) throws IOException&#123; File file1 = newFile(&quot;d:&quot; + File.separator + &quot;hello1.txt&quot;); File file2 = newFile(&quot;d:&quot; + File.separator + &quot;hello2.txt&quot;); File file3 = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); InputStream input1 =new FileInputStream(file1); InputStream input2 =new FileInputStream(file2); OutputStream output =new FileOutputStream(file3); // 合并流 SequenceInputStreamsis = new SequenceInputStream(input1, input2); int temp = 0; while((temp =sis.read()) != -1)&#123; output.write(temp); &#125; input1.close(); input2.close(); output.close(); sis.close(); &#125;&#125; PrintStream也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.err和System.out 就是PrintStream 的实例！ 【案例】使用PrintStream进行输出 12345678910import java.io.*;class hello &#123; public static void main(String[] args) throws IOException &#123; PrintStream print = new PrintStream(new FileOutputStream(newFile(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;))); print.println(true); print.println(&quot;Rollen&quot;); print.close(); &#125;&#125; 【案例】使用PrintStream进行格式化输出 1234567891011import java.io.*;class hello &#123; public static void main(String[] args) throws IOException &#123; PrintStream print = new PrintStream(new FileOutputStream(newFile(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;))); String name=&quot;Rollen&quot;; int age=20; print.printf(&quot;姓名：%s. 年龄：%d.&quot;,name,age); print.close(); &#125;&#125; 【案例】使用OutputStream向屏幕上输出内容 12345678910111213141516import java.io.*;class hello &#123; public static void main(String[] args) throws IOException &#123; OutputStream out=System.out; try&#123; out.write(&quot;hello&quot;.getBytes()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; try&#123; out.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 【案例】输入输出重定向 12345678910111213public class systemDemo&#123; public static void main(String[] args)&#123; // 此刻直接输出到屏幕 System.out.println(&quot;hello&quot;); File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); try&#123; System.setOut(new PrintStream(new FileOutputStream(file))); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;这些内容在文件中才能看到哦！&quot;); &#125;&#125; 【案例】使用System.err重定向 123456789101112public class systemErr&#123; public static void main(String[] args)&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); System.err.println(&quot;这些在控制台输出&quot;); try&#123; System.setErr(new PrintStream(new FileOutputStream(file))); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; System.err.println(&quot;这些在文件中才能看到哦！&quot;); &#125;&#125; 【案例】System.in重定向 12345678910111213141516171819202122public class systemIn&#123; public static void main(String[] args)&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); if(!file.exists())&#123; return; &#125;else&#123; try&#123; System.setIn(newFileInputStream(file)); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; byte[] bytes = new byte[1024]; int len = 0; try&#123; len = System.in.read(bytes); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;读入的内容为：&quot; + new String(bytes, 0, len)); &#125; &#125;&#125; 4.字符输入流Reader定义和说明：Reader 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。 BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。 FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。 实例操作演示：【案例】从文件中读取内容` 12345678910111213import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); char[] ch=new char[100]; Reader read=new FileReader(f); int count=read.read(ch); read.close(); System.out.println(&quot;读入的长度为：&quot;+count); System.out.println(&quot;内容为&quot;+new String(ch,0,count)); &#125;&#125; 注意：当然最好采用循环读取的方式，因为我们有时候不知道文件到底有多大。 【案例】以循环方式从文件中读取内容 12345678910111213141516import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); char[] ch=new char[100]; Reader read=new FileReader(f); int temp=0; int count=0; while((temp=read.read())!=(-1))&#123; ch[count++]=(char)temp; &#125; read.close(); System.out.println(&quot;内容为&quot;+new String(ch,0,count)); &#125;&#125; 【案例】BufferedReader的小例子 注意：BufferedReader只能接受字符流的缓冲区，因为每一个中文需要占据两个字节，所以需要将System.in这个字节输入流变为字符输入流，采用： BufferedReader buf = new BufferedReader(newInputStreamReader(System.in)); 1234567891011121314151617/** * 使用缓冲区从键盘上读入内容 * */public class BufferedReaderDemo&#123; public static void main(String[] args)&#123; BufferedReader buf = new BufferedReader( newInputStreamReader(System.in)); String str = null; System.out.println(&quot;请输入内容&quot;); try&#123; str = buf.readLine(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;你输入的内容是：&quot; + str); &#125;&#125; 【案例】Scanner类实例 1234567891011121314151617import java.util.Scanner;/** *Scanner的小例子，从键盘读数据 * */public class ScannerDemo&#123; publicstatic void main(String[] args)&#123; Scanner sca = new Scanner(System.in); // 读一个整数 int temp = sca.nextInt(); System.out.println(temp); //读取浮点数 float flo=sca.nextFloat(); System.out.println(flo); //读取字符 //...等等 &#125;&#125; 【案例】Scanner类从文件中读出内容 1234567891011121314public class ScannerDemo&#123; public static void main(String[] args)&#123; File file = new File(&quot;d:&quot; + File.separator +&quot;hello.txt&quot;); Scanner sca = null; try&#123; sca = new Scanner(file); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; String str = sca.next(); System.out.println(&quot;从文件中读取的内容是：&quot; + str); &#125;&#125; 5.字符输出流Writer定义和说明：Writer 是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。 PipedWriter 是向与其它线程共用的管道中写入数据， BufferedWriter 是一个装饰器为Writer 提供缓冲功能。 PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。 OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似。 实例操作演示：【案例】向文件中写入数据 1234567891011import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); Writer out =new FileWriter(f); String str=&quot;hello&quot;; out.write(str); out.close(); &#125;&#125; 注意：这个例子上之前的例子没什么区别，只是你可以直接输入字符串，而不需要你将字符串转化为字节数组。当你如果想问文件中追加内容的时候，可以使用将上面的声明out的哪一行换为：Writer out =new FileWriter(f,true);这样，当你运行程序的时候，会发现文件内容变为：hellohello如果想在文件中换行的话，需要使用“\\r\\n”比如将str变为String str=”\\r\\nhello”;这样文件追加的str的内容就会换行了。 6、字符流与字节流转换转换流的特点：（1）其实是字符流和字节流之间的桥梁 （2）可对读取到的字节数据经过指定编码转换成字符 （3）可对读取到的字符数据经过指定编码转换成字节 何时使用转换流？当字节和字符之间有转换动作时； 流操作的数据需要编码或解码时。 具体的对象体现：InputStreamReader:字节到字符的桥梁 OutputStreamWriter:字符到字节的桥梁 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。 字节流和字符流转换实例：【案例】将字节输出流转化为字符输出流 12345678910import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName= &quot;d:&quot;+File.separator+&quot;hello.txt&quot;; File file=new File(fileName); Writer out=new OutputStreamWriter(new FileOutputStream(file)); out.write(&quot;hello&quot;); out.close(); &#125;&#125; 【案例】将字节输入流转换为字符输入流 123456789101112import java.io.*;class hello&#123; public static void main(String[] args) throws IOException &#123; String fileName= &quot;d:&quot;+File.separator+&quot;hello.txt&quot;; File file=new File(fileName); Reader read=new InputStreamReader(new FileInputStream(file)); char[] b=new char[100]; int len=read.read(b); System.out.println(new String(b,0,len)); read.close(); &#125;&#125; 7、File类File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 1234567891011121314151617181920212223//创建一个文件File f=new File(&quot;D:\\\\hello.txt&quot;);//File类的两个常量System.out.println(File.separator);System.out.println(File.pathSeparator);//删除一个文件（或者文件夹）if(f.exists())&#123; f.delete();&#125;else&#123; System.out.println(&quot;文件不存在&quot;);&#125;//创建一个文件夹String fileName=&quot;D:&quot;+File.separator+&quot;hello&quot;;File f=new File(fileName);f.mkdir();//列出目录下的所有文件String[] str=f.list();for (int i = 0; i &lt; str.length; i++) &#123; System.out.println(str[i]);&#125;//注意使用list返回的是String数组，。而且列出的不是完整路径，如果想列出完整路径的话，需要使用listFiles.它返回的是File的数组。//此外还有不少不一一说了，有兴趣可以去看相关链接和专门写File的一篇文章//判断一个指定的路径是否为目录 8、RandomAccessFile类该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。该对象特点： 该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。 该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw) 注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。可以用于多线程下载或多个线程同时写数据到文件。 【案例】使用RandomAccessFile写入文件 123456789101112131415import java.io.*;class hello&#123; public static void main(String[]args) throws IOException &#123; StringfileName=&quot;D:&quot;+File.separator+&quot;hello.txt&quot;; File f=new File(fileName); RandomAccessFile demo=newRandomAccessFile(f,&quot;rw&quot;); demo.writeBytes(&quot;asdsad&quot;); demo.writeInt(12); demo.writeBoolean(true); demo.writeChar(&#x27;A&#x27;); demo.writeFloat(1.21f); demo.writeDouble(12.123); demo.close(); &#125;&#125; 4、IO流的高级概念编码问题【案例 】取得本地的默认编码 12345publicclass CharSetDemo&#123; public static void main(String[] args)&#123; System.out.println(&quot;系统默认编码为：&quot;+ System.getProperty(&quot;file.encoding&quot;)); &#125;&#125; 【案例 】乱码的产生 123456789public class CharSetDemo2&#123; public static void main(String[] args) throws IOException&#123; File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); OutputStream out = new FileOutputStream(file); byte[] bytes = &quot;你好&quot;.getBytes(&quot;ISO8859-1&quot;); out.write(bytes); out.close(); &#125;//输出结果为乱码，系统默认编码为GBK，而此处编码为ISO8859-1&#125; 对象的序列化对象序列化就是把一个对象变为二进制数据流的一种方法。 一个类要想被序列化，就行必须实现java.io.Serializable接口。虽然这个接口中没有任何方法，就如同之前的cloneable接口一样。实现了这个接口之后，就表示这个类具有被序列化的能力。先让我们实现一个具有序列化能力的类吧： 【案例 】实现具有序列化能力的类 123456789101112131415public class SerializableDemo implements Serializable&#123; public SerializableDemo()&#123; &#125; publicSerializableDemo(String name, int age)&#123; this.name=name; this.age=age; &#125; @Override public String toString()&#123; return &quot;姓名：&quot;+name+&quot; 年龄：&quot;+age; &#125; private String name; private int age;&#125; 【案例 】序列化一个对象 – ObjectOutputStream 1234567891011121314151617181920212223242526public class Person implements Serializable&#123; public Person()&#123; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return &quot;姓名：&quot; +name + &quot; 年龄：&quot; +age; &#125; private String name; private int age;&#125;/** * 示范ObjectOutputStream * */public class ObjectOutputStreamDemo&#123; public static voidmain(String[] args) throws IOException&#123; File file = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectOutputStream oos= new ObjectOutputStream(new FileOutputStream( file)); oos.writeObject(newPerson(&quot;rollen&quot;, 20)); oos.close(); &#125;&#125; 【案例 】反序列化—ObjectInputStream 12345678910public class ObjectInputStreamDemo&#123; public static voidmain(String[] args) throws Exception&#123; File file = new File(&quot;d:&quot; +File.separator + &quot;hello.txt&quot;); ObjectInputStreaminput = new ObjectInputStream(new FileInputStream( file)); Object obj =input.readObject(); input.close(); System.out.println(obj); &#125;&#125; 注意：被Serializable接口声明的类的对象的属性都将被序列化，但是如果想自定义序列化的内容的时候，就需要实现Externalizable接口。 当一个类要使用Externalizable这个接口的时候，这个类中必须要有一个无参的构造函数，如果没有的话，在构造的时候会产生异常，这是因为在反序列话的时候会默认调用无参的构造函数。 现在我们来演示一下序列化和反序列话： 【案例 】使用Externalizable来定制序列化和反序列化操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ExternalizableDemo&#123; public static voidmain(String[] args) throws Exception&#123; ser(); // 序列化 dser(); // 反序列话 &#125; public static void ser()throws Exception&#123; File file = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectOutputStream out= new ObjectOutputStream(new FileOutputStream( file)); out.writeObject(newPerson(&quot;rollen&quot;, 20)); out.close(); &#125; public static void dser()throws Exception&#123; File file = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectInputStreaminput = new ObjectInputStream(new FileInputStream( file)); Object obj =input.readObject(); input.close(); System.out.println(obj); &#125;&#125; class Person implements Externalizable&#123; public Person()&#123; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return &quot;姓名：&quot; +name + &quot; 年龄：&quot; +age; &#125; // 复写这个方法，根据需要可以保存的属性或者具体内容，在序列化的时候使用 @Override public voidwriteExternal(ObjectOutput out) throws IOException&#123; out.writeObject(this.name); out.writeInt(age); &#125; // 复写这个方法，根据需要读取内容 反序列话的时候需要 @Override public voidreadExternal(ObjectInput in) throws IOException, ClassNotFoundException&#123; this.name = (String)in.readObject(); this.age =in.readInt(); &#125; private String name; private int age;&#125; 注意：Serializable接口实现的操作其实是吧一个对象中的全部属性进行序列化，当然也可以使用我们上使用是Externalizable接口以实现部分属性的序列化，但是这样的操作比较麻烦， 当我们使用Serializable接口实现序列化操作的时候，如果一个对象的某一个属性不想被序列化保存下来，那么我们可以使用transient关键字进行说明： 【案例 】使用transient关键字定制序列化和反序列化操作 12345678910111213141516171819202122232425262728293031323334353637383940414243public class serDemo&#123; public static voidmain(String[] args) throws Exception&#123; ser(); // 序列化 dser(); // 反序列话 &#125; public static void ser()throws Exception&#123; File file = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectOutputStream out= new ObjectOutputStream(new FileOutputStream( file)); out.writeObject(newPerson1(&quot;rollen&quot;, 20)); out.close(); &#125; public static void dser()throws Exception&#123; File file = newFile(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectInputStreaminput = new ObjectInputStream(new FileInputStream( file)); Object obj =input.readObject(); input.close(); System.out.println(obj); &#125;&#125; class Person1 implements Serializable&#123; public Person1()&#123; &#125; public Person1(Stringname, int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return &quot;姓名：&quot; +name + &quot; 年龄：&quot; +age; &#125; // 注意这里 private transient Stringname; private int age;&#125; 【运行结果】： 姓名：null 年龄：20 【案例 】序列化一组对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SerDemo1&#123; public static void main(String[] args) throws Exception&#123; Student[] stu = &#123; new Student(&quot;hello&quot;, 20), new Student(&quot;world&quot;, 30), new Student(&quot;rollen&quot;, 40) &#125;; ser(stu); Object[] obj = dser(); for(int i = 0; i &lt; obj.length; ++i)&#123; Student s = (Student) obj[i]; System.out.println(s); &#125; &#125; // 序列化 public static void ser(Object[] obj) throws Exception&#123; File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream( file)); out.writeObject(obj); out.close(); &#125; // 反序列化 public static Object[] dser() throws Exception&#123; File file = new File(&quot;d:&quot; + File.separator + &quot;hello.txt&quot;); ObjectInputStream input = new ObjectInputStream(new FileInputStream( file)); Object[] obj = (Object[]) input.readObject(); input.close(); return obj; &#125;&#125; class Student implements Serializable&#123; public Student()&#123; &#125; public Student(String name, int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return &quot;姓名： &quot; + name + &quot; 年龄：&quot; + age; &#125; private String name; private int age;&#125; 相关链接：https://www.cnblogs.com/ylspace/p/8128112.html、https://www.cnblogs.com/QQ846300233/p/6046388.html、https://www.cnblogs.com/rollenholt/archive/2011/09/11/2173787.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"IO","slug":"IO","permalink":"http://example.com/tags/IO/"}]},{"title":"HashMap底层","date":"2021-05-04T06:46:35.520Z","path":"2021/05/04/HashMap底层/","text":"一、HashMap概述 在JDK1.8之前，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 jdk1.8之前的hashmap结构，左边部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。 jdk1.8之前的hashmap，都是基于一个数组和多个单链表，hash值冲突的时候，就将对应节点以链表的形式存储。如果在一个链表中查找其中一个节点时，将会花费O（n）的查找时间，会有很大的性能损失。到了jdk1.8，当同一个hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树。 二、涉及到的数据结构：处理hash冲突的链表和红黑树以及位桶1、链表的实现12//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; &#123;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 node中包含一个next变量，这个就是链表的关键点，hash结果相同的元素就是通过这个next进行关联的。 2、红黑树12//红黑树static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123;&#125; 红黑树比链表多了四个变量，parent父节点、left左节点、right右节点、prev上一个同级节点，红黑树内容较多，不在赘述。 3、位桶1transient Node&lt;k,v&gt;[] table;//存储（位桶）的数组 HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。 有了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。 三、HashMap源码分析1、类的继承关系1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 可以看到HashMap继承自父类（AbstractMap），实现了Map、Cloneable、Serializable接口。其中，Map接口定义了一组通用的操作；Cloneable接口则表示可以进行拷贝，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响被拷贝的对象；Serializable接口表示HashMap实现了序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。 2、类的属性类的数据成员很重要，下面解释得很详细了。 12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 填充因子 final float loadFactor;&#125; 3、类的构造函数（1）HashMap(int, float)型构造函数1234567891011121314151617public HashMap(int initialCapacity, float loadFactor) &#123; // 初始容量不能小于0，否则报错 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 初始容量不能大于最大值，否则为最大值 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 填充因子不能小于或等于0，不能为非数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 初始化填充因子 this.loadFactor = loadFactor; // 初始化threshold大小 this.threshold = tableSizeFor(initialCapacity); &#125; 说明：tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这个是给容量定义初始大小的，列入你传入了一个自定义的大小为10，传入这个函数，之后该函数进行计算，将最终的capacaity计算出来并返回，对于这个计算，采用的是有关二进制的，推荐一篇关于了解这个的文章https://blog.csdn.net/Qgwperfect/article/details/87686913。 这个函数最终将this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;，你会像是不是缺少了将容器乘与填充因子0.75，这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。 但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算。 4、重要方法分析putVal方法 HashMap并没有直接提供putVal接口给用户调用，而是提供的put方法，而put方法就是通过putVal来插入元素的。 putVal方法执行过程 ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 具体源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // 步骤④：判断该链为红黑树 // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 步骤⑥：超过最大容量 就扩容 // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; 注意： HashMap的put会返回key的上一次保存的数据，比如： 1234HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();System.out.println(map.put(&quot;a&quot;, &quot;A&quot;)); // 打印nullSystem.out.println(map.put(&quot;a&quot;, &quot;AA&quot;)); // 打印ASystem.out.println(map.put(&quot;a&quot;, &quot;AB&quot;)); // 打印AA getNode方法 HashMap同样并没有直接提供getNode接口给用户调用，而是提供的get方法，而get方法就是通过getNode来取得元素的。 resize方法 ①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容； ②.每次扩展的时候，都是扩展2倍； ③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。 相关链接：https://www.cnblogs.com/xiaoxi/p/7233201.html、https://blog.csdn.net/Qgwperfect/article/details/87686913","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"HashSet与HashMap","date":"2021-05-04T06:46:35.520Z","path":"2021/05/04/HashSet与HashMap/","text":"HashSet与HashMapHashSetHashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。 HashSet 实现了 Set 接口。 HashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。 123import java.util.HashSet; // 引入 HashSet 类HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;();//创建对象 1、添加元素添加元素可以使用 add() 方法: 2、判断元素是否存在我们可以使用 contains() 方法来判断元素是否存在于集合当中: 3、删除元素我们可以使用 remove() 方法来删除集合中的元素；删除集合中所有元素可以使用 clear 方法： 4、计算大小如果要计算 HashSet 中的元素数量可以使用 size() 方法：重复的元素不会被添加 5、迭代 HashSet可以使用 for-each 来迭代 HashSet 中的元素。 12345678910111213141516// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; HashMapHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。 HashMap 是无序的，即不会记录插入的顺序。 HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。 HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。 123import java.util.HashMap; // 引入 HashMap 类HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); 1、添加元素添加键值对(key-value)可以使用 put() 方法: 12345678910111213141516// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites); &#125;&#125;//输出结果为&#123;1=Google, 2=Runoob, 3=Taobao, 4=Zhihu&#125; 2、访问元素我们可以使用 get(key) 方法来获取 key 对应的 value: 3、删除元素我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value)；删除所有键值对(key-value)可以使用 clear 方法： 4、计算大小如果要计算 HashMap 中的元素数量可以使用 size() 方法： 5、迭代 HashMap可以使用 for-each 来迭代 HashMap 中的元素。 如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。 1234567891011121314151617181920212223// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); // 输出 key 和 value for (Integer i : Sites.keySet()) &#123; System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + Sites.get(i)); &#125; // 返回所有 value 值 for(String value: Sites.values()) &#123; // 输出每一个value System.out.print(value + &quot;, &quot;); &#125; &#125;&#125; 更多方法123456789101112131415161718192021222324252627putAll(Map m) //将指定所有的键/值对插入到 HashMap 中。m - 包含插入到 HashMap 的映射关系import java.util.HashMap;class Main &#123; public static void main(String[] args) &#123; // 创建一个 HashMap HashMap&lt;Integer, String&gt; sites = new HashMap&lt;&gt;(); // 往 HashMap 添加一些元素 sites.put(1, &quot;Google&quot;); sites.put(2, &quot;Runoob&quot;); sites.put(3, &quot;Taobao&quot;); System.out.println(&quot;sites HashMap: &quot; + sites); // 创建另一个 HashMap HashMap&lt;Integer, String&gt; sites2 = new HashMap&lt;&gt;(); sites2.put(1, &quot;Weibo&quot;); // 已存在会被替换 sites2.put(4, &quot;Wiki&quot;); // 将所有的映射关系从 sites 添加到 sites2 sites2.putAll(sites); System.out.println(&quot;sites2 HashMap: &quot; + sites2); &#125;&#125;//输出sites HashMap: &#123;1=Google, 2=Runoob, 3=Taobao&#125;sites2 HashMap: &#123;1=Google, 2=Runoob, 3=Taobao, 4=Wiki&#125;//ites 和 site2，代码后面使用了 putAll() 方法将 sites 的 Key/value插入到 site2 中，其中 site2 中 key 为 1 的已经存在，所以 site 对应的 value 会替换 site2 对应对 value。 123putIfAbsent(K key, V value); //先判断指定的键（key）是否存在，不存在则将键/值对插入到 HashMap 中。replaceAll(); //将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。 //sites.replaceAll((key, value) -&gt; value.toUpperCase()); 原文链接：https://www.runoob.com/java","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"StringBuilder的capacity","date":"2021-04-26T04:15:07.531Z","path":"2021/04/26/StringBuilder的capacity/","text":"当创建对象时赋值，它的值capacaty+字符串的长度 当对其进行append，insert增加时，capacaty变化和追加的字符串长度有关 该capacaty规则对增加字符串长度的都满足，如insert，append，replace 同时继承的是AbstractStringBuilder，对StringBuilder和StringBuffer都满足 写一个append查看它的底层 1、可以看到StringBuilder调用了父类的append方法 1234public StringBuilder append(String str) &#123; super.append(str); return this;&#125; 2、我们查看sppend追加方法的父类AbstractStringBuilder， 123456789public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125; 3、其中有一个ensureCapacityInternal(count + len);保证内部容器的安全措施，查看 1234567private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code溢出的代码 if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; 这里的minimumCapacity为新添加的数据长度和已有数据长度的和 4、其中的一个newCapacity即为新容器的大小，点开 12345678910private int newCapacity(int minCapacity) &#123; // overflow-conscious code int newCapacity = (value.length &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; &#125; return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity;&#125; 5、可以看到对于容器变化的规则 首先新的容器为原容器的二倍加二，之后再和minimumCapacity进行比较 参考文章：https://blog.csdn.net/cuncaojin/article/details/78925234","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"Random类","date":"2021-04-26T04:15:07.522Z","path":"2021/04/26/Random类/","text":"Random类（Java.util）Random类中实现的随机算法是伪随机，也就是有规则的随机。在进行随机时，随机算法的起源数字称为种子数(seed)，在种子数的基础上进行一定的变换，从而产生需要的随机数字。 相同种子数的Random对象，相同次数生成的随机数字是完全相同的。也就是说，两个种子数相同的Random对象，第一次生成的随机数字完全相同，第二次生成的随机数字也完全相同。这点在生成多个随机数字时需要特别注意。 1、Random对象的生成Random类包含两个构造方法： public Random() 该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。 public Random(long seed) 再次强调：==种子数只是随机算法的起源数字，和生成的随机数字的区间无关==。 2、Random类中的常用方法 public boolean nextBoolean() 生成一个随机的boolean值，生成true和false的值几率相等 public double nextDouble() 生成一个随机的double值，数值介于[0,1.0)之间，就是java.math.random public int nextInt() 生成一个随机的int值，该值介于int的区间，从-2的31次方到2的31次方之间 public int nextInt(int n) 生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值 public void setSeed(long seed) 重新设置Random对象中的种子数。设置完种子数以后的Random对象和相同种子数使用new关键字创建出的Random对象相同。 它有一个几率实现的设置，有兴趣的可以搜搜 3、其它问题 相同种子数Random对象问题 12345678public static void main(String[] args) &#123; Random r1 = new Random(); Random r2 = new Random(); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(r1.nextInt()); System.out.println(r2.nextInt()); &#125;&#125; 该代码中，对象r1和r2使用的种子数都是10，则这两个对象相同次数生成的随机数是完全相同的。如果想避免出现随机数字相同的情况，则需要注意，无论项目中需要生成多少个随机数字，都只使用一个Random对象即可。 关于Math类中的random方法 其实在Math类中也有一个random方法，该random方法的工作是生成一个[0,1.0)区间的随机小数。 通过阅读Math类的源代码可以发现，Math类中的random方法就是直接调用Random类中的nextDouble方法实现的。只是random方法的调用比较简单，所以很多程序员都习惯使用Math类的random方法来生成随机数字。 引用原文：https://www.cnblogs.com/Fskjb/archive/2009/08/29/1556417.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"pat1017","date":"2021-04-26T04:15:07.522Z","path":"2021/04/26/pat1017/","text":"1017. A除以B [⼤整数运算]本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R， 使得A = B * Q + R成⽴。 输⼊格式： 输⼊在1⾏中依次给出A和B，中间以1空格分隔。 输出格式： 在1⾏中依次输出Q和R，中间以1空格分隔。 输⼊样例： 1123456789050987654321 7 输出样例1： 117636684150141093474 3 分析：模拟⼿动除法的过程，每次⽤第⼀位去除以B，如果得到的商不是0就输出，否则就*10+下⼀ 位，直到最后的数为余数～ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; string s; int a, t = 0, temp = 0; cin &gt;&gt; s &gt;&gt; a; int len = s.length(); t = (s[0] - &#x27;0&#x27;) / a; if ((t != 0 &amp;&amp; len &gt; 1) || len == 1) cout &lt;&lt; t; temp = (s[0] - &#x27;0&#x27;) % a; for (int i = 1; i &lt; len; i++) &#123; t = (temp * 10 + s[i] - &#x27;0&#x27;) / a; cout &lt;&lt; t; temp = (temp * 10 + s[i] - &#x27;0&#x27;) % a; &#125; cout &lt;&lt; &quot; &quot; &lt;&lt; temp; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#51;&#x30;&#x34;&#x37;&#48;&#x33;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1018","date":"2021-04-26T04:15:07.522Z","path":"2021/04/26/pat1018/","text":"1018. 锤⼦剪⼑布[模拟]⼤家应该都会玩“锤⼦剪⼑布”的游戏：两⼈同时给出⼿势，胜负规则如图所示： 现给出两⼈的交锋记录，请统计双⽅的胜、平、负次数，并且给出双⽅分别出什么⼿势的胜算最⼤。 输⼊格式： ⼤家应该都会玩“锤⼦剪⼑布”的游戏：两⼈同时给出⼿势，胜负规则如图所示： 现给出两⼈的交锋记录，请统计双⽅的胜、平、负次数，并且给出双⽅分别出什么⼿势的胜算最⼤。 输出格式： 输出第1、2⾏分别给出甲、⼄的胜、平、负次数，数字间以1个空格分隔。第3⾏给出两个字⺟， 分别代表甲、⼄获胜次数最多的⼿势，中间有1个空格。如果解不唯⼀，则输出按字⺟序最⼩的解。 输⼊样例： 123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例： 1235 3 22 3 5B B 分析：jiawin、yiwin分别表示甲⼄赢的次数，s和t分别表示每⼀次甲⼄给出的⼿势，maxjia和maxyi分 别表示甲⼄获胜次数最多的⼿势所对应的下标（012分别表示BCJ），枚举每⼀次甲⼄⼿势的胜负结果 并累加到jiawin和yiwin中，最后根据题⽬要求输出结果～ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int jiawin = 0, yiwin = 0; int jia[3] = &#123;0&#125;, yi[3] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; char s, t; cin &gt;&gt; s &gt;&gt; t; if (s == &#x27;B&#x27; &amp;&amp; t == &#x27;C&#x27;) &#123; jiawin++; jia[0]++; &#125; else if (s == &#x27;B&#x27; &amp;&amp; t == &#x27;J&#x27;) &#123; yiwin++; yi[2]++; &#125; else if (s == &#x27;C&#x27; &amp;&amp; t == &#x27;B&#x27;) &#123; yiwin++; yi[0]++; &#125; else if (s == &#x27;C&#x27; &amp;&amp; t == &#x27;J&#x27;) &#123; jiawin++; jia[1]++; &#125; else if (s == &#x27;J&#x27; &amp;&amp; t == &#x27;B&#x27;) &#123; jiawin++; jia[2]++; &#125; else if (s == &#x27;J&#x27; &amp;&amp; t == &#x27;C&#x27;) &#123; yiwin++; yi[1]++; &#125; &#125; cout &lt;&lt; jiawin &lt;&lt; &quot; &quot; &lt;&lt; n - jiawin - yiwin &lt;&lt; &quot; &quot; &lt;&lt; yiwin &lt;&lt; endl &lt;&lt;yiwin &lt;&lt; &quot; &quot; &lt;&lt; n - jiawin - yiwin &lt;&lt; &quot; &quot; &lt;&lt; jiawin &lt;&lt; endl; int maxjia = jia[0] &gt;= jia[1] ? 0 : 1; maxjia = jia[maxjia] &gt;= jia[2] ? maxjia : 2; int maxyi = yi[0] &gt;= yi[1] ? 0 : 1; maxyi = yi[maxyi] &gt;= yi[2] ? maxyi : 2; char str[4] = &#123;&quot;BCJ&quot;&#125;; cout &lt;&lt; str[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; str[maxyi]; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#51;&#48;&#x34;&#x37;&#x30;&#51;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1019","date":"2021-04-26T04:15:07.522Z","path":"2021/04/26/pat1019/","text":"1019. 数字⿊洞[数学问题]给定任⼀个各位数字不完全相同的4位正整数，如果我们先把4个数字按⾮递增排序， 再按⾮递减排序，然后⽤第1个数字减第2个数字，将得到⼀个新的数字。⼀直重复 这样做，我们很快会停在有“数字⿊洞”之称的6174，这个神奇的数字也叫Kaprekar常数。 例如，我们从6767开始，将得到 7766 – 6677 = 1089 9810 – 0189 = 9621 9621 – 1269 = 8352 8532 – 2358 = 6174 7641 – 1467 = 6174 … … 现给定任意4位正整数，请编写程序演示到达⿊洞的过程。 输⼊格式： 输⼊给出⼀个(0, 10000)区间内的正整数N。 输出格式： 如果N的4位数字全相等，则在⼀⾏内输出“N – N = 0000”；否则将计算的每⼀步在 ⼀⾏内输出，直到6174作为差出现，输出格式⻅样例。注意每个数字按4位数格式输出。 输⼊样例1： 16767 输出样例1： 12347766 – 6677 = 10899810 – 0189 = 96219621 – 1269 = 83528532 – 2358 = 6174 输⼊样例2： 12222 输出样例2： 12222 – 2222 = 0000 分析：有⼀个测试⽤例注意点，如果当输⼊N值为6174的时候，依旧要进⾏下⾯的步骤，直到差值为 6174才可以～所以⽤do while语句，⽆论是什么值总是要执⾏⼀遍while语句，直到遇到差值是0000或 6174～ 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b) &#123;return a &gt; b;&#125;int main() &#123; string s; cin &gt;&gt; s; s.insert(0, 4 - s.length(), &#x27;0&#x27;); do &#123; string a = s, b = s; sort(a.begin(), a.end(), cmp); sort(b.begin(), b.end()); int result = stoi(a) - stoi(b); s = to_string(result); s.insert(0, 4 - s.length(), &#x27;0&#x27;); cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; s &lt;&lt; endl; &#125; while (s != &quot;6174&quot; &amp;&amp; s != &quot;0000&quot;); return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#50;&#51;&#x30;&#x34;&#x37;&#48;&#x33;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Math常用方法","date":"2021-04-26T04:15:07.506Z","path":"2021/04/26/Math类常用方法/","text":"Math常用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Demo&#123; public static void main(String args[])&#123; /** *Math.sqrt()//计算平方根 *Math.cbrt()//计算立方根 *Math.pow(a, b)//计算a的b次方 *Math.max( , );//计算最大值 *Math.min( , );//计算最小值 */ System.out.println(Math.sqrt(16)); //4.0 System.out.println(Math.cbrt(8)); //2.0 System.out.println(Math.pow(3,2)); //9.0 System.out.println(Math.max(2.3,4.5));//4.5 System.out.println(Math.min(2.3,4.5));//2.3 /** * abs求绝对值 */ System.out.println(Math.abs(-10.4)); //10.4 System.out.println(Math.abs(10.1)); //10.1 /** * ceil天花板的意思，就是返回大的值 */ System.out.println(Math.ceil(-10.1)); //-10.0 System.out.println(Math.ceil(10.7)); //11.0 System.out.println(Math.ceil(-0.7)); //-0.0 System.out.println(Math.ceil(0.0)); //0.0 System.out.println(Math.ceil(-0.0)); //-0.0 System.out.println(Math.ceil(-1.7)); //-1.0 /** * floor地板的意思，就是返回小的值 */ System.out.println(Math.floor(-10.1)); //-11.0 System.out.println(Math.floor(10.7)); //10.0 System.out.println(Math.floor(-0.7)); //-1.0 System.out.println(Math.floor(0.0)); //0.0 System.out.println(Math.floor(-0.0)); //-0.0 /** * random 取得一个大于或者等于0.0小于不等于1.0的随机数 */ System.out.println(Math.random()); //大于或者等于0小于1的double类型的数 System.out.println(Math.random()*2);//大于或者等于0小于2的double类型的数 System.out.println(Math.random()*2+1);//大于或者等于1小于3的double类型的数 /** * rint 四舍五入，返回double值 * 注意.5的时候会取偶数 异常的尴尬=。= */ System.out.println(Math.rint(10.1)); //10.0 System.out.println(Math.rint(10.7)); //11.0 System.out.println(Math.rint(11.5)); //12.0 System.out.println(Math.rint(10.5)); //10.0 System.out.println(Math.rint(10.51)); //11.0 System.out.println(Math.rint(-10.5)); //-10.0 System.out.println(Math.rint(-11.5)); //-12.0 System.out.println(Math.rint(-10.51)); //-11.0 System.out.println(Math.rint(-10.6)); //-11.0 System.out.println(Math.rint(-10.2)); //-10.0 /** * round 四舍五入，float时返回int值，double时返回long值 等价于Math.floor(num+0.5) */ System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.7)); //11 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.51)); //11 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.51)); //-11 System.out.println(Math.round(-10.6)); //-11 System.out.println(Math.round(-10.2)); //-10 &#125; &#125; floor 向下取整 round 四舍五入 - 返回整数Math.round(num)实际上是等价于Math.floor(num+0.5) ceil 取不小于num的最小整数 abs 求绝对值 random 随机数 pow 幂函数 sqrt 开根号 引用原文：https://www.cnblogs.com/whiteme/p/7234243.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"Object老祖宗类","date":"2021-04-26T04:15:07.506Z","path":"2021/04/26/Object老祖宗类/","text":"Object老祖宗类 Object 类属于 java.lang 包，此包下的所有类在使用时无需手动导入，系统会在程序编译期间自动导入。Object 类是所有类的基类，当一个类没有直接继承某个类时，默认继承Object类，也就是说任何类都直接或间接继承此类，Object 类中能访问的方法在所有类中都可以调用，下面我们会分别介绍Object 类中的所有方法。 1、Object类结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * */package java.lang;/** * Class &#123;@code Object&#125; is the root of the class hierarchy. * Every class has &#123;@code Object&#125; as a superclass. All objects, * including arrays, implement the methods of this class. * * @author unascribed * @see java.lang.Class * @since JDK1.0 */public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125; 类{@code Object}是类层次结构的根。 每个类都有{@code Object}作为超类。所有对象, *包括数组，实现该类的方法。 2、 为什么java.lang包下的类不需要手动导入？编译器会自动导入 java.lang 包，我们能直接使用了。至于原因，因为用的多，提前加载了，省资源。 3、类构造器类构造器是创建Java对象的途径之一，通过new 关键字调用构造器完成对象的实例化，还能通过构造器对对象进行相应的初始化。一个类必须要有一个构造器的存在，如果没有显示声明，那么系统会默认创造一个无参构造器，在JDK的Object类源码中，是看不到构造器的，系统会自动添加一个无参构造器。我们可以通过： Object obj = new Object()；构造一个Object类的对象。 4、equals 方法equals() 方法和 == 运算符的区别== 运算符：用于比较基本类型的值是否相同，或者比较两个对象的引用是否相等 而对于equals() 方法： 先看看object 类中的equals 方法： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 可以看到，在 Object 类中，== 运算符和 equals 方法是等价的，都是比较两个对象的引用是否相等，从另一方面来讲，如果两个对象的引用相等，那么这两个对象一定是相等的。对于我们自定义的一个对象，如果不重写 equals 方法，那么在比较对象的时候就是调用 Object 类的 equals 方法，也就是用 == 运算符比较两个对象。 对于重写equals() 方法的子类来说： 在Java规范中，对 equals 方法的使用(子类重写)必须遵循以下几个原则： ①、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 ②、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 ③、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 ④、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改 ⑤、对于任何非空引用值 x，x.equals(null) 都应返回 false。 举例String 类中的重写的 equals 方法： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; String 是引用类型，比较时不能比较引用是否相等，重点是字符串的内容是否相等。所以 String 类定义两个对象相等的标准是字符串内容都相同。 5、getClass 方法getClass()在 Object 类中如下，作用是返回对象的运行时类。 1public final native Class&lt;?&gt; getClass(); 这里我们要知道用 native 修饰的方法我们不用考虑，由操作系统帮我们实现，该方法的作用是返回一个对象的运行时类，通过这个类对象我们可以获取该运行时类的相关属性和方法。也就是Java中的反射，各种通用的框架都是利用反射来实现的，这里我们不做详细的描述。 介绍 getClass 方法返回的是一个对象的运行时类对象，这该怎么理解呢？Java中还有一种这样的用法，通过 类名.class 获取这个类的类对象 ，这两种用法有什么区别呢？ 父类：Parent.class 1public class Parent &#123;&#125; 子类：Son.class 1public class Son extend Parent&#123;&#125; 测试及结果： 12345678910@Testpublic void testClass()&#123; Parent p = new Son(); System.out.println(p.getClass()); System.out.println(Parent.class);&#125;//结果class com.wang.test.Sonclass com.wang.test.Parent class 是一个类的属性，能获取该类编译时的类对象，而 getClass() 是一个类的方法，它是获取该类运行时的类对象。 6、hashCode 方法hashCode 在 Object 类中定义如下：1public native int hashCode(); 这也是一个用 native 声明的本地方法，作用是返回对象的散列码，是 int 类型的数值。 那么这个方法存在的意义是什么呢? 我们知道在Java 中有几种集合类，比如 List,Set，还有 Map，List集合一般是存放的元素是有序可重复的，Set 存放的元素则是无序不可重复的，而 Map 集合存放的是键值对。 前面我们说过判断一个元素是否相等可以通过 equals 方法，没增加一个元素，那么我们就通过 equals 方法判断集合中的每一个元素是否重复，但是如果集合中有10000个元素了，但我们新加入一个元素时，那就需要进行10000次equals方法的调用，这显然效率很低。 于是，Java 的集合设计者就采用了 哈希表 来实现。关于哈希表的数据结构我有过介绍。哈希算法也称为散列算法，是将数据依特定算法产生的结果直接指定到一个地址上。这个结果就是由 hashCode 方法产生。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。 哈希表Hash表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。 注意，这里有个重要的问题就是如何把关键字转换为数组的下标，这个转换的函数称为哈希函数（也称散列函数），转换的过程称为哈希化。 哈希函数：把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。 产生冲突：一个方法是通过系统的方法找到数组的一个空位，并把这个单词填入，而不再用哈希函数得到数组的下标，这种方法称为开放地址法。另一种方法，前面我们也提到过，就是数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中，这种方法称为链地址法。 开放地址法 ①、线性探测：在线性探测中，它会线性的查找空白单元。数组下标依次递增，直到找到空白的位置。这就叫做线性探测 当哈希表变得太满时，会出现聚集。组填的越满，聚集越可能发生。 装填因子：已填入哈希表的数据项和表长的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 2/3。当装填因子不太大时，聚集分布的比较连贯，而装填因子比较大时，则聚集发生的很大了。 ②、二次探测：二测探测是防止聚集产生的一种方式，思想是探测相距较远的单元，而不是和原始位置相邻的单元。线性探测中，如果哈希函数计算的原始下标是x, 线性探测就是x+1, x+2, x+3, 以此类推；而在二次探测中，探测的过程是x+1, x+4, x+9, x+16，以此类推，到原始位置的距离是步数的平方。二次探测虽然消除了原始的聚集问题，但是产生了另一种更细的聚集问题，叫二次聚集 ③、再哈希法：为了消除原始聚集和二次聚集，我们使用另外一种方法：再哈希法。 第二个哈希函数必须具备如下特点：一、和第一个哈希函数不同。二、不能输出0（否则，将没有步长，每次探测都是原地踏步，算法将陷入死循环）。专家们已经发现下面形式的哈希函数工作的非常好：stepSize = constant - key % constant; 其中constant是质数，且小于数组容量。 链地址法：在哈希表每个单元中设置链表（即链地址法），某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这个位置的数据项只需要加到链表中，不需要在原始的数组中寻找空位。 桶：另外一种方法类似于链地址法，它是在每个数据项中使用子数组，而不是链表。这样的数组称为桶。这个方法显然不如链表有效，因为桶的容量不好选择，如果容量太小，可能会溢出，如果太大，又造成性能浪费，而链表是动态分配的，不存在此问题。所以一般不使用桶。 总结：哈希表基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。用来解决冲突的有两种方法：开放地址法和链地址法。在开发地址法中，把冲突的数据项放在数组的其它位置；在链地址法中，每个单元都包含一个链表，把所有映射到同一数组下标的数据项都插入到这个链表中。 ①、如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； ②、如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了； ③、不相同的话，也就是发生了Hash key相同导致冲突的情况，那么就在这个Hash key的地方产生一个链表，将所有产生相同HashCode的对象放到这个单链表上去，串在一起（很少出现）。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 可以得到如下推论： 两个对象相等，其 hashCode 一定相同; 两个对象不相等，其 hashCode 有可能相同; hashCode 相同的两个对象，不一定相等; hashCode 不相同的两个对象，一定不相等; 7、toString 方法123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; getClass().getName()是返回对象的全类名（包含包名）,Integer.toHexString(hashCode()) 是以16进制无符号整数形式返回此哈希码的字符串表示形式。 打印某个对象时，默认是调用 toString 方法，比如 System.out.println(person),等价于 System.out.println(person.toString()) 8、notify()/notifyAll()/wait()用于多线程之间的通信方法 9、finalize 方法1protected void finalize() throws Throwable &#123; &#125; 该方法用于垃圾回收，一般由 JVM 自动调用，一般不需要程序员去手动调用该方法。 引用原文：https://www.cnblogs.com/ysocean/p/8419559.html#_label5","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"File类","date":"2021-04-26T04:15:07.499Z","path":"2021/04/26/File类/","text":"File类1.1. File类说明存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失.为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习一个和文件有密切关系的类,叫做File类,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据。 那么File类关心的是在磁盘上文件的存储. File类描述的是一个文件或文件夹。（文件夹也可以称为目录） 该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹。 可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。 文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。 1.2. 体验File类123456public static void main(String[] args) &#123; File file = new File(&quot;D:\\\\blog&quot;); System.out.println(file.exists()); System.out.println(file.isFile()); System.out.println(file.isDirectory());&#125; 结论：File对象也可以表示不存在的文件。其实代表了一个抽象路径 构建一个File类的实例并不会在机器上创建一个文件。不管文件是否存在都可以创建任意文件名的File实例,可以调用File实例的exists方法判断文件或目录是否存在。 1.3. 构造一个File类实例：首先存在/d/blog/source 12345678910public static void main(String[] args) &#123; File file = new File(&quot;D:\\\\blog/source&quot;,&quot;images&quot;); System.out.println(file.exists()); System.out.println(file.isFile()); System.out.println(file.isDirectory()); System.out.println(file.getPath()); //完整的路径为parent.getPath()+child //说明： //如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false。&#125; 创建File对象需要导包, import java.io.File ==File对象没有无参数构造，创建对象需要传参。== 123456//标准public static void main(String[] args) &#123; String path = &quot;D:\\\\blog&quot;; File file = new File(path); System.out.println(file.exists());&#125; 1.4.路径路径就是文件或文件夹所在的位置。 1.4.1. 路径分割符上下级文件夹之间使用分隔符分开： 在Windows中分隔符为\\，在Unix/Linux中分隔符为/。 更专业的做法是使用File.separatorChar，这个值就会根据系统得到的相应的分割符。 例：new File(&quot;c:&quot; + File.separatorChar + &quot;a.txt&quot;); 注意，如果是使用”&quot;，则需要进行转义，写为”\\“才可以，如果是两个”&quot;，则写为”\\\\“。 123456public static void main(String[] args) &#123; String path1 = &quot;D:&quot;; String path2 = &quot;blog&quot;; File file = new File(path1+File.separator+path2); System.out.println(file.exists());&#125; 1.4.2. 绝对路径与相对路径对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。 对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\\…”。相对路径没有盘符前缀。 相对路径： 相对路径是指相对于某位置的路径，是指相对于当前目录。在执行Java程序时，相对路径为执行java命令时当前所在的目录。 一般在使用时，建议用绝对路径，因为相对路径容易出问题，不好确定到底在什么地方。 1.5. File类中常用的方法： 创建 1、createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建然后返回false 1234public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:\\\\a.txt&quot;); System.out.println(file.createNewFile());&#125; 2、mkdir()指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛异常。 1234public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:\\\\resource&quot;); System.out.println(file.mkdir());&#125; 3、mkdirs()在指定位置创建目录，这会创建路径中所有不存在的目录。 1234public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:\\\\resource\\\\hexo&quot;); System.out.println(file.mkdirs());&#125; 4、renameTo(File dest)使用说明 第一种场景：同一路径下文件重命名【文件重命名】 如果test路径下1.txt 不存在，那么返回false。 123File oldName = new File(&quot;E:\\\\hello\\\\test\\\\1.txt&quot;); File newName = new File(&quot;E:\\\\hello\\\\test\\\\2.txt&quot;); System.out.println(oldName.renameTo(newName));//true 第二种场景：将文件从一个路径移动另一个路径下，并且移动的文件进行重命名【文件移动重命名】 E:\\hello1\\test1必须要存在，否则返回false 。 123File oldName = new File(&quot;E:\\\\hello\\\\test\\\\1.txt&quot;); File newName = new File(&quot;E:\\\\hello1\\\\test1\\\\2.txt&quot;); System.out.println(oldName.renameTo(newName));//tue 第三种场景：修改文件夹的名称，文件夹里面没有文件的时候修改成功！ 说明：修改文件夹名称，这个目录必须存在 E:\\hello\\dufy。其中如果 E:\\hello\\dufy 这个目录不为空，返回false。 123File oldNamed = new File(&quot;E:\\\\hello\\\\dufy&quot;); File newNamed = new File(&quot;E:\\\\hello\\\\dufy_fly&quot;); System.out.println(oldNamed.renameTo(newNamed)); //true renameTo 可以重命名文件，也可以进行文件的移动操作！ 删除 123delete() 删除文件或一个空文件夹，如果是文件夹且不为空，则不能删除，成功返回true，失败返回false。deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录，保证程序异常时创建的临时文件也可以被删除 判断 123456789exists() 文件或文件夹是否存在。isFile() 是否是一个文件，如果不存在，则始终为false。isDirectory() 是否是一个目录，如果不存在，则始终为false。isHidden() 是否是一个隐藏的文件或是否是隐藏的目录。isAbsolute() 测试此抽象路径名是否为绝对路径名。 获取 1234567891011121314151617getName() 获取文件或文件夹的名称，不包含上级路径。getPath() 返回绝对路径，可以是相对路径，但是目录要指定getAbsolutePath() 获取文件的绝对路径，与文件是否存在没关系 执行的位置length() 获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。getParent() 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。lastModified() 获取最后一次被修改的时。&#x2F;&#x2F;返回是时间戳，可用calendar.setTimeInMillis接收文件夹相关：list() 返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。listFiles() 返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。 测试 list() 与 listFiles 的区别 1234567891011121314151617181920File file = new File(&quot;D:\\\\blog&quot;);for (String s : file.list()) &#123; System.out.println(s);&#125;//===============================.deploy_git.gitignore._config.yml.swm._config.yml.swn._config.yml.swo._config.yml.swpdb.jsonnode_modulespackage-lock.jsonpackage.jsonpublicscaffoldssourcethemes_config.yml 1234567891011121314151617181920File file = new File(&quot;D:\\\\blog&quot;);for (File listFile : file.listFiles()) &#123; System.out.println(listFile);&#125;//==============================D:\\blog\\.deploy_gitD:\\blog\\.gitignoreD:\\blog\\._config.yml.swmD:\\blog\\._config.yml.swnD:\\blog\\._config.yml.swoD:\\blog\\._config.yml.swpD:\\blog\\db.jsonD:\\blog\\node_modulesD:\\blog\\package-lock.jsonD:\\blog\\package.jsonD:\\blog\\publicD:\\blog\\scaffoldsD:\\blog\\sourceD:\\blog\\themesD:\\blog\\_config.yml 1.6. 案例：1、列出指定目录中所有的子文件名与所有的子目录名，要求目录名与文件名分开列出12345678910111213141516171819public static void main(String[] args)&#123; String path = &quot;D:\\\\blog&quot;; file1 file1 = new file(); file1.listAllFilesAndDirs(path);&#125;public void listAllFilesAndDirs(String path) &#123; File dir = new File(path); File[] names = dir.listFiles(); for (int i = 0; i &lt; names.length; i++) &#123; File file = names[i]; if (file.isFile()) &#123; System.out.print((&quot;子文件：&quot;)); System.out.println(&quot;\\t&quot; + file.getName()); &#125; else if (file.isDirectory()) &#123; System.out.print((&quot;子目录：&quot;)); System.out.println(&quot;\\t&quot; + file.getName()); &#125; &#125;&#125; 2、列出指定目录中所有扩展名为.java的文件。不同系统对于路径的 windows系统使用斜线作为路径分隔符 “&quot; linux 系统使用反斜线作为路径分隔符”/“java是跨平台的语言，java程序如果部署到linux系统上，如果程序中有File对象， 可以使用File类separatorChar (字段) 123456789101112131415public static void main(String[] args)&#123; String path = &quot;D:&quot; + File.separatorChar + &quot;blog&quot;; File file = new File(path); file1 file1 = new file1(); file1.listAllFiles(file,&quot;json&quot;);&#125;public void listAllFiles(File dir, String extension) &#123; File[] files = dir.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; File file = files[i]; if (file.getName().endsWith(extension)) &#123; System.out.println(file.getName()); &#125; &#125;&#125; 原文链接：https://blog.csdn.net/u010648555/article/details/78356040","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"String类","date":"2021-04-26T04:15:07.490Z","path":"2021/04/26/String类常用方法/","text":"String类1、String类初始化由于String对象特别常用，所以在对String对象进行初始化时，Java提供了一种简化的特殊语法，格式如下： String s = “abc”;s = “Java语言”; 2、字符串的常见操作charAt方法该方法的作用是按照索引值(规定字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推)，获得字符串中的指定字符。例如： 123String s = &quot;abc&quot;;char c = s.chatAt(1);//则变量c的值是&#x27;b&#x27; compareTo方法该方法的作用是比较两个字符串的大小，比较的原理是依次比较每个字符的字符编码。首先比较两个字符串的第一个字符，如果第一个字符串的字符编码大于第二个的字符串的字符编码，则返回大于0的值，如果小于则返回小于0的值，如果相等则比较后续的字符，如果两个字符串中的字符编码完全相同则返回0。 1234String s = &quot;abc&quot;;String s1 = &quot;abd&quot;;int value = s.compareTo(s1);//则value的值是小于0的值，即-1。 类似的方法compareToIgnoreCase()，这个方法是忽略字符的大小写进行比较，比较的规则和compareTo一样。 concat方法该方法的作用是进行字符串的连接，将两个字符串连接以后形成一个新的字符串。 1234567891011tring s = &quot;abc&quot;;String s1 = &quot;def&quot;;String s2 = s.concat(s1);//则连接以后生成的新字符串s2的值是”abcdef”，而字符串s和s1的值不发生改变。//============================================================//如果需要连接多个字符串，可以使用如下方法：String s = &quot;abc&quot;;String s1 = &quot;def&quot;;String s2 = &quot;1234&quot;;String s3 = s.concat(s1).concat(s2);//则生成的新字符串s3的值为”abcdef1234”。 在实际使用时，语法上提供了一种更简单的形式，就是使用“+”进行字符串的连接。例如 String s = &quot;abc&quot; + &quot;1234&quot;;使用要求： 使用“+”进行连接，不仅可以连接字符串，也可以连接其他类型。 但是要求进行连接时至少有一个参与连接的内容是字符串类型。 “+”匹配的顺序是从左向右，如果两边连接的内容都是基本数字类型则按照加法运算 例如： 12345678910int a = 10;String s = &quot;123&quot; + a + 5;//连接以后字符串s的值是&quot;123105&quot;int a = 10;String s = a + 5 + &quot;123&quot;;//连接以后字符串s的值是&quot;15123&quot;//而下面的连接代码是错误的：int a = 12;String s = a + 5 + &#x27;s&#x27;;//参与连接的没有一个字符串，则计算出来的结果是数字值，在赋值时无法将一个数字值赋值给字符串s。 endsWith，startWith方法该方法的作用是判断字符串是否以某个字符串结尾(开始)，如果以对应的字符串结尾(开始)，则返回true。 1234String s = “student.doc”;boolean b = s.endsWith(“doc”);boolean c = s.startWith(“student”);//则变量b,c的值是true。 equals方法该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回true，否则返回false。之前一篇关于 Object() 类的有关 equals() 方法及子类的重写就用到了 String类的equals()方法的源码。 123String s = &quot;abc&quot;;String s1 = new String(&quot;abc&quot;);boolean b = s.equals(s1); 类似的方法equalsIgnoreCase，该方法的作用是忽略大小写比较两个字符串的内容是否相同。 getBytes方法该方法的作用是将字符串转换为对应的byte数组，从而便于数据的存储和传输。 123String s = “计算机”;byte[] b = s.getBytes(); //使用本机默认的字符串转换为byte数组byte[] b = s.getBytes(“gb2312”); //使用gb2312字符集转换为byte数组 indexOf方法该方法的作用是查找特定字符或字符串在当前字符串中的起始位置，如果不存在则返回-1，也可以从特定位置以后查找对应的字符。l类似的有lastIndexOf例如： 123456String s = &quot;abcded&quot;;int index1 = s.indexOf(&#x27;d&#x27;);int index2 = s.indexOf(&#x27;h&#x27;);//index1为3。index2为-1int index3 = s.indexOf(‘d’,4);//则查找字符串s中从索引值4(包括4)以后的字符中第一个出现的字符d，index3为5。 length方法略 replace方法该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。 12345String s = &quot;abcat&quot;;String s1 = s.replace(&#x27;a&#x27;,&#x27;1&#x27;);//新字符串s1的值是&quot;1bc1t&quot;String ss = &quot;abatbac&quot;;String s2 = s.replaceAll(&quot;ba&quot;,&quot;12&quot;);//新字符串s2的值是&quot;a12t12c&quot;String s1 = s. replaceFirst (&quot;ba&quot;,&quot;12&quot;);//新字符串s2的值是&quot;a12tbac&quot; split方法该方法的作用是以特定的字符串作为间隔，拆分当前字符串的内容，一般拆分以后会获得一个字符串数组。 12345String s = &quot;abbcbtbb&quot;;String s1[] = s.split(&quot;b&quot;);//s1的内容为：&#123;&quot;a&quot;,&quot;&quot;,&quot;c&quot;,&quot;t&quot;&#125;//中间的空字符串的数量等于中间间隔字符串的数量减一个。//最后的空字符串不论有多少个，都会被忽略。 substring方法该方法的作用是取字符串中的“子串”，所谓“子串”即字符串中的一部分。例如“23”是字符串“123”的子串。 123String s = &quot;TestString&quot;;String s1 = s.substring(2);//s1的值是&quot;stString&quot;。String s2 = s.substring(2,5);//s2的值是&quot;stS&quot; toCharArray方法该方法的作用和getBytes方法类似，即将字符串转换为对应的char数组。 123String s = &quot;abc&quot;;char[] c = s.toCharArray();//则字符数组c的值为：&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;。 toLowerCase方法该方法的作用是将字符串中所有大写字符都转换为小写。类似的方法是toUpperCase 12345String s = &quot;AbC123&quot;;String s1 = s.toLowerCase();//则字符串s1的值是&quot;abc123&quot;，而字符串s的值不变。String s2 = s.toUpperCase ();//则字符串s2的值是&quot;ABC123&quot;，而字符串s的值也不变。 trim方法该方法的作用是去掉字符串开始和结尾的所有空格，然后形成一个新的字符串。该方法不去掉字符串中间的空格。 123String s = &quot; abc abc 123 &quot;;String s1 = s.trim();//则字符串s1的值为：&quot; abc abc 123&quot;。字符串s的值不变。 valueOf方法该方法的作用是将其它类型的数据转换为字符串类型。方法是static方法，所以不用创建String类型的对象即可。 123int n = 10;String s = String.valueOf(n);//则字符串s的值是”10”。 引用原文：https://www.cnblogs.com/springcsc/archive/2009/12/03/1616326.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"StringBuilder、StringBufer常用方法","date":"2021-04-26T04:15:07.457Z","path":"2021/04/26/StringBuilder与StringBufer区别于联系/","text":"StringBuilder、StringBufer常用方法区别与联系StringBuilder 是一个可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。 StringBuffer 是一个线程安全的可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。 StringBuilder和StringBuffer不同，前者是非线程安全的，后者是线程安全的。 相比String有一个reverse()方法 这两个的方法基本相同，只是一个有synchronized的安全，一个没有；AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。下面介绍一个这些常见的公共方法，以StringBuilder为例： insert123456789101112131415161718192021222324252627282930313233343536StringBuilder sbuilder = new StringBuilder();// 在位置0处插入字符数组sbuilder.insert(0, new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;);// 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度sbuilder.insert(0, new char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;, 0, 3);// 在位置0处插入floatsbuilder.insert(0, 1.414f);// 在位置0处插入doublesbuilder.insert(0, 3.14159d);// 在位置0处插入booleansbuilder.insert(0, true);// 在位置0处插入charsbuilder.insert(0, &#x27;\\n&#x27;);// 在位置0处插入intsbuilder.insert(0, 100);// 在位置0处插入longsbuilder.insert(0, 12345L);// 在位置0处插入StringBuilder对象sbuilder.insert(0, new StringBuilder(&quot;StringBuilder&quot;));// 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括)sbuilder.insert(0, new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13);// 在位置0处插入StringBuffer对象。sbuilder.insert(0, new StringBuffer(&quot;StringBuffer&quot;));// 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括)sbuilder.insert(0, new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12);// 在位置0处插入String对象。sbuilder.insert(0, &quot;String&quot;);// 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括)sbuilder.insert(0, &quot;0123456789&quot;, 1, 6);sbuilder.insert(0, &#x27;\\n&#x27;);// 在位置0处插入Object对象。此处以HashMap为例HashMap map = new HashMap();map.put(&quot;1&quot;, &quot;one&quot;);map.put(&quot;2&quot;, &quot;two&quot;);map.put(&quot;3&quot;, &quot;three&quot;);sbuilder.insert(0, map); append12345678910111213141516171819202122232425262728293031323334353637383940414243StringBuilder sbuilder = new StringBuilder();// 追加字符数组sbuilder.append(new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;);// 追加字符数组。0表示字符数组起始位置，3表示长度sbuilder.append(new char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;, 0, 3);// 追加floatsbuilder.append(1.414f);// 追加doublesbuilder.append(3.14159d);// 追加booleansbuilder.append(true);// 追加charsbuilder.append(&#x27;\\n&#x27;);// 追加intsbuilder.append(100);// 追加longsbuilder.append(12345L);// 追加StringBuilder对象sbuilder.append(new StringBuilder(&quot;StringBuilder&quot;));// 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括)sbuilder.append(new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13);// 追加StringBuffer对象。sbuilder.append(new StringBuffer(&quot;StringBuffer&quot;));// 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括)sbuilder.append(new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12);// 追加String对象。sbuilder.append(&quot;String&quot;);// 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括)sbuilder.append(&quot;0123456789&quot;, 1, 6);sbuilder.append(&#x27;\\n&#x27;);// 追加Object对象。此处以HashMap为例HashMap map = new HashMap();map.put(&quot;1&quot;, &quot;one&quot;);map.put(&quot;2&quot;, &quot;two&quot;);map.put(&quot;3&quot;, &quot;three&quot;);sbuilder.append(map);sbuilder.append(&#x27;\\n&#x27;);// 追加unicode编码sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码 replace12345678910111213StringBuilder sbuilder;sbuilder = new StringBuilder(&quot;0123456789&quot;);sbuilder.replace(0, 3, &quot;ABCDE&quot;);System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder);sbuilder = new StringBuilder(&quot;0123456789&quot;);sbuilder.reverse();System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder);sbuilder = new StringBuilder(&quot;0123456789&quot;);sbuilder.setCharAt(0, &#x27;M&#x27;);System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); delete12345678910111213StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;);// 删除位置0的字符，剩余字符是“123456789”。sbuilder.deleteCharAt(0);// 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。sbuilder.delete(3,6);// 获取sb中从位置1开始的字符串String str1 = sbuilder.substring(1);// 获取sb中从位置3(包括)到位置5(不包括)之间的字符串String str2 = sbuilder.substring(3, 5);// 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为StringString str3 = (String)sbuilder.subSequence(3, 5); index1234567891011121314StringBuilder sbuilder = new StringBuilder(&quot;abcAbcABCabCaBcAbCaBCabc&quot;);System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder);// 1. 从前往后，找出&quot;bc&quot;第一次出现的位置System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.indexOf(&quot;bc&quot;));// 2. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;, 5)&quot;, sbuilder.indexOf(&quot;bc&quot;, 5));// 3. 从后往前，找出&quot;bc&quot;第一次出现的位置System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;));// 4. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;, 4)); 剩下的API12345678910StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;);int cap = sbuilder.capacity();System.out.printf(&quot;cap=%d\\n&quot;, cap);char c = sbuilder.charAt(6);System.out.printf(&quot;c=%c\\n&quot;, c);char[] carr = new char[4];sbuilder.getChars(3, 7, carr, 0); 总结：和String类相比，有一个reverse()方法，有一个追加字符串，还有一个对追加长度的计算，capacity相当与String中的类。 insert和append，理论上来说，一个是在前面添上元素，一个是在后面添上元素。作用感觉只要一个就好了。 StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。 抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。 最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 如果想了解更多关于capacity容器的增加，可以看看另一篇关于它的文章。 参考文章： https://www.cnblogs.com/xudong-bupt/p/3961159.html https://www.cnblogs.com/skywang12345/p/string03.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"pat1016","date":"2021-04-18T11:56:05.066Z","path":"2021/04/18/pat1016/","text":"1016. 部分A+B (15) [模拟]正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。 现给定A、DA、B、DB，请编写程序计算PA + PB。 输⼊格式： 输⼊在⼀⾏中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 10^10。 输出格式： 在⼀⾏中输出PA + PB的值。 输⼊样例1： 13862767 6 13530293 3 输出样例1： 1399 输⼊样例2： 13862767 1 13530293 8 输出样例2： 10 分析：将A和B保存在string a 和 b中，将DA和DB保存在da和db中，因为A为字符串，所以对于它的每⼀ 位a[i]，当da == (a[i]- ‘0’)时候表示da和a[i]相等，将相等的次数保存在cnta中，当cnta不为0时，说明A中 有位数等于da，先令pa = da，然后根据cnta的次数，将cnta个da转化为pa的值（转化⽅法为for循环从 1到cnta-1，每次pa乘以10再加上da），B同理，相等的次数保存在cntb中，求出pb的值，最后输出 pa+pb的值～ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; string a, b; int da, db, cnta = 0, cntb = 0, pa = 0, pb = 0; cin &gt;&gt; a &gt;&gt; da &gt;&gt; b &gt;&gt; db; for (int i = 0; i &lt; a.length(); i++) if (da == (a[i] - &#x27;0&#x27;)) cnta++; for (int i = 0; i &lt; b.length(); i++) if (db == (b[i] - &#x27;0&#x27;)) cntb++; if (cnta != 0) pa = da; if (cntb != 0) pb = db; for (int i = 1; i &lt; cnta; i++) pa = 10 * pa + da; for (int i = 1; i &lt; cntb; i++) pb = 10 * pb + db; cout &lt;&lt; pa + pb; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#x32;&#x33;&#x30;&#52;&#x37;&#x30;&#51;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1014","date":"2021-04-18T11:51:09.180Z","path":"2021/04/18/pat1014/","text":"1014. 福尔摩斯的约会 (20) [字符串处理]⼤侦探福尔摩斯接到⼀张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。 ⼤侦探很快就明⽩了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”， 因为前⾯两字符串中第1对相同的⼤写英⽂字⺟（⼤⼩写有区分）是第4个字⺟’D’， 代表星期四；第2对相同的字符是’E’，那是第5个英⽂字⺟，代表⼀天⾥的第14个钟头（于是⼀天的0点到23点由数字0到9、以及⼤写字⺟A到N表示）；后⾯两字符串 第1对相同的英⽂字⺟’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定 两对字符串，请帮助福尔摩斯解码得到约会的时间。 输⼊格式： 输⼊在4⾏中分别给出4个⾮空、不包含空格、且⻓度不超过60的字符串 输出格式： 在⼀⾏中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写, 即MON表示星期⼀，TUE表示星期⼆，WED表示星期三，THU表示星期四，FRI表示星期五， SAT表示星期六，SUN表示星期⽇。题⽬输⼊保证每个测试存在唯⼀解。 输⼊样例： 12343485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 输出样例： 1THU 14:04 分析：按照题⽬所给的⽅法找到相等的字符后判断即可，如果输出的时间不⾜2位数要在前⾯添0，即 ⽤%02d输出～ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; char t[2]; int pos, i = 0, j = 0; while(i &lt; a.length() &amp;&amp; i &lt; b.length()) &#123; if (a[i] == b[i] &amp;&amp; (a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;G&#x27;)) &#123; t[0] = a[i]; break; &#125; i++; &#125; i = i + 1; while (i &lt; a.length() &amp;&amp; i &lt; b.length()) &#123; if (a[i] == b[i] &amp;&amp; ((a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;N&#x27;) || isdigit(a[i]))) &#123; t[1] = a[i]; break; &#125; i++; &#125; while (j &lt; c.length() &amp;&amp; j &lt; d.length()) &#123; if (c[j] == d[j] &amp;&amp; isalpha(c[j])) &#123; pos = j; break; &#125; j++; &#125; string week[7] = &#123;&quot;MON &quot;, &quot;TUE &quot;, &quot;WED &quot;, &quot;THU &quot;, &quot;FRI &quot;, &quot;SAT &quot;, &quot;SUN &quot;&#125;; int m = isdigit(t[1]) ? t[1] - &#x27;0&#x27; : t[1] - &#x27;A&#x27; + 10; cout &lt;&lt; week[t[0]-&#x27;A&#x27;]; printf(&quot;%02d:%02d&quot;, m, pos); return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#x30;&#50;&#x33;&#x30;&#x34;&#x37;&#48;&#51;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java异常机制","date":"2021-04-18T11:51:09.159Z","path":"2021/04/18/异常/","text":"异常机制1、什么是异常实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或硬盘可能满了，等等 软件程序在运行过程中，非常可能遇到刚刚提到的浙西异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。 异常指程序运行中出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。 简单分类要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： 异常处理框架 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法遇见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常：运行时异常是可能被程序员避免的异常。与检查行异常相反，运行时异常可以在编译时被忽略。 错误ERROE：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 2、异常体系结构Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。 在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception ErrorError 类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。 Java 虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止； 还有发生在虚拟机执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。 Exception在Exception分支中有一个重要的子类RuntimeException（运行时异常） ArrayIndexOutOfBoundsException（数组下标越界） NullPointerException（空指针异常） ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。 这些异常一般是有程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生； Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。 3、Java异常处理机制抛出异常 捕获异常 123456789int a = 1;int b = 0;try&#123; a/b;&#125;catch&#123; sout(&quot;异常&quot;);&#125;finally&#123; //善后处理 souu(&quot;finally&quot;)&#125; 异常处理五个关键字 try、catch、finally、throw、throws 4、自定义异常使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。 在程序中使用自定义异常类，大体可分为以下几个步骤： 创建自定义异常类。 在方法中通过throw关键字抛出异常对象。 如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。 在出现异常方法的调用者中捕获并处理异常。 5、总结处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理 在多重catch块后面，可以加一个catch（Exception）来处理可能被遗漏的异常 对于不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切记只是简单地调用printStackTrace()去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"面向对象","date":"2021-04-18T11:51:09.157Z","path":"2021/04/18/面向对象/","text":"面向对象编程Java的核心思想就是OOP 1、初识面向对象面象过程&amp;面向对象面向过程思想 步骤清晰简单，第一步做什么，第二步做什么… 面向过程适合处理一些较为简单的问题 面向对象思想 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对莫格分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！ ==对于描述复杂的事务，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。== 什么是面向对象面向对象编程（Object-Oriented Programming，OOP） 面向对象编程的本质就是：==以类的方式组织代码，以对象的组织（封装）数据。== 抽象 三大特性： ==特性== ==继承== ==多态== 从认识论角度考虑是先有对象后有类。对象，是具体的事务。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 2、方法回顾和加深方法的定义 修饰符 返回类型 ==break：跳出switch，结束循环 和 return 的区别== 方法名：注意规范就OK 见面之意 参数列表：（参数类型，参数名）… 异常抛出：后面讲解 方法的调用：递归 静态方法 非静态方法 形参和实参 值传递和引用传递 this 关键字 3、对象的创建分析类与对象的关系类是一种抽象的数据类型，它是对某一类事务整体描述/定义，但是并不能代表某一个具体的事物。 动物、植物、手机、电脑… Person类，Pet类，Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为。 对象是抽象概念的具体实例 张三就是人的一个具体实例张三家里的旺财就是狗的一个具体实例。 能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。 创建和初始化对象使用new关键字创建的时候，出了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用， 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点： 必须和类的名字相同 必须没有返回类型，也不能写void ==构造器必须要掌握== 4、面向对象三大特性封装该露的露，该藏的藏 我们程序设计要追求==”高内聚，低耦合”==。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露扫两点方法给外部使用。 封装（数据的隐藏） 通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。 记住：==属性私有，get/set== 继承继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。 ==extands== 的意思是“扩展”。子类是父类的扩展。 Java中类只有单继承，没有多继承！ 继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。 继承关系的两个类，一个为子类(派生类)，一个为父类(基类)。子类继承父类，使用关键字extends来表示。 object类 super 方法重写：重写—&gt;多态 多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式。 一个对象的实际类型是却ing的，但可以指向对象的引用的类型有很多（父类，有关系的类） 多态存在的条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意：多态是方法的多态，属性没有多态性。 instanceof （类型转换） 引用类型 5、抽象类和接口抽象类==abstract==修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。 抽象类，不能使用new关键字来创建对象，他是用来让子类继承的。 抽象方法，只有方法的生，没有方法的实现，它是用来让子类实现的。 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。 接口 普通类：只有具体实现 抽象类：具体实现和规范(抽象方法)都有！ 接口：只有规范！自己无法写方法~专业的约束！ 接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…“的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，就能被欺负；如果你是坏人，则必须欺负好人。 接口的本质是契约，就像我们人间的法律一样。定制好后大家都遵守。 OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（如C++，java，c#），就是因为设计模式所研究的，实际上就是如何合理的去抽象。 6、内部类及OOP实战内部类内布类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。 成员内部类 静态内部类 局部内部类 匿名内部类","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java数组","date":"2021-04-18T11:51:09.128Z","path":"2021/04/18/Java数组/","text":"数组1、数组概述数组是相同类型数据的有序集合。 数组描述的是下沟通类型的若干个数据，按照一定的先后次序排列组合而成。 其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。 2、数组声明创建首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法： 12345datatType[] arrayRefVar; //首选的方法或dataType arrayRefVar[]; //效果校内通，但不是首选方法//上面一种是java方式的首选使用，下面一种是C/C++语言风格的，完全是为了早些年C/C++程序员能够快速掌握Java(为了挖人) Java语言使用new操作符来创建数组，语法如下： 1dataType[] arrayRefVar = new dataType[arraySize]; 数组的元素是通过索引访问的，数组索引从0开始。 获取数组长度 3、数组使用内存分析 堆： 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象 栈： 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址） 方法区： 可以被所有的线程共享 包含了所有的class和static变量 三种初始化 静态初始化 12int[] a = &#123;1,2,3&#125;;Man[] mans = new Man(1,1),new Man(2,2); 动态初始化 123int[] a = new iny[2];a[0]=1;a[1]=2; 数组的默认初始值 数组是引用变量，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 数组的四个基本特点其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型，不允许出现混合类型。 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。 数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，==数组对象本身是在堆中的。== 数组边界下标的合法区间：[0,length-1]，如果越界就会报错； 1234public static void main(String[] args)&#123; int[] a = new int[2]; sout(a[2]);&#125; ArrayIndexOutOfBoundsException：数组下标越界异常！ 小结： 数组是相同数据类型（数据类型可以为任意类型）的有序集合 数组也是对象。数组元素相当于对象的成员变量 数组长度是确定的，不可变的。如果越界，则报：ArreyIndexOutOfBounds 数组的使用普通的For循环 For-Each循环 数组作方法入参 数组作返回值 4、多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。 二维数组 1int a[][] = new int[2][5];//看成一个二行五列的数组 5、Arrays 类数组的工具类java.util.Arrays由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。 ==查看JDK帮助文档== Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意：是不用而不是不能） 具有以下常用功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法，按升序。 比较数组：通过 aquals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找放操作。 冒泡排序 冒泡排序无疑是最为出名的排序算法之一，总共有八大排序！ 冒泡的代码还是相当简单的，两层循环，外层冒泡论述，里层依次比较，江湖中人人尽皆知。 我们看到嵌套循环，应该立马就可以得出这个算法的==时间复杂度为O(n2)== 如果想看更多有关排序的可以看看我写的一篇专门有关排序的。 6、稀疏数组需求：编写五子棋游戏中，有存盘退出和续上盘的功能。 分析问题：因为该二维数组的很多值的默认值0，因此记录了很多没有意义的数据。 解决：稀疏数组 稀疏数组介绍当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java方法","date":"2021-04-18T11:51:09.127Z","path":"2021/04/18/Java方法/","text":"Java方法1、何谓方法 System.out.println()，那么它是什么呢？ Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他对方被引用 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。 2、方法的定义及调用方法的定义Java的方法类似于其他语言的函数，是一段==用来完成特定功能的代码片段==，一般情况下，定义一个方法包含以下语法： ==方法包含一个方法头和一个方法体==。下面是一个方法的所有部分 修饰符：这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，没有返回值。在这种情况下，returnValueType是关键字void 方法名：是方法的实际名称、方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 形式参数：在方法被调用时用于接受外界输入的数据。 实参：调用方法是实际传给方法的数据。 方法体：方法体包含具体的语句，定义该方法的功能。 方法调用调用方法：对象名.方法名(实参列表) Java支持两种调用方法的方式，根据方法是否返回值来选择。 当方法返回一个值的时候，方法调用通常被当做一个值。例如： 1int larger = max(30,40); 如果方法返回值是 void，方法调用一定是一条语句。 1System.out.println(&quot;Hello,zhangsan&quot;); 了解值传递(Java)和引用传递 3、方法重载重载就是在一个类中，有相同的函数名称，但形参不同的函数。 方法的重载的规则： 方法名称必须相同 参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等) 方法的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为方法的重载。 实验理论： 方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。 4、命令行传参有时候你希望运行一个程序的时候再传递给它消息。这要靠传递命令行参数给main()函数实现。 12345public class CommmandLine &#123; public static void main(String[] agrs)&#123; System.out.println(&quot;args[&quot; + i + &quot;]:&quot; + args[i] ); &#125;&#125; 命令行执行 12345javac Demo.javajava com.wang.method.Demo this is zhangsanargs[0]:thisargs[1]:isargs[2]:zhangsan 5、可变参数JDK1.5开始，Java支持传递同类型的可变参数给一个方法。 在方法声明中，在指定参数类型后加一个省略号(…)。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它声明之前。 12345678910111213141516171819202122public class Demo&#123; public static void main(String args[])&#123; //调用可变参数的方法 printMax(22,3,4,421,1); printMax(new double[]&#123;1,2,3&#125;); &#125; public static void printMax(double... numbers)&#123; if(numbers.length == 0)&#123; System.out.pringln(&quot;No argument passed&quot;); &#125; double result = number[0]; //排序 for(int i = 1; i &lt; number.length; i++)&#123; if(numbers[i] &gt; result)&#123; result = numbers; &#125; &#125; System.out.println(&quot;The max value is &quot; + result); &#125;&#125; 6、递归A 方法调用 B 方法，我们很容易理解！ 递归就是：A 方法调用 A 方法！就是自己调用自己 利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。 递归结构包括两个部分： 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。 递归体：什么时候需要调用自身方法。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"pat1015","date":"2021-04-18T11:51:09.125Z","path":"2021/04/18/pat1015/","text":"1015. 德才论 (25) [排序]题⽬描述： 宋代史学家司⻢光在《资治通鉴》中有⼀段著名的“德才论”：“是故才德全尽谓之圣⼈，才德兼亡谓之愚⼈，德胜才谓之君⼦，才胜德谓之⼩⼈。凡取⼈之术，苟不得圣⼈，君⼦⽽与之，与其得⼩⼈，不 若得愚⼈。” 现给出⼀批考⽣的德才分数，请根据司⻢光的理论给出录取排名。 输⼊格式： 输⼊第1⾏给出3个正整数，分别为：N（&lt;=105），即考⽣总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考⽣才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低 于此线的被定义为“才德全尽”，此类考⽣按德才总分从⾼到低排序；才分不到但德分到线的⼀类考⽣ 属于“德胜才”，也按总分排序，但排在第⼀类考⽣之后；德才分均低于H，但是德分不低于才分的考⽣ 属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第⼆类考⽣之后；其他达到最低线L的考⽣也按总分排序，但排在第三类考⽣之后。 随后N⾏，每⾏给出⼀位考⽣的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才 分为区间[0, 100]内的整数。数字间以空格分隔。 输出格式： 输出第1⾏⾸先给出达到最低分数线的考⽣⼈数M，随后M⾏，每⾏按照输⼊格式输出⼀位考⽣的信 息，考⽣按输⼊中说明的规则从⾼到低排序。当某类考⽣中有多⼈总分相同时，按其德分降序排列； 若德分也并列，则按准考证号的升序输出。 输⼊样例： 12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例： 123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 分析：⽤结构体存储。写好cmp函数~结构体数组vector v[4]中v[0]保存第⼀类考⽣，v[1]保存第⼆类考⽣……以此类推。写好cmp函数很重要，cmp函数中，排序先按照总分排序，然后按照德分排序，最后按照才分排序……最后输出符合条件的结果～ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int num, de, cai;&#125;;int cmp(struct node a, struct node b) &#123; if ((a.de + a.cai) != (b.de + b.cai)) return (a.de + a.cai) &gt; (b.de + b.cai); else if (a.de != b.de) return a.de &gt; b.de; else return a.num &lt; b.num;&#125;int main() &#123; int n, low, high; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;low, &amp;high); vector&lt;node&gt; v[4]; node temp; int total = n; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;temp.num, &amp;temp.de, &amp;temp.cai); if (temp.de &lt; low || temp.cai &lt; low) total--; else if (temp.de &gt;= high &amp;&amp; temp.cai &gt;= high) v[0].push_back(temp); else if (temp.de &gt;= high &amp;&amp; temp.cai &lt; high) v[1].push_back(temp); else if (temp.de &lt; high &amp;&amp; temp.cai &lt; high &amp;&amp; temp.de &gt;= temp.cai) v[2].push_back(temp); else v[3].push_back(temp); &#125; printf(&quot;%d\\n&quot;, total); for (int i = 0; i &lt; 4; i++) &#123; sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j &lt; v[i].size(); j++) printf(&quot;%d %d %d\\n&quot;, v[i][j].num, v[i][j].de, v[i][j].cai); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#51;&#48;&#x34;&#55;&#48;&#51;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"反编译","date":"2021-04-13T15:03:20.848Z","path":"2021/04/13/反编译/","text":"反编译一、什么是编译1、利用编译程序从源语言编写的源程序产生目标程序的过程。 2、用编译程序产生目标程序的动作。 编译就是把高级语言变成计算机可以识别的2进制语言，计算机只认识1和0，编译程序把人们熟悉的语言换成2进制的。 编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析;语法分析;语义检查和中间代码生成;代码优化;目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。 二、什么是反编译计算机软件反向工程(Reverse engineering)也称为计算机软件还原工程，是指通过对他人软件的目标程序(可执行程序)进行“逆向分析、研究”工作，以推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素，某些特定情况下可能推导出源代码。反编译作为自己开发软件时的参考，或者直接用于自己的软件产品中。 三、 Java类的编译与反编译我们在最初学习Java的时候，会接触到两个命令：javac和java,那个时候我们就知道，javac是用来编译Java类的，就是将我们写好的helloworld.java文件编译成helloworld.class文件。 class文件打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。 那么反编译呢，就是通过helloworld.class文件得到java文件(或者说是程序员能看懂的Java文件) 四、什么时候会用到反编译 我们只有一个类的class文件，但是我们又看不懂Java的class文件，那么我们可以把它反编译成我们可以看得懂的文件。 学习Java过程中，JDK的每个版本都会加入越来越多的语法糖，有些时候我们想知道Java一些实现细节，我们可以借助反编译。 五、介绍Java的反编译工具 javapjavap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。javap和其他两个反编译工具最大的区别是他生成的文件并不是java文件，也不像其他两个工具生成代码那样更容易理解。拿一段简单的代码举例，如我们想分析Java 中的switch是如何支持String的，我们先有以下可以编译通过的源代码放入 idea 中查看 javap并没有将字节码反编译成java文件，而是生成了一种我们可以看得懂字节码。其实javap生成的文件仍然是字节码，只是程序员可以稍微看得懂一些。如果你对字节码有所掌握，还是可以看得懂以上的代码的。其实就是把String转成hashcode，然后进行比较。 六、如何防止反编译由于我们有工具可以对Class文件进行反编译，所以，对开发人员来说，如何保护Java程序就变成了一个非常重要的挑战。但是，魔高一尺、道高一丈。当然有对应的技术可以应对反编译咯。但是，这里还是要说明一点，和网络安全的防护一样，无论做出多少努力，其实都只是提高攻击者的成本而已。无法彻底防治。 典型的应对策略有以下几种： 隔离Java程序让用户接触不到你的Class文件 对Class文件进行加密提高破解难度 代码混淆将代码转换成功能上等价，但是难于阅读和理解的形式 相关链接：http://java.tedu.cn/ask/203119.html、https://www.cnblogs.com/z00377750/p/9480207.html","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"反编译","slug":"反编译","permalink":"http://example.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}]},{"title":"Java流程控制","date":"2021-04-12T13:41:52.163Z","path":"2021/04/12/Java流程控制/","text":"Java流程控制1、用户交互ScannerScanner对象之前我们学的基本语法中我们并没有实现程序和人的交互，但是Java给我们提供了这样一个工具类，我们可以获取用户的输入。java.util.Scanner是Java 5 的新特性，==我们可以通过Scanner类来获取用户的输入==。 基本语法： 1Scanner sc = new Scanner(Syetem.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()与·hasNextLine()判断是否还有输入的数据。 next()： 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 ==next() 不能得到带有空格的字符串。== nextLine()： 以 Enter 为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符。 可以获得空白。 1234567891011121314151617181920//hasnextInt()用来查看下一个输出是不是Int类型，其余如此//nextInt() 将输入的值提取出来//我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，//通过输入非数字来结束输入并输出执行结果Scanner scanner = new Scanner(System.in);double sum = 0.0; //和int m = 0; //计算输入了多少个数字while (scanner.hasNextDouble())&#123; double x = scanner.nextDouble(); m = m +1; sum = sum+x; System.out.println(&quot;你输入了第&quot;+m+&quot;个数据，然后当前结果sum=&quot;+sum);&#125;System.out.println(m+&quot;个数的和为&quot;+sum);System.out.println(m+&quot;个数的平均值是&quot;+(sum/m));scanner.close(); 2、顺序结构Java的基础结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。 顺序结构是最简单的算法结构。 语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，==它是任何一个算法都离不开的一种基本算法结构==。 3、选择结构if 单选择结构 我们很多时候需要去判断一个东西是否可行，然后我们采取才去执行，这样一个过程在程序中用 if 语句来表示 if 双选择结构 需求用一个 if 就搞不定了，我们需要有两个判断，需要一个双选择结构，所以就有了 if-else 结构。 if 多选择结构 在生活中很多时候也不仅仅只有两个，所以我们需要一个多选择结构来处理这类问题！ 嵌套的 if 结构 使用嵌套的 if…else 语句是合法的。 switch 多选择结构 多选择结构还有一个实现方式就是switch case 语句。 switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 switch 语句中的变量类型可以是： byte、short、int 或者 char ==从 Java SE7 开始，switch 支持字符串 String 类型了== 同时 case 标签必须为字符串常量或字面量。 4、循环结构while循环while 是最基本的循环,它的结构为: 123while(布尔表达式)&#123; //循环内容&#125; 只要布尔表达式为 true，循环就会一致执行下去。 我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。 少部分情况需要循环一直执行，比如服务器的请求响应监听等。 循环条件一直为 true 就会造成无线循环，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死崩溃！ do…whileu循环对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 区别是它先执行后判断 for循环虽然所有循环结构都可以用 while 或者 do…while表示，但Java提供了另一种语句——for循环，使一些循环结构变得更加简单。 for 循环语句是支持迭代的一种通用结构，==是最有效、最灵活的循环结构。== for 循环执行的次数是在执行前就确定的。语法格式如下： 123for(初始值；布尔表达式；更新)&#123; //代码语句&#125; 在Java5中引入了一种主要用于数组的增强型for循环Java5 引入了一种主要用于数组和集合的增强型 for 循环。 Java 增强 for 循环语法格式如下： 123for(声明语句：表达式)&#123; //代码句子&#125; 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 5、break &amp; continuebreak 在任何循环语句的主体部分，均可用break控制循环的流程。==break 用于强行退出循环==，不执行循环中剩余的语句。(也用在switch语句中) continue 语句用在循环语句体中，==用于终止某次循环过程==，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 关于goto关键字goto 关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子···带标签的break和continue。 “标签”是指后面跟一个冒号的标识符，例如：label: 对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只终端当前循环，但若随标签使用，它们就会中断到存在标签的地方。 练习打印三角形123456789101112131415public static void main(String[] args)&#123; //打印三角形，5行 for(int i = 1; i &lt;= 5; i++)&#123; for(int j = 5; j &gt;= i; j++)&#123; System.out.print(&quot; &quot;); &#125; for(int j = 1; j &lt;= i; j++)&#123; System.out.print(&quot;*&quot;); &#125; for(int j = 1; j &lt; i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125;&#125;","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础","date":"2021-04-10T03:14:54.730Z","path":"2021/04/10/Java基础/","text":"Java基础1、注释、标识符、关键字注释平时我们编译代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到注释了。 注释并不会被执行，是给我们写代码的人看的 ==书写注释是一个非常好的== Java中的注释有三种： 单行注释 多行注释 文档注释 标识符关键字==Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。== 标识符注意点 所有的标识符都应该以字母（A-Z或者a-z）,美元符或者下划线开始 首字符之后可以是字母，美元符下划线或数字的任何字符自核 ==不能使用关键字作为变量名或方法名== 标识符是==大小写敏感==的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary、#abc ==可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音== 2、数据类型强类型语言要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 弱类型语言要求变量的使用符合规定 Java的数据类型分为两大类基本类型 引用类型 什么是字节位（bit）：是计算机 内部数据 存储的最小单位，1100 1100 是一个八位二进制。 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示 1B（byte 字节）= 8 bit（位） 字符：是指计算机中使用的字母、数字、字和符号 1bit表示一位 1Byte表示一个字节 1B=8b 1024B=1KB 1024KB=1M 1024M=1G 3、类型转换由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。 运算中，不同类型的数据先转换为同一类型，然后进行运算。 4、变量、常量变量什么是变量：就是可以变化的量！ Java是一种强类型语言，每个变量都必须声明其类型。 Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和==作用域==。 注意： 每个变量都有类型，类型可以是基本类型，也可以是引用类型。 变量名必须是合法的标识符。 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 变量作用域 类变量 示例变量 局部变量 首先我们要知道java中变量按照声明位置的不同将所有的变量分为成员变量与局部变量两大块。 在方法体外，类体内声明的变量称为==成员变量==。 方法体内部声明的变量称为==局部变量==。 两者都有声明周期，局部变量除了形参外，都需要显示初始化。(赋值) 成员变量分为实例变量与类变量。不用static的为实例变量，其他方法体使用的时候，访问时需要定义类的对象来访问，如下实例；用static使用的为类变量，在类内部引用不需要声明。类变量可以通过类或类对象来访问。 123456789101112131415public class Demo&#123; //类体内，可以有多个方法 //实例变量 String name；//这两个实例变量一个为基本类型，默认为0，一个为引用类型默认为null注意 int age； //类变量 static double salary = 2500；//在类中可以直接使用，不用声明 public static void mian(String[] agrs)&#123; //类体内，方法体外 Demo demo = new Demo(); sout(demo.age); //为0 sout(salary);//类变量 &#125;&#125; 局部变量分为形参(方法签名中定义的变量)，方法局部变量(在方法内定义)，代码块局部变量(在代码块内定义)。 常量常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值。 所谓常量可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。 常量名一般使用大写字符。 像static，final的为修饰符，不分前后， 5、运算符Java语言支持如下运算符： 算术运算符：+，-，*，%，++，- - 注意不同基本类型变量相加的类型转换问题，会自动转换为所有变量中类型最高的 赋值运算符 = 关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof 逻辑运算符：&amp;&amp;，||，！ 条件运算符：&amp;，|，^，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt; 扩展赋值运算符：+=，-=，*=，/= 6、包机制、JavaDoc包机制为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。 一般公司利用域名倒置作为报名； 为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用import语句可完成此功能。 JavaDocjavadoc命令是用来生成自己API文档的 参数信息 @author 作者名 @version 版本 @since 指明需要最早使用的jdk版本 @param 参数名 @return 返回值情况 @throws 异常抛出情况","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java入门","date":"2021-04-10T01:32:34.887Z","path":"2021/04/10/Java入门/","text":"JavaSE故事：Java帝国的诞生 一场旷日持久的战争 C&amp;C++1972年C诞生 贴近硬件，运行极快，效率极高。 操作系统，编译器，数据库，网络系统等 指针和内存管理 1982年C++诞生 面向对象 兼容C 图形领域、游戏等 反抗我们要建立一个新的语言： 语法有点像C 没有指针 没有内存管理 真正的可移植性，编译一次，到处运行 面向对象 类型安全 高质量和的类库 …… Java初生 1995年的网页简单而粗糙，缺乏互动性。 图形界面的程序（Applet） Bill Gates说：这是迄今为止设计的最好的语言！ Java 2 标准版(J2SE)：去占领桌面 Java 2 移动版(J2ME)：去占领手机 Java 2 企业版(J2EE)：去占领服务器 大量的巨头加入 Java发展 他们基于Java开发了巨多的平台，系统，工具 构建工具：Ant，Maven，Jekins 应用服务器：Tomcat，Jetty，Jboss，Websphere，weblogic Web开发：Struts，Spring，Hibernate，myBatis 开发工具：Eclipse，Netbean，intellij idea，Jbuilder …… 2006：Hadoop（大数据领域） 2008：Android（手机端） ==一个伟大的帝国诞生了== Java特性和优势 简单性 面向对象 可移植性 高性能 分布式 动态性 多线程 安全性 健壮性 Java三大版本 Write Once、Run Anywhere JavaSE：标准版(桌面程序，控制台开发……) JavaME：嵌入式开发(手机，小家电……) JavaEE(web端，服务器开发……) JDK JRE JVM JDK：Java Development Kit JRE：Java Runtime Enviroment JVM：Java Virtual Machine 搭建开发环境 JDK下载与安装 卸载JDK 删除 java 的安装目录 删除JAVA_HOME 删除 path 下关于java的目录 java -version 安装JDK 百度搜索JDK8，找到下载地址 同意协议 下载电脑对应的版本 双击安装JDK 记住安装的路径 配置环境变量 环境变量添加JAVA_HOME 配置 path 变量 测试JDK是否安装成功 配置环境变量 环境变量添加JAVA_HOME 配置 path 变量 JDK目录介绍 HelloWorld及简单语法规则 Notepad++安装和使用 HelloWorld 新建一个文件夹，存放代码 新建一个java文件 文件后缀名为.java Hello.java 系统可能没有显示文件后缀名，我们需要手动打开 编写代码 12345public class Hello()&#123; public static void main(String args[])&#123; System.out.print(&quot;Hello,World!&quot;); &#125;&#125; 编译javac Hello.java，会生成一个 class 文件 运行 class 文件，java hello 可能会遇到的问题 单词大小写不能出现问题 尽量使用英文 文件名和类型保持一致 符号);使用了中文 Java程序运行机制 编译型 解释型 程序运行机制","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"SpringMVC执行原理","date":"2021-04-08T09:35:46.512Z","path":"2021/04/08/SpringMVC三幻神/","text":"什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 中心控制器Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类) SpringMVC执行原理 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 12345678910111213141516171819package com.kuang.controller; import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 1&lt;body&gt;$&#123;msg&#125;&lt;/body&gt; 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 版权声明：本文为CSDN博主「狂神说」的原创文章，遵循CC 4.0 BY-SA版权协议。原文链接：https://blog.csdn.net/qq_33369905/article/details/106647319","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"Java中Calendar类的常用方法","date":"2021-04-07T04:55:52.305Z","path":"2021/04/07/Calendar类/","text":"Java中Calendar类的常用方法认识Calendar可分为两种，一种入门简单了解的，另一种为深入了解基础，个人查找的。 Calendar基础了解获取时间(get)123456789// 使用默认时区和语言环境获得一个日历 Calendar cal = Calendar.getInstance(); // 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1 sout(&quot;年:&quot; + cal.get(Calendar.YEAR)); sout(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1)); sout(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH)); sout(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY)); sout(&quot;分:&quot; + cal.get(Calendar.MINUTE)); sout(&quot;秒:&quot; + cal.get(Calendar.SECOND)); 结果为： 123456年:2021月:4日:7时:11分:32秒:24 设置时间(set)月份的下标从 0 开始，设置时同样需要注意，比如我们设置为 4 月 30 日除夕当晚的倒计时的最后一秒： 2021-04-30 23:59:59 12345Calendar cal = Calendar.getInstance();// 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1// cal.set(year, month, date, hourOfDay, minute, second);cal.set(2021, 4, 30, 23, 59, 59);System.out.println(cal.getTime(); 细节：如果设置的为1月32号，则时间计算会自动进行换算，跳到2月1号，对于其他换算也是如此。 时间计算(add)add方法： 比如在金今天(4/7)当晚最后一秒，add 一秒： 12345Calendar cal = Calendar.getInstance();System.out.println(cal.getTime());cal.set(2021, 4, 7, 23, 59, 59);cal.add(Calendar.SECOND, 1);System.out.println(cal.getTime()); 打印时间结果如下，日期会自动进入下一天： 12Wed Apr 07 11:39:16 CST 2021Sat May 08 00:00:00 CST 2021 再比如 1 月 30 号的时候，月份加一，会出现怎样结果：(已知2月没有30号) 12345Calendar cal = Calendar.getInstance();cal.set(2021, 0, 31, 8, 0, 0);System.out.println(cal.getTime());cal.add(Calendar.MONTH,1);System.out.println(cal.getTime()); 运行结果： 12Sun Jan 31 08:00:00 CST 2021Sun Feb 28 08:00:00 CST 2021 说明 add 月份时，会将不存在的日期归为当月日历的最后一天。 学到这对一般的日历用法够了，想继续深入了解可以参照下面 Calendar深入了解项目当中，我们经常会涉及到对时间的处理。Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，而是更推荐使用 Calendar 类进行时间和日期的处理。 原理简介Calendar类被abstract所修饰，说明不能通过new的方式来获得实例，对此，Calendar提供了一个类方法getInstance，以获得此类型的一个通用的对象，getInstance方法返回一个Calendar对象（该对象为Calendar的子类对象），其日历字段已由当前日期和时间初始化： 1Calendar cal = Calendar.getInstance(); 之所以说返回的是Calendar的子类对象，是因为每个国家地区都有自己的一套日历算法，比如西方国家的第一个星期大部分为星期日，而中国则为星期一。我们来看看getInstance方法获取实例的源码： 1234public static Calendar getInstance()&#123; return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));&#125; 其中参数TimeZone.getDefaultRef()代表的就是时区，createCalendar方法就是根据不同国家地区返回对应的日期子类。 常用方法为了更加便捷的对日期进行操作，Calendar类对YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 时间获取123456789101112131415161718192021222324252627282930313233343536373839404142434445Calendar cal = Calendar.getInstance(); //Calendar类的实例化SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //时间的格式化System.out.println(cal.getTime()); //date=Wed Apr 07 12:45:14 CST 2021System.out.println(sdf.format(cal.getTime())); //nowTime=2021-04-07 12:45:14//当前日：两种方法等价int day_of_month = cal.get(Calendar.DAY_OF_MONTH); //day_of_month=97int day = cal.get(Calendar.DATE); //day=97//获取当月day的最大值！！int max_day_of_month = cal.getActualMaximum(Calendar.DAY_OF_MONTH);System.out.println(max_day_of_month);//当前时钟：24小时制int hour24 = cal.get(Calendar.HOUR_OF_DAY);System.out.println(hour24);//当前时钟：12小时制int hour12 = cal.get(Calendar.HOUR);System.out.println(hour12);//星期几：用数字（1~7）表示（星期日~星期六），使用时通常会-1int day_of_week = cal.get(Calendar.DAY_OF_WEEK) - 1;System.out.println(day_of_week);//上午-0；下午-1int amOrPm = cal.get(Calendar.AM_PM);System.out.println(amOrPm);//当前年的第几周int week_of_year = cal.get(Calendar.WEEK_OF_YEAR);System.out.println(week_of_year);//当前月的星期数int week_of_month = cal.get(Calendar.WEEK_OF_MONTH);System.out.println(week_of_month);//当前月中的第几个星期int day_of_week_in_month = cal.get(Calendar.DAY_OF_WEEK_IN_MONTH);System.out.println(day_of_week_in_month);//当前年的第几天int day_of_year = cal.get(Calendar.DAY_OF_YEAR);System.out.println(day_of_year);int day_of_year = cal.get(Calendar.DAY_OF_YEAR); //day_of_year=27 设置时间与时间计算基础够了 小结 Calendar 类区分不同的时区输出时间格式； Calendar 类的计算优势非常明显，不需要考虑每个月有多少天，非常便利。举个例子：如果要计算昨天的日期，你要考虑昨天是不是某月的最后一天，某年的最后一天，要考虑平年、闰年，考虑上个月是31天，30天，29天还是28天…但是Calendar类省去了你所有的顾虑，直接减1天就可以输出正确的日期了； 参考链接：https://blog.csdn.net/weixin_44259720/article/details/86669177、https://blog.csdn.net/yx0628/article/details/79317440","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"常用类","slug":"常用类","permalink":"http://example.com/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"pat1009","date":"2021-04-05T15:05:29.347Z","path":"2021/04/05/pat1009/","text":"1009. 说反话 (20) [字符串处理]给定⼀句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输⼊格式： 测试输⼊包含⼀个测试⽤例，在⼀⾏内给出总⻓度不超过80的字符串。字符串由若⼲单词和若⼲空格 组成，其中单词是由英⽂字⺟（⼤⼩写有区分）组成的字符串，单词之间⽤1个空格分开，输⼊保证句 ⼦末尾没有多余的空格。 输出格式： 每个测试⽤例的输出占⼀⾏，输出倒序后的句⼦。 输⼊样例： 1Hello World Here I Come 输出样例： 1Come I Here World Hello 分析：将输⼊的每个单词s都分别v.push(s)压⼊栈中，再输出栈顶v.top()，然后将栈顶元素弹出 v.pop()，直到栈空为⽌～ 123456789101112131415#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;string&gt; v; string s; while(cin &gt;&gt; s) v.push(s); cout &lt;&lt; v.top(); v.pop(); while(!v.empty()) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; v.top(); v.pop(); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#x32;&#x33;&#48;&#52;&#x37;&#x30;&#x33;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1008","date":"2021-04-05T15:05:29.343Z","path":"2021/04/05/pat1008/","text":"1008. 数组元素循环右移问题 (20) [模拟]⼀个数组A中存有N（N&gt;0）个整数，在不允许使⽤另外数组的前提下，将每个整数循环向右移 M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1） （最后M个数循环移⾄最前⾯的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输⼊格式： 每个输⼊包含⼀个测试⽤例，第1⾏输⼊N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2⾏输⼊N个整数，之间⽤空格分隔。 输出格式： 在⼀⾏中输出循环右移M位以后的整数序列，之间⽤空格分隔，序列结尾不能有多余空格。 输⼊样例： 126 21 2 3 4 5 6 输出样例： 15 6 1 2 3 4 分析：数组⻓度为n，要想把数组循环右移m位，只需要先将整个数组a倒置，再将数组前m位倒置， 最后将数组后n-m位倒置即可完成循环右移m位～reverse函数可以实现将⼀个数组或者vector中元素倒 置，这个函数在algorithm头⽂件中～（如果m⼤于n，那么循环右移m位相当于循环右移m%n位，因为 那些n倍数位的移动是多余的，所以在使⽤m之前，先将m = m%n） 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; m %= n; if (m != 0) &#123; reverse(begin(a), begin(a) + n); reverse(begin(a), begin(a) + m); reverse(begin(a) + m, begin(a) + n); &#125; for (int i = 0; i &lt; n - 1; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; a[n - 1]; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#x30;&#50;&#x33;&#48;&#x34;&#55;&#48;&#51;&#x40;&#113;&#113;&#46;&#99;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1012","date":"2021-04-05T15:04:41.538Z","path":"2021/04/05/pat1012/","text":"1012. 数字分类给定⼀系列正整数，请按要求对数字进⾏分类，并输出以下5个数字： A1 = 能被5整除的数字中所有偶数的和； A2 = 将被5除后余1的数字按给出顺序进⾏交错求和，即计算n1-n2+n3-n4…； A3 = 被5除后余2的数字的个数； A4 = 被5除后余3的数字的平均数，精确到⼩数点后1位； A5 = 被5除后余4的数字中最⼤数字。 输⼊格式： 每个输⼊包含1个测试⽤例。每个测试⽤例先给出⼀个不超过1000的正整数N， 随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出格式： 对给定的N个正整数，按题⽬要求计算A1~A5并在⼀⾏中顺序输出。 数字间以空格分隔，但⾏末不得有多余空格。 若其中某⼀类数字不存在，则在相应位置输出“N”。 输⼊样例1： 113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 130 11 2 9.7 9 输⼊样例2： 18 1 2 4 5 6 7 9 16 输出样例2： 1N 11 2 N 9 分析：将每⼀个数字按照取余后的结果i保存在v[i]数组中，然后对v[i]中的每⼀个元素按照不同i分类计 算出A1 A2…A5～ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, num, A1 = 0, A2 = 0, A5 = 0; double A4 = 0.0; cin &gt;&gt; n; vector&lt;int&gt; v[5]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; v[num%5].push_back(num);//把所有的数看成5进制，厉害 &#125; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; v[i].size(); j++) &#123; if (i == 0 &amp;&amp; v[i][j] % 2 == 0) A1 += v[i][j];//A1结果出来了 if (i == 1 &amp;&amp; j % 2 == 0) A2 += v[i][j]; if (i == 1 &amp;&amp; j % 2 == 1) A2 -= v[i][j];//A2结果出来了 if (i == 3) A4 += v[i][j];//求出的为满足5进制A4的所有数总和 if (i == 4 &amp;&amp; v[i][j] &gt; A5) A5 = v[i][j];//A5最大值结果出来了 &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123; if (i != 0) printf(&quot; &quot;);//这种方法和动态sql语句很像 if (i == 0 &amp;&amp; A1 == 0 || i != 0 &amp;&amp; v[i].size() == 0) &#123;//为(i==0&amp;&amp; A1== 0)||(i!=0&amp;&amp;v[i].size()==0),一个复杂短路或运算 printf(&quot;N&quot;); continue; &#125; if (i == 0) printf(&quot;%d&quot;, A1); if (i == 1) printf(&quot;%d&quot;, A2); if (i == 2) printf(&quot;%d&quot;, v[2].size());//返回A3个数，正好为放进去的个数 if (i == 3) printf(&quot;%.1f&quot;, A4 / v[3].size());//A4平均数 if (i == 4) printf(&quot;%d&quot;, A5); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#50;&#51;&#x30;&#52;&#x37;&#48;&#x33;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1013","date":"2021-04-05T15:04:41.538Z","path":"2021/04/05/pat1013/","text":"1013. 数素数 (20)令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 10^4，请输出PM到PN的所有素数。 输⼊格式： 输⼊在⼀⾏中给出M和N，其间以空格分隔。 输出格式： 输出从PM到PN的所有素数，每10个数字占1⾏，其间以空格分隔，但⾏末不得有多余空格。 输⼊样例： 15 27 输出样例： 12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 分析：vector中保存第M到第N个素数，⽤cnt标记输出了多少个，如果当前已经输出的个数为10的倍 数，则输出⼀个空⾏～ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool isprime(int a) &#123; //判断传过来的是不是质数，如果不是返回false，是返回true for (int i = 2; i * i &lt;= a; i++) if(a % i == 0) return false; return true;&#125;int main() &#123; int M, N, num = 2, cnt = 0; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; v; while (cnt &lt; N) &#123; if (isprime(num)) &#123; cnt++; if (cnt &gt;= M) v.push_back(num); &#125; num++; &#125; cnt = 0; //剩下部分用来解决输出相关问题，包括空格、一行10个 for (int i = 0; i &lt; v.size(); i++) &#123; cnt++; if (cnt % 10 != 1) printf(&quot; &quot;); printf(&quot;%d&quot;, v[i]); if (cnt % 10 == 0) printf(&quot;\\n&quot;); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#x32;&#x33;&#48;&#x34;&#x37;&#x30;&#x33;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1011","date":"2021-04-05T15:04:40.454Z","path":"2021/04/05/pat1011/","text":"1010. A+B和C题⽬描述： 给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否⼤于C。 输⼊格式： 输⼊第1⾏给出正整数T(&lt;=10)，是测试⽤例的个数。随后给出T组测试⽤例，每组占⼀⾏，顺序给出 A、B和C。整数间以空格分隔。 输出格式： 对每组测试⽤例，在⼀⾏中输出“Case #X: true”如果 A+B&gt;C，否则输出“Case #X: false”，其中X是测试⽤例的编号（从1开始）。 输⼊样例： 1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例： 1234Case #1: falseCase #2: trueCase #3: trueCase #4: false 分析：使⽤long long int存储a、b和c，当a + b &gt; c的时候输出true，否则输出false～ 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; long long int a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); printf(&quot;Case #%d: %s\\n&quot;, i + 1, a + b &gt; c ? &quot;true&quot; : &quot;false&quot;); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#50;&#x33;&#48;&#x34;&#55;&#48;&#x33;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1010","date":"2021-04-05T14:52:44.410Z","path":"2021/04/05/pat1010/","text":"1010. ⼀元多项式求导 (25) [模拟]设计函数求⼀元多项式的导数。（注：xn（n为整数）的⼀阶导数为n*xn-1。） 输⼊格式： 以指数递降⽅式输⼊多项式⾮零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式： 以与输⼊相同的格式输出导数多项式⾮零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。 输⼊样例： 13 4 -5 2 6 1 -2 0 输出样例： 112 3 -10 1 6 0 分析： flag⽤来判断是否已经有过输出～ 当b!=0时，因为给出的是所有⾮零项系数，所以必定会有输出，先判断flag是否为1，如果为1表示已 经有过输出，那么在前⾯要先输出⼀个空格 输出 a * b 和 b – 1，然后将flag标记为1表示已经有过输出 4.最后判断当没有输出并且b==0的时候， 输出“0 0” 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, flag = 0; while (cin &gt;&gt; a &gt;&gt; b) &#123; if (b != 0) &#123; if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a * b &lt;&lt; &quot; &quot; &lt;&lt; b - 1; flag = 1; &#125; &#125; if (flag == 0) cout &lt;&lt; &quot;0 0&quot;; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#x32;&#x33;&#x30;&#52;&#55;&#48;&#51;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MyBatisPlus概述","date":"2021-04-05T14:42:13.244Z","path":"2021/04/05/MyBatisPlus/","text":"MyBatisPlus概述需要的基础：SSM就可以学习这个了！ 为什么要学习它呢？MyBatisPlus 可以节省我们大量工作时间，所有的CRUD代码他都可以自动化完成！ JPA、tk-mapper、MyBatisPlus 偷懒的！ 简介是什么？MyBatis 本来就是简化 JDBC 而生 官网：为简化开发而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门地址：https://mp.baomidou.com/guide/quick-start.html#初始化工程 使用第三方组件： 导入对应的依赖 研究依赖如何配置 代码如何编写 提高扩展技术能力！ 步骤 创建数据库mybatis_plus 创建user表 1234567891011121314151617DROP TABLE IF EXISTS USER;CREATE TABLE USER( id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;, NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;, age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;, PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 编写项目，初始化项目！使用 SpringBoot 初始化！ 导入依赖 12345678910111213141516&lt;!--数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--mybatis_plus 是自己开发，并非官方的！--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 说明：我们使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus！版本的差异！ 连接数据库！这一步和 mybatis 相同 12345# mysql 8 驱动不同com.mysql.cj.jdbc.Driver需要增加时区的配置 serverTimeZone=Asia.Shanghaispring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 传统方式pojo-dao（连接mybatis，配置mapper.xml）-service-controller 使用了mybatis-plus 之后 pojo 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String smail;&#125; mapper接口 123456// 在对应的Mapper上面继承基本的类 BaseMapper@Repository //代表持久层public interface Usermapper extends BaseMapper &#123; //所有的CRUD操作都已经编写完成了 //你不需要像以前的配置一大堆文件了！&#125; 注意点，我们需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(&quot;com.kuang.mapper&quot;) 测试类中测试 配置日志我们所有的 sql 现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！ 12# 配置日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上 Mybatis-Plus！ CRUD扩展插入操作123456789101112//测试插入@Testpublic void testInsert()&#123; User user = new User(); user.setName(&quot;狂神说Java&quot;); user.setAge(3); user.setEmail(&quot;27917232@qq.com&quot;); int result = userMapper.insert(user);//帮我们自动生成id System.out.println(result);//受影响的行数 System.out.println(user);//发现，id会自动回填&#125; 数据库插入的id默认值为：全局的唯一id主键生成策略123@TableId(IdType.NONE)默认 * 用户输入ID * 该类型可以通过自己注册自动填充插件进行填充 分布式系统唯一id生成 雪花算法： snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。 可以查看表单的ID生成 123456789101112131415161718192021222324252627/** * 数据库ID自增 */AUTO(0),/** * 该类型为未设置主键类型 */NONE(1),/** * 用户输入ID * 该类型可以通过自己注册自动填充插件进行填充 */INPUT(2),/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *//** * 全局唯一ID (idWorker) */ID_WORKER(3),/** * 全局唯一ID (UUID) */UUID(4),/** * 字符串全局唯一ID (idWorker 的字符串表示) */ID_WORKER_STR(5); 主键自增 我们需要配置主键自增 实体类字段上@TableId(type=IdType.AUTO) 数据库字段一定要是自增的！ 再次测试插入即可！ 更新操作12345678910111213//测试更新@Testpublic void testUpdate()&#123; User user = new User(); //通过条件自动拼接动态sql user.setId(6L); user.setName(&quot;关注公众号：狂神说&quot;); user.setAge(18); //注意：updateById 但是参数是一个对象！ int i = userMapper.updateById(user); System.out.println(i);&#125; 所有的 sql 都是自动帮你动态配置的！ 自动填充创建时间、修改时间！这些个操作一般都是自动化完成的，我们不希望手动更新！ 阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！并且需要自动化！ 方式一：数据库级别（工作中不允许修改数据库的） 在表中新增字段create_time，update_time，默认为CURRENT_TIMESTAMP 再次测试插入方法，我们需要先把实体类同步！ 12private Date createTime;private Date updateTime; 方式二：代码级别 删除数据库中的默认值、更新操作！ 实体类字段属性上需要增加注解 12345//字段添加填充内容@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 编写处理器来处理这个注解即可！ 123456789101112131415161718@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill.....&quot;); this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125; //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill.....&quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125;&#125; 测试插入 测试更新，观察时间即可！ 乐观锁在面试过程中，我们经常参观会被问道乐观锁，悲观锁！这个其实非常简单！ 乐观锁：故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现问题，再次更新值测试 乐观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作 我们这里主要讲解 乐观锁机制！ 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 给数据库增加version字段； 我们实体类加对应的字段 12@Version //乐观锁Version注解private Integer version; 注册组件 1234567891011//扫描我们的mapper文件@MapperScan(&quot;com.kuang.mapper&quot;)@EnableTransactionManagement@Configuration //配置类public class MyBatisPlusConfig &#123; //注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor()&#123; return new OptimisticLockerInterceptor(); &#125;&#125; 测试 查询操作123456789101112131415161718192021222324//测试查询@Testpublic void testSelectById()&#123; User user = userMapper.selectById(1L); System.out.println(user);&#125;//测试批量查询@Testpublic void testSelectBatchIds()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println);&#125;//按条件查询之一 使用map操作@Testpublic void testSelectByMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //自定义查询 map.put(&quot;name&quot;,&quot;狂神说Java&quot;); map.put(&quot;age&quot;,3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println);&#125; 分页查询分页在网页使用的十分之多！ 原始的 limit 进行分页 pageHelper 第三方插件 MP 其实也内置了分页插件！ 如何使用 配置拦截器组件即可！ 12345//分页插件@Beanpublic PaginationInterceptor paginationInterceptor()&#123; return new PaginationInterceptor();&#125; 直接使用Page对象即可！ 12345678910@Testpublic void testPage()&#123; //参数一：当前页 //参数二：页面大小 //使用了分页插件之后，所有的分页操作也变得简单了！ Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println);&#125; 删除操作基本的删除操作 12345678910111213141516171819//测试删除@Testpublic void testDeleteById()&#123; userMapper.deleteById(1378534644579885060L);&#125;//通过id批量删除@Testpublic void test()&#123; userMapper.deleteBatchIds(Arrays.asList(1378534644579885058L,1378534644579885059L));&#125;//通过map删除@Testpublic void testDeleteMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;狂神说Java&quot;); userMapper.deleteByMap(map);&#125; 我们在工作中回遇到一些问题，逻辑删除！ 逻辑删除 物理删除：从数据库中直接移除 逻辑删除：在数据库中没有被移除，而是通过一个变量来让它生效！delete = 0 =&gt;delete = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站 测试一下： 在数据表中增加一个 deleted 字段 实体类中增加属性 12345//逻辑删除组件!@Beanpublic ISqlInjector sqlInjector()&#123; return new LogicSqlInjector();&#125; 配置！ 123# 配置逻辑删除mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0 测试删除数据 走的是更新操作，并不是删除操作 查询的时候会自动过滤被逻辑删除的字段 以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高工作和写项目的效率！ 性能分析插件我们在平时的开发中，会遇到一些慢 sql。测试！druid… 作用：性能分析拦截器，用于输出每条SQL语句及其执行时间 MP也提供性能分析插件，如果超过这个时间就停止运行！ 导入插件 1234567891011&#x2F;** sql执行效率插件*&#x2F;@Bean@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)&#x2F;&#x2F;设置 dev test 环境启动，保证我们的效率 public PerformanceInterceptor performanceInterceptor()&#123; PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100);&#x2F;&#x2F;ms 设置sql执行的最大时间，如果超过了则会报错 performanceInterceptor.setFormat(true);&#x2F;&#x2F;是否格式化代码 return performanceInterceptor;&#125; 记住，要在SpringBoot中配置环境为dev或者test环境！ 测试使用！只要超过规定的时间就会抛出异常 1234567@Testvoid contextLoads() &#123; //参数是一个Wrapper 条件构造器，这里我们先不用 null //查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println);&#125; 使用性能分析插件，可以帮助我们提高效率！ 条件构造器十分重要：Wrapper 我们写一些复杂的 sql 就可以使用它来代替！ 测试一 12345678910@Testvoid contextLoads() &#123; //查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(&quot;name&quot;) .isNotNull(&quot;email&quot;) .ge(&quot;age&quot;,12); userMapper.selectList(wrapper).forEach(System.out::println);//和我们刚才学习的map对比一下！&#125; 测试二 12345678@Testpublic void test2()&#123; //查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;name&quot;,&quot;狂神说&quot;); User user = userMapper.selectOne(wrapper);//查询一个数据，出现多个结果使用List 或者 Map System.out.println(user);&#125; 测试三 12345678@Testpublic void test3()&#123; //查询年龄在20-30之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(&quot;age&quot;,20,30);//区间 Integer count = userMapper.selectCount(wrapper);//查询结果数 System.out.println(count);&#125; 测试四，记住查看输出的SQL进行分析 12345678910@Testpublic void test4()&#123; //查询年龄在20-30之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //左和右 %e% wrapper.notLike(&quot;name&quot;,&quot;e&quot;) .likeRight(&quot;email&quot;,&quot;t&quot;); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);//查询结果数 maps.forEach(System.out::println);&#125; 测试五 12345678@Testpublic void test5()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //id 在子查询中查出来 wrapper.inSql(&quot;id&quot;,&quot;select id from user where id&lt;3&quot;); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);//查询结果数 objects.forEach(System.out::println);&#125; 测试六 123456789@Testpublic void test6()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //通过id进行排序 wrapper.orderByDesc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(wrapper);//查询结果数 users.forEach(System.out::println);&#125; 其余的测试，可以自己下去多练习！ 代码自动生成器dao、pojo、service、controller都给我自己去编写完成！ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"}]},{"title":"git","date":"2021-04-05T14:42:13.241Z","path":"2021/04/05/git/","text":"git学习 git 之前，我们需要先明白一个概念，版本控制！ 版本控制 什么是版本控制 版本迭代，新的版本！版本管理器 版本控制是一种在开发的过程中用管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便回复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事务性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。 无论是工作还是学习，或者自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！ 多人开发就必须要使用，都在代价会比较大 常见的版本控制工具 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制产品非常的多，现影响力最大且使用最广泛的是Git 版本控制分类 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。 集中版本控制 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 分布式版本控制 Git 每个人都有全部的代码！安全隐患！ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN最主要的区别 SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git 是分布式版本控制系统，没有中央服务器，每一个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己的电脑上改了文件A，其他人也在电脑上改了文件A，这时，它们俩只需把各自的修改推送给对方，就可以互相看到对方的修改了。 ==Git 是目前世界上最先进的分布式版本控制系统。== 聊聊Git历史同生活中的很多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众广的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991-2002年间）。到2002年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 Linux 社区中存在许多的大佬！破解研究 BitKeeper！ 到了2005年，开发BitKeeper的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是Linux的缔造者 Linux Torvalds）基于使用BitKeeper 时的经验教训，开发出自己的版本系统。（两周左右）也就是后来的Git！ Git环境配置 软件下载 打开[git官网]，下载git对应操作系统的版本。 所有东西下载慢的话就可以去找镜像！ 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows 卸载 直接反安装即可、然后清理环境变量 下载对应的版本即可安装！ 安装：无脑下一步即可！安装完毕就可以使用了！ 启动Git 安装成功后在开始菜单中会有Git选项，菜单下有3个程序：任意文件夹下右键 Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格的命令行 Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 常用的Linux命令学习 cd：改变目录。 cd..：退回到上一个目录，直接cd进入默认目录 pwd：显示当前所在的目录路径 ls(ll)：都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 touch：新建一个文件，如touching index.js 就会在当前目录下新建一个index.js 文件 rm：删除一个文件，rm index.js 就会把 index.js 文件删除 mkdir：新建一个目录，就是新建一个文件夹 rm -r：删除一个文件夹，rm -r -src 删除src目录 mv：移动文件，mv index.html src index.html 是我们要移动的文件，src 是目标文件夹，当然，这样写 reset：重新初始化终端/清屏 clear：清屏 history：查看命令历史 help：帮助 exit：退出 #：表示注释 Git 配置 查看配置git config -l查看不同级别的配置文件 12345# 查看系统configgit config --system --list# 查看当前用户(global)配置git config --global --list Git相关的配置文件 Git\\etc\\gitconfig：Git安装目录下的 gitconfig –System 系统级 C:\\user\\Administrator\\.gitconfig 只适用于当前登录用户的配置 –global 全局 这里可以直接编辑配置文件，通过命令设置后会影响到这里 设置用户名和邮箱(用户标识,必要) 当你安装Git后首先要做的事情是设置你的用户名和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： 12git config --global user.name &quot;touchingwang&quot; #名称git config --global user.email touchingwang@163.com #邮箱 Git基本理论（核心所有的实践都需要源于这个理论） 工作区域 Git 本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Respository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域了。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是你平时存放项目代码的地方 Stage/Index：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Respository：仓库区(或本地仓库)：就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你的项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本 Directory：使用Git管理的一个目录，也就是一个仓库，包括我们的工作空间和Git的管理空间 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新去，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Satsh：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域； 将暂存区域的文件提交到git仓库 因此，git管理的文件有三种状态：已修改(modified)，已暂存(staged)，已提交(committed) Git项目搭建 创建工作目录与常见指令 工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住6个命令： 本地仓库搭建 创建全新的仓库，需要用Git管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 12# 克隆一个项目和它的整个代码历史(版本信息)git clone [url] https://gitee.com/XXX 去gitee或者github上克隆一个测试！ Git文件操作 文件4中状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。通过git add状态变为Straged。 Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变成Modified.如果使用git rm移出版本库，则成为Untracked文件 Modefied：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过git add可进入暂存staged状态，使用git checkout则丢弃修改过，返回到unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改！ Staged：暂存状态，执行git commit则将修改同步到库，这时库中的文件和本地文件又变为一致，文件为Unmodify状态。执行git reset HEAD filename取消暂存，文件状态为Modified 查看文件状态 上面说文件有4种状态，通过如下命令可以查看到文件的状态： 12345678# 查看指定文件状态git status [filename]# 查看所有文件状态git status# git add . 添加所有文件到暂存区# git commit -m 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下规则： 忽略文件中的空行或以井号(#)开始的行将会被忽略。 可以使用Linux通配符。例如：星号(*)代表任意多个字符，问号(?)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,…})代表可选的符号串等。 如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略。 如果名称的最前面有一个路径分分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面有一个路径分分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)。 123456# 为注解*.txt #忽略所有 .txt结尾的文件，这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件，不包括其他目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略doc/notes.txt 但不包括 doc/sercer/arch.txt 使用码云 github 是由墙的，比较慢，在国内的话，我们一般使用gitee，公司中有时候会搭建自己的gielab服务器 这个其实可以作为大家未来找工作的一个重要信息！ 注册登录码云，完善个人信息 设置本机绑定SSH公钥，实现免密码登录！(免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！) 123# 进入 C:\\User\\Administrator\\.ssh 目录# 生成公钥ssh-keygen 将公钥信息public key添加到码云账户中即可！ 使用码云创建一个自己的仓库！ 克隆到本地！ IDEA中集成Git 新建项目，绑定git。 将我们远程的git文件目录拷贝到项目中即可！ 注意观察idea中的变化 修改文件，使用IDEA操作git 提交测试 这些都是单个人的操作！ 说明：GIT分支git分支中常用的命令 123456789101112131415161718192021# 列出所有本地分支 git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支git merge [branch]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 多个分支如果并行执行，就会导致我们代码冲突，也就是同时存在多个版本！ web-api -A web-admin -B 会调用A（修改了A的代码！） web-app -C 会调用 B 和 A 的代码 如果冲突了就需要协商即可！ 如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 团队很重要！","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"服务器相关知识","date":"2021-04-05T14:42:13.239Z","path":"2021/04/05/服务器相关知识/","text":"服务器相关知识 为什么程序员都需要一个自己的服务器 你作为一个程序员，必须要发布自己的网站和项目！ 练习Linux操作 自己的远程仓库、远程数据库、远程tomcat…..搭建在服务器上 练习，Linux进行任意的环境部署操作！Window下开发，你不熟悉Linux …… 服务器如何购买 尽量趁打折，购买，便宜！ 如果是学生或者24岁一下的小伙伴，可以购买学生机，100多一年 香港服务器可以避免备案，但是尽量不要自己挂VPN，会被封！ 买完服务器之后该做什么 服务器就是一个远程Linux 在阿里云购买的，需要开通安全组设置；端口映射（端口映射都需要在） 获取服务器的公网 ip 地址；修改实例名和密码，第一次修改需要重启。使用 xshell 远程连接 连接到服务器之后，我们需要搭建环境！ 傻瓜式 宝塔面板安装教学 下载完毕之后，就可以得到一个地址：宝塔的管理面板！ url： username： password： 自定义安装服务器环境 一键部署应用 比如tomcat 就可以放到 webapps 目录下！ 特殊的网站：开源项目，就按照自己操作来！ 上传文件尽量使用XFTP 命令式（原生）","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Mybatis知识笔记","date":"2021-03-28T10:13:19.300Z","path":"2021/03/28/Mybatis/","text":"Mybatis-2.10环境： JDK 1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。最好的方式：看官网文档； 1、简介1.1、什么是 MyBatis 是一款优秀的持久层框架 支持定制化 SQL、存储过程以及高级映射架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 如何获取 Mybatis maven仓库 1.2、持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io 文件持久化 为什么需要持久化？ 有一些对象，不能让他丢掉 内存太贵了 1.3、持久层Dao层(Data Access Objects数据持久层对象)，Service层，Controller层… 完成持久化工作的代码块 层界限十分明显。 1.4、为什么需要Mybatis? 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。技术没有高低之分 优点： 简单易学 灵活 sql 的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组件维护 提供 xml 标签，支持编写动态 sql 使用的人多 Spring SpringMVC SpringBoot 2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 连接数据库会出现serverTimeZone设置时区问题将其改为Asia/Shanghai 2.1、搭建环境搭建数据库 12345678910111213CREATE DATABASE `mybatis`;SHOW DATABASES;USE `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;213123&#x27;) 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!----&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、创建一个模块123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 12345678910111213141516171819202122//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static&#123; try &#123; //使用Myabatis第一步 获取sqlSessionFactory对象 String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。 //SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 //而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 public static SqlSession getSqlSession()&#123; return SqlSessionFactory sqlSessionFactory.openSession(); &#125;&#125; 2.3、编写代码 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//实体类public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wang.dao.UserDao&quot;&gt;&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2.4、测试注意点：org.apache.ibatis.binding.BindingException: Type interface com.wang.dao.UserDao is not known to the MapperRegistry.（UserDao类型接口没有在注册中心显示） MapperRegistry是什么？ 核心配置文件中注册 mappers junit 测试 12345678910111213141516@Testpublic void test()&#123; //第一步：获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一:getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close();&#125; 可能会遇到的问题： 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD1、namespacenamespace中的包命要和 Dao/mapper 接口的包名一致！ 2、select选择，查询语句； id：就是对应的namespace中的方法名； resultType：Sql 语句执行的返回值！ parameterType：参数类型！ 编写接口 12//根据ID查询用户User getUserById(Int id); 编写对应的mapper中的sql语句 1234&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 1234567891011@Testpublic void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close();&#125; 3、Insert123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt; 4、update123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;&lt;/update&gt; 5、Delete123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;;&lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范 NullPointerException，没有注册到资源！ 输出的xml文件中存在中文乱码的问题 maven资源没有导出问题！ 7、万能map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 123//万能的Mapint addUser2(Map&lt;String,Object&gt; map); 1234&lt;!--对象中的属性，可以直接取出来 传递map的key--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id,pwd) values (#&#123;userid&#125;,#&#123;password&#125;);&lt;/insert&gt; 123456789101112131415@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,5); map.put(&quot;password&quot;,&quot;22223333&quot;); mapper.addUser2(map); sqlSession.commit(); sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！【parameterType=”map“】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object“】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8、思考题模糊查询怎么写？ Java代码执行的时候，传递通配符%% 1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符！ 1select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot; 4、配置解析1、核心配置文件 mybatis-config.xml Mybatis 的配置文件包含了会深深影响Mybatis 行为和设置的属性信息 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 2、环境配置（enviroments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是JDBC，连接池：POOLED 3、属性（property）我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 意思是可以的Java属性文件中配置，也可以在db.properties中去配置【db.properties】 将properties标签放在后面，出现这段话的意思是，在xml中，所有的标签都可以规定其顺序，即按照它所给的标签顺序写入，否则会报错 编写一个配置文件 db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF8username=rootpassword=123456 在核心配置文件中映入 12345&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/properties&gt; 可以直接引入外部配置文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，官方文档说首先读取在 properties 元素体内指定的属性。意思是先读取标签元素体内的属性，在去读取外部文件的属性，这样外部的会把标签内的覆盖掉，这样就会读取到外部配置文件的属性。 4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.wang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，Mybatis 会在包名下面搜索需要的Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！ 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.wang.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种不行，如果非要该，需要在实体上增加注解 12@Alias(&quot;user&quot;)public class User &#123;&#125; 5、设置这是Mybatis 中极为重要的调整设置，它们会改变 Mybatis 的运行时行为。 6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用 mapper 7、映射器（mapper）MapperRegistty：注册绑定我们的Mapper文件； 方式一： 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/wang/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二：使用 class 文件绑定注册 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;package name=&quot;com.wang.dao&quot; /&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口和 UserMappper.xml 改为一致！并且放在同一个包下！ 3、生命周期和作用域作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuider： 一旦创建了SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 连接池的一个连接（请求）! SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用。 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题1、问题数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 12345public class User &#123; private int id; private String name; private String password;&#125; 测试出现问题 发现属性名与字段名不一致的提取不出来所需要的值 123//select * from mybatis.user where id = #&#123;id&#125;//类型处理器//select id,name,pwd from mybatis.user where id = #&#123;id&#125; 解决方法： 起别名 2、resultMap结果集映射 12id name pwdid name password 1234567&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。 6、日志6.1、日志工程如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout，debug 现在：日志工厂！ SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING 在Mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ 6.2、Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入LOG4J的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/wang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 12345 &lt;settings&gt; &lt;!--标准的日志工厂实现--&gt;&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; Log4j的使用！直接测试运行刚才的查询 简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 123logger.info(&quot;info:进入了testLog4j&quot;);logger.debug(&quot;debug:进入了testLog4j&quot;);logger.error(&quot;error:进入了testLog4j&quot;); 7、分页思考：为什么要分页？ 减少数据的处理量 7.1、使用Limit分页123语法:SELECT * FORM lIMIT startIndex,pageSize;select *from user limit 2,2; 笔记： 0,3 意思是每页显示 3 个从第0个开始查询 使用Mybatis实现分页，核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!--分页--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 这里返回的为resultMap结果集映射，其中的UserMap为对应的章节的映射，我这里就出错了。 测试 12345678910111213141516@Testpublic void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,0); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userByLimit = mapper.getUserByLimit(map); for (User user : userByLimit) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.2、RowBounds分页不再使用SQL实现分页 接口 12//分页2List&lt;User&gt; getUserByRowBounds(); mapper.xml 1234&lt;!--分页2--&gt;&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 123456789101112131415@Testpublic void getUserByRowBounds()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.wang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.3、分页插件 PageHelper了解即可，万一以后公司的架构师，说要使用，你需要知道它是什么东西！ 8、使用注解开发8.1、面向接口编程大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因：==解耦==，可扩展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得很容易，规范性很好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现租户的，对系统来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体（abstract class） 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface） 一个体有可能有多个抽象面。抽象面与抽象面是由区别的。 三个面向区别 面向对象是指，我们考虑问题是，以对象为单位，考虑它的属性及方法。 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现。 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题。更多的体现就是对系统整体的构架。 8.2、使用注解开发 注解在接口上实现 12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口！ 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ 8.3、注解的CRUD我们可以在工具类创建的时候实现自动提交事务！(util里） 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注解 123456789101112131415161718public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解 @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserByID(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name = #&#123;name&#125;,pwd=#&#123;password&#125; where id = &#123;#id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);&#125; 测试类 【注意：我们必须要将接口注册绑定到我们的核心配置文件中！】 8.4、关于@Param（）注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的@Param（）中设定的属性名！ #{} ${}区别 9、Lombok12Project Lombok is a java library that automatically plugs插件 into your editor（在你的代码里面） and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs 插件 build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 12345&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;version&gt;1.18.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 在实体类上加注解 123@Data@AllArgsConstructor@NoArgsConstructor 12345678910111213141516@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows 说明： 123456@Data：无参构造、get、set、tostring、hashcode、equals@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode@ToString@Getter 10、多对一处理多对一： 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 对于老师而言，集合，一个老师，有很多学生 SQL： 123456789101112131415161718192021222324252627CREATE TABLE &#96;teacher&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INDELETE FROM &#96;mybatis&#96;.&#96;user&#96; WHERE &#96;id&#96; &#x3D; &#39;id&#39; ;TO teacher(&#96;id&#96;, &#96;name&#96;) VALUES (1, &#39;秦老师&#39;); CREATE TABLE &#96;student&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, &#96;tid&#96; INT(10) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;fktid&#96; (&#96;tid&#96;), CONSTRAINT &#96;fktid&#96; FOREIGN KEY (&#96;tid&#96;) REFERENCES &#96;teacher&#96; (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;); 测试环境搭建 导入 lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或文件！【方式很多，随心选】 测试查询是否能够成功！ 按照查询嵌套处理12345678910111213141516171819&lt;!-- 思路： 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 按照结果嵌套处理1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 回顾Mysql多对一查询方式： 子查询 连表查询 11、一对多处理比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系 环境搭建，和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结构嵌套处理1234567891011121314151617181920&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection javatype=&quot;&quot; 指定属性的类型！ 集合中的泛型信息，我们使用oftype获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理1234567891011&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudents2&quot;&gt; select * from mybatis.teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudents2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志，建议使用Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ 12、动态SQL==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态SQL这一特性可以彻底摆脱这种痛苦 1234ifchoose (when, otherwise)trim (where, set)foreach 搭建环境1234567CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口 和 Mapper.XML文件 if123456789&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; choose(when, otherwise)1234567891011121314select * from mybatis.blog&lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; trim(where,set)123456789select * from mybatis.blog&lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/where&gt; ==所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码== if where，set，choose，when SQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 1234select * from mybatis.blog&lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;&lt;/where&gt; 在需要使用的地方使用 Include 标签引用即可 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 注意事项： 最好基于单表来定义SQL片段！ 不要存在 where 标签 Foreach1234567891011&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map，这map中可以存在一个集合！ --&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and(&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 现在 Mysql 中写出完整的SQL，在对应的去修改成为我们的动态SQL实现通用即可！ 13、缓存13.1、简介12查询 ： 连接数据库 ， 耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--》内存：缓存 什么是缓存【cache】？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地指定和配置缓存。缓存可以极大的提高查询效率。 Mybatis系统中默认定义了二级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.3、一级缓存 一级缓存也交本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库； 测试步骤： 开启日志！ 测试在一个Session中查询两次记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于 namspace 级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存指定数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 12&lt;!--在当前Mapper.xml中开启二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题：如果只写&lt;cache/&gt;会出现序列化缓存的问题，如果开启了eadOnly=&quot;true&quot;就可以了 1Caused by: java.io.NotSerializableException: com.wang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ 13.5、缓存原理 13.6、自定义缓存-ehcache1Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用 ehcache，先要导包！ 在 mapper 中指定使用我们的Ehcache 缓存实现！ Redis 数据库来做缓存！","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"}]},{"title":"UUID的故事","date":"2021-03-27T14:49:46.670Z","path":"2021/03/27/UUID/","text":"UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。 如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID） 1.简介UUID 是国际标准化组织（ISO-International Organization for Standardization）提出的一个概念。UUID 是一个128比特的数值，这个数值可以通过一定的算法计算出来。 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。 UUID 由以下几部分的组合： 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 2.重复机率随机产生的 UUID 的128个比特中，有122个比特是随机产生，4个比特在此版本被使用，还有2个在其变体中被使用。 与被陨石击中的机率比较的话，已知一个人每年被陨石击中的机率估计为170亿分之1，也就是说机率大约是0.00000000006 (6 x 10^-11)，等同于在一年内置立数十兆笔GUID并发生一次重复。换句话说，每秒产生10亿笔UUID，100年后只产生一次重复的机率是50%。如果地球上每个人都各有6亿笔GUID，发生一次重复的机率是50%。 3.版本UUID具有多个版本，每个版本的算法不同，应用范围也不同。 基于时间的UUID基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。 基于名字的UUID（MD5）基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"pat1007","date":"2021-03-27T06:58:57.578Z","path":"2021/03/27/pat1007/","text":"1007. 素数对猜想 (20) [素数]让我们定义 dn 为：dn = pn+1 – pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数 对猜想”认为“存在⽆穷多对相邻且差为2的素数”。 现给定任意正整数N (&lt; 105)，请计算不超过N的满⾜猜想的素数对的个数。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数N。 输出格式： 每个测试⽤例的输出占⼀⾏，不超过N的满⾜猜想的素数对的个数。 输⼊样例： 120 输出样例： 14 分析：判断素数的函数isprime这样写：对于数字a，i从2到根号a，如果a能够被其中⼀个i整除，说明i 不是素数，return false，否则说明a是素数return true；对于输⼊数据N，for循环中的i从5到N依次判断 i-2和i是否是素数，如果都是素数，则统计个数的cnt++，最后输出cnt即可～ 123456789101112131415#include &lt;iostream&gt;using namespace std;bool isprime(int a) &#123; for (int i = 2; i * i &lt;= a; i++) if (a % i == 0) return false; return true;&#125;int main() &#123; int N, cnt = 0; cin &gt;&gt; N; for (int i = 5; i &lt;= N; i++) if (isprime(i-2) &amp;&amp; isprime(i)) cnt++; cout &lt;&lt; cnt; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#x33;&#x30;&#52;&#55;&#48;&#51;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1006","date":"2021-03-27T06:53:10.558Z","path":"2021/03/27/pat1006/","text":"1006. 换个格式输出整数 (15) [字符串处理]让我们⽤字⺟B来表示“百”、字⺟S表示“⼗”，⽤“12…n”来表示个位数字n（&lt;10），换个格式来输出任 ⼀个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“⼗”、以及个位的 4。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数n（&lt;1000）。 输出格式： 每个测试⽤例的输出占⼀⾏，⽤规定的格式输出n。 输⼊样例： 1234 输出样例： 1BBSSS1234 输⼊样例2： 123 输出样例2： 1SS123 分析：因为n⼩于1000，所以数字不会超过百位～输⼊数据⾸先保存在a中，然后将a的每⼀个数字保存 在int b[3]中，然后将b[2]、b[1]、b[0]中存储的数字看作输出次数依次输出B、S和12..b[0]～ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int a, i = 0; cin &gt;&gt; a; int b[3] = &#123;0&#125;; while (a != 0) &#123; b[i++] = a % 10; a = a / 10; &#125; for (int k = 0; k &lt; b[2]; k++) cout &lt;&lt; &quot;B&quot;; for (int k = 0; k &lt; b[1]; k++) cout &lt;&lt; &quot;S&quot;; for (int k = 0; k &lt; b[0]; k++) cout &lt;&lt; k + 1; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#50;&#51;&#x30;&#52;&#55;&#48;&#x33;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1005","date":"2021-03-27T06:49:05.269Z","path":"2021/03/27/pat1005/","text":"1005.继续(3n+1)猜想 (25) [Hash散列]卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题⽬⾥，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每⼀个数。例如对 n=3进⾏验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进⾏验证的时候，就 可以直接判定卡拉兹猜想的真伪，⽽不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我 们称5、8、4、2是被3“覆盖”的数。我们称⼀个数列中的某个数n为“关键数”，如果n不能被数列中的其 他数字所覆盖。 现在给定⼀系列待验证的数字，我们只需要验证其中的⼏个关键数，就可以不必再重复验证余下的数 字。你的任务就是找出这些关键数字，并按从⼤到⼩的顺序输出它们。 输⼊格式： 每个测试输⼊包含1个测试⽤例，第1⾏给出⼀个正整数K(&lt;100)，第2⾏给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间⽤空格隔开。 输出格式： 每个测试⽤例的输出占⼀⾏，按从⼤到⼩的顺序输出关键数字。数字间⽤1个空格隔开，但⼀⾏中最后 ⼀个数字后没有空格。 输⼊样例： 1263 5 6 7 8 11 输出样例： 17 6 分析：对每⼀个输⼊的数字n进⾏验证，把验证过的数字对应的arr标记为1，然后对这些输⼊的数字从 ⼤到⼩排序，输出所有arr=0的数字即为关键数字～ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int arr[10000];bool cmp(int a, int b) &#123;return a &gt; b;&#125;int main() &#123; int k, n, flag = 0; cin &gt;&gt; k; vector&lt;int&gt; v(k); for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; v[i] = n; while (n != 1) &#123; if (n % 2 != 0) n = 3 * n + 1; n = n / 2; if (arr[n] == 1) break; arr[n] = 1; &#125; &#125; sort(v.begin(), v.end(), cmp); for (int i = 0; i &lt; v.size(); i++) &#123; if (arr[v[i]] == 0) &#123; if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; v[i]; flag = 1; &#125; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#x32;&#51;&#48;&#x34;&#x37;&#x30;&#x33;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1004","date":"2021-03-27T06:34:53.933Z","path":"2021/03/27/pat1004/","text":"1004. 成绩排名 (20) [查找元素]读⼊n名学⽣的姓名、学号、成绩，分别输出成绩最⾼和成绩最低学⽣的姓名和学号。 输⼊格式： 每个测试输⼊包含1个测试⽤例，格式为 第1⾏：正整数n 第2⾏：第1个学⽣的姓名 学号 成绩 第3⾏：第2个学⽣的姓名 学号 成绩 … … … 第n+1⾏：第n个学⽣的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的⼀个整数，这⾥保证在⼀组测试 ⽤例中没有两个学⽣的成绩是相同的。 输出格式： 对每个测试⽤例输出2⾏，第1⾏是成绩最⾼学⽣的姓名和学号，第2⾏是成绩最低学⽣的姓名和学号， 字符串间有1空格。 输⼊样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 分析：in = 101。遍历所有数据，如果当前学⽣数据的分数⽐最⼤值⼤，那么更新max的值，并将 他的姓名学号保存在maxname和maxnum中；如果当前学⽣数据的分数⽐最⼩值⼩，那么更新min的 值，并将他的姓名学号保存在minname和minnum中。最后输出maxname、maxnum、minname和 minnum～ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main() &#123; int n, max = -1, min = 101, score; cin &gt;&gt; n; string maxname, minname, maxnum, minnum, name, num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; num &gt;&gt; score; if (max &lt; score) &#123; max = score; maxname = name; maxnum = num; &#125; if (min &gt; score) &#123; min = score; minname = name; minnum = num; &#125; &#125; cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnum &lt;&lt; endl &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnum; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#x33;&#48;&#52;&#55;&#48;&#x33;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1003","date":"2021-03-27T06:16:00.089Z","path":"2021/03/27/pat1003/","text":"1003.我要通过！(20) [数学题]“答案正确”是⾃动判题系统给出的最令⼈欢喜的回复。本题属于PAT的“答案正确”⼤派送 —— 只要读⼊ 的字符串满⾜下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字⺟ A 组 成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字 ⺟ A 组成的字符串。 现在就请你为PAT写⼀个⾃动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输⼊格式： 每个测试输⼊包含1个测试⽤例。第1⾏给出⼀个⾃然数n (&lt;10)，是需要检测的字符串个数。接下来每 个字符串占⼀⾏，字符串⻓度不超过100，且不包含空格。 输出格式： 每个字符串的检测结果占⼀⾏，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。 输⼊样例： 1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例： 12345678YESYESYESYESNONONONO 分析： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本题解析：本题我做的时候是很很难的，即使第二次看也用了一个小时才搞明白，这道题按答案解析，主要在于理解题目，以及如果查找出a，b，c。 首先，题目给出了 3 个很有迷惑性的 “正确答案” 的条件，第 1 条，必须有仅有PAT三种字符很好理解，第二个为 XPATX，X 为空或 ’A‘，”AA“，”AAA“，··· 也好理解。关键第 3 个条件，如果aPbTc是正确的，那么aPbATca正确，也可以继续推第三代，第四代 ···，那么就需要考虑第一代原型是什么，而此时的第二个条件就为原型，且只有第二个条件为原型，这一定要理解，不然这题就废了。这样一看，原型也是有规律的，即b必须为一个A，且原型 a 的A和C的A个数相等，即原型为PAT,APATA,AAPATAA…再将每一个原型代入第三个条件进行推导会发现一个对所有字符串（满足条件1）都适用的规律，即c=a*b。接下来就好多了，一个for循环，判断s[i]==&#39;P&#39;和s[i]==&#39;T&#39;，找出 P 和 T 个数为 1。之后 y&gt;x ,这道题基本难点也讲完了。 1s.find(P)=x,s.dind(y)=y,y&gt;x 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#50;&#51;&#x30;&#52;&#55;&#48;&#51;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MySQL三种常见引擎","date":"2021-03-16T13:48:07.242Z","path":"2021/03/16/Mysql引擎/","text":"MySQL三种常见引擎 一.InnoDB存储引擎InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是 InnoDB。 InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。 InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。 InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。 二.MyISAM存储引擎MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。 MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。 MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。 三.MEMORY存储引擎MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 友链(本篇为理解，没有我写的成分)：https://blog.csdn.net/qq_41118581/article/details/90173117","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://example.com/tags/MYSQL/"}]},{"title":"pat1002","date":"2021-03-12T05:23:22.295Z","path":"2021/03/12/pat1002/","text":"1002. 写出这个数 (20) [字符串处理]读⼊⼀个⾃然数n，计算其各位数字之和，⽤汉语拼⾳写出和的每⼀位数字。 输⼊格式：每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。这⾥保证n⼩于10100。 输出格式： 在⼀⾏内输出n的各位数字之和的每⼀位，拼⾳数字间有1 空格，但⼀⾏中最后⼀个拼⾳数字后没有空 格。 输⼊样例： 11234567890987654321123456789 输出样例： 1yi san wu 分析：⽤string接收输⼊，string的每⼀位数字累加到sum⾥⾯，再将sum转化为string类型的num，对 num的每⼀位输出对应中⽂拼⾳～ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#x30;&#50;&#51;&#48;&#x34;&#55;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"pat1001","date":"2021-03-11T15:01:17.326Z","path":"2021/03/11/pat1001/","text":"1001. 害死⼈不偿命的(3n+1)猜想(15) [模拟]卡拉兹(Callatz)猜想： 对任何⼀个⾃然数n，如果它是偶数，那么把它砍掉⼀半；如果它是奇数，那么把(3n+1)砍掉⼀半。这 样⼀直反复砍下去，最后⼀定在某⼀步得到n=1。卡拉兹在1950年的世界数学家⼤会上公布了这个猜 想，传说当时耶鲁⼤学师⽣⻬动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学⽣们⽆⼼学 业，⼀⼼只证(3n+1)，以⾄于有⼈说这是⼀个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题⽬不是证明卡拉兹猜想，⽽是对给定的任⼀不超过1000的正整数n，简单地数⼀下，需要 多少步（砍⼏下）才能得到n=1？ 输⼊格式： 每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。 输出格式： 输出从n计算到1需要的步数。 输⼊样例： 13 输出样例： 15 分析：count从0开始统计需要的步数，(n % 2 != 0) 表示n为奇数，当n为奇数，就令n = 3*n+1；之后将 其砍掉⼀半，步数count+1，直到n == 1为⽌，最后输出count～ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int num=0,n; cin &gt;&gt;n; while(n!=1)&#123; if(n%2)n=(3*n+1); n=n/2; num++; &#125; cout&lt;&lt;num; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#x32;&#x33;&#48;&#x34;&#x37;&#48;&#x33;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据库学习之《mysql必知必会》","date":"2021-02-28T03:32:20.437Z","path":"2021/02/28/数据库学习之《mysql必知必会》/","text":"之前买了一本《MySQL必知必会》，最终拖拖拉拉用来一个星期的时间才把它看完，关于此书我觉得前面没有多大的难度，和《计算机网络自顶向下》 比起 还是很简单的，在我觉得比较困难的是存储过程，触发器的那几章，还有的是懂得了一门语言不是重点，重要的是要会使用和经常使用，这两点我还不行。下面我说说学习《MySQL必知必会》遇到的几个问题。 关于导入《MySQL必知必会》样例表的问题。一开始我并不打算使用这本书的数据库，后来发现有些知识点比较难懂于是又开始去寻找如何下载，下面是我的总结。 首先去网页下载两个SQL脚本文件，所需要获得和运行的一切东西都可以在https://forta.com/books/0672327120 上找到。 之后会有这个 点击自己选择一个名字 如text，则底下会出现一个这个 再接下来点击进入其中选择schemas 创建一个数据源，这一步和简单，你可以选择在命令行中进行，根据MySQL必知必会，选择名字crashcourse比较好， 然后再在菜单栏中，选择File-&gt;Open SQL Script，分别找到create.sql脚本，点击下图位置运行 对于populate.sql文件，重复导入脚本以及运行步骤即可 最后选中数据源并右键，选择Refresh All！！！（很重要） 今天学到了MySQL第十四章，对子查询这一步感到惊叹，能想出这样的方法— 真是老牛下蛋，牛逼坏了。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"用故事讲解md","date":"2021-02-28T03:27:14.304Z","path":"2021/02/28/用故事讲解Markdown/","text":"Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬 John Gruber 和 Aaron Swartz 。2010年，确定了其标准语法 CommonMark，2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站… 人人都应学Markdown1.1Markdown是什么​ Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬John Gruber和 Aaron Swartz。Makedown本质是一个标记语言，与HTML非常相似，兼容HTML。起初用于网络写作，现在记笔记，写文档，写README.md。2010年，确定了其标准语法 CommonMark，虽然有了定义但是标准语法的核心功能还是太少了，于是不断扩展，知道2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站。 1.2推荐使用​ 需要文字排版但无特殊要求 ​ 可以很方便的转换位Word 1.3如何学习使用Markdown 编写Markdown源码 &gt; 编辑器 &gt; 各种样式 语法学习 2.1基础语法所有标记符号都必须是半角标点符号 标题 语法：”# + 空格 + 标题内容” 行首插入 # “#”的个数=标题的等级 建议在#后面加个空格 支持最多六个标题 粗体和斜体 粗体，由两个*或两个_包裹 斜体，由一个*或一个_包裹 列表 有序列表，数字符号 + 英文句号 + 空格 + 列表内容 有序列表1 有序列表2 无序列表，-*/+/- + 空格 + 列表内容 无序列表1 无序列表2 嵌套列表，下层列表前按Tab键 有序列表和无序列表可以互相嵌套 分割线 三个或三个以上的_来标记 图片 语法，！[图片代替文字](图片地址) 图片替代文字不是必须，可以为空 图片地址，可以是本地路径，也可以是网络路径 本地图片支持相对路径和绝对路径两种 链接 文字链接 语法，[链接文字](链接地址) 链接过多后，可读性变差 引用链接 语法，[链接文字] [链接标记][链接标记]: 链接地址 链接标记可以是字母，数字，空格和标点符号 链接标记不区分大小写 定义的链接可任意位置放置，建议放在页尾 链接地址为网络地址需以http/https开头 网址链接 语法，&lt;url 或邮箱地址&gt; 无需以 http/https 开头 行内代码与代码块 行内代码：用包裹 代码块：以tab键或4个空格开头 1echo &quot;hello word&quot; 引用 语法，&gt; + 引用内容 在引用中可以嵌套引用 在引用中可以使用其他的 Markdown 语法 扩展语法2.1删除线 语法，~~被删除的文字~~ 2.2表情符号 语法，使用:包裹表情代码，:表情代码 表情符号代码，请参考webpagefx，或搜索Markdown emoji code 2.3表格 语法 1234|表头1|表头2|表头3||-|--|---||内容1|内容2|内容3||内容1|内容2|内容3| 表头1 表头2 表头3 内容1 内容2 内容3 内容1 内容2 内容3 2.4任务列表 语法，- + 空格 + [空格] + 空格 +文字内容 未勾选，-[] 已勾选，-[X/x] 语法说明 x可大写或小写，但有些编辑器不支持大写，故推荐使用小写的x 2.5围栏代码块 使用规范 使用连续的3个` 行内代码使用`包裹 1echo &#x27;hello word&#x27; 2.6锚点[锚点描述](#锚点名) 2.7内联数学公式 语法，$数学公式$ 快捷键，control + M $f(x,y)=\\frac{x}{y}$","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"使用命令窗口发送邮件","date":"2021-02-28T03:18:13.645Z","path":"2021/02/28/使用命令窗口发送邮件/","text":"学习笔记之前建立了一个hexo的博客，但是两个月没用出现了，结果出现了’使用子域名作为Github Pages的域名导致访问不了’的问题,对于才接触的我也没有解决的办法，只好重新安装了一个，以后如果再出现这个问题要解决掉，最近正在学计算机网络的应用层感觉用命令窗口发送qq邮箱很有趣，于是打算写一篇关于如何用命令窗口进行与邮件服务器进行链接的文章。我是使用win10 用qq邮箱进行发送的，如果以后有机会用163进行一次。 开启邮箱服务首先先开启qq邮箱的独立密码，进入设置-账户-独立密码，使邮箱开启POP3/SMTP，进入设置-账户-开启服务 接下来打开windows计算机上的telnet服务，打开控制面板-打功选中Telnet客户端、Telnet服务器，然后确定，等待完成 开始发送先打开命令窗口，输入 telnet smtp.qq.com 25,回复220，如果不是查看telnet服务是否开启 接着输入helo qq(后缀.com有时加有时不用)如果成功，服务器返回 250 ，不成功换一下 登录认证输入auth login，，会返回类似于：334 VXNlcm5hbWU6 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车回复334成功，其他失败 如果不知道可以 进行简单的代码运行得到1234import sun.misc.BASE64Encoder;public static void main(String[] args)&#123; System.out.println(Base64.encodeBase(&quot;xxxxx@qq.com&quot;.getBytes())); &#125; 输出即为。输入时如果太麻烦鼠标右键的话会直接粘贴，比较方便。 接下来输入独立密码的base64编码之后的字符串然后回车 回复235 Authentication successful成功，如果失败可能是因为独立密码失效 编写邮件输入 mail from:&lt;你自己的邮箱@qq.com&gt; 回车，成功返回250ok 输入 rcpt to:&lt;收件人邮箱，xxx@xxx.xxx&gt; 回车，成功返回250ok 输入 data 回车，回车后就可以开始写邮件内容了 输入 from：发件人名称 (可任意填) 输入 to：收件人名称(可任意填) 输入 subject：信件主题 在正文输入结束时输入一个.(英文)回车 服务器返回 250 Ok: queues as,表示邮件已经发送","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"翻墙(下)","date":"2021-02-28T02:08:16.679Z","path":"2021/02/28/翻墙(下)/","text":"3、域名劫持 Domain name hijacking一般情况下, 使用浏览器去连接互联网站点时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来。当使用翻墙软件时, 各种翻墙软件是采用在境外服务器和境内服务器之间建立一条安全隧道的方式，借助代理服务器对敏感数据进行加密访问。此时, 浏览器先向代理服务器发出请求, 再由代理服务器取回浏览器所需信息并传送给浏览器。摘自：典型翻墙软件的网络通信特征研究在中国知网查看：点击跳转 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 目的是无法访问目标网站，限制在特定的被劫持的网络范围内，是互联网攻击的一种方式。 DNS（Domain Name System，域名bai系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简介定义域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。 域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 原理：域名解析 (DNS) 的基本原理是把网络地址（域名，以一个字符串的形式）对应到真是计算机能够识别的网络地址（IP地址，比如216.239.53.99 这样的形式），以便计算机能够进一步通信，传递网址和内容等。 由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。 过程由于域名劫持只能在特定的网络范围内进行，所以范围外的域名服务器(DNS)能返回正常IP地址。攻击者正是利用此点在范围内封锁正常DNS的IP地址，使用域名劫持技术，通过冒充原域名以E-MAIL方式修改公司的注册域名记录，或将域名转让到其他组织，通过修改注册信息后在所指定的DNS服务器加进该域名记录，让原域名指向另一IP的服务器，让多数网民无法正确访问，从而使得某些用户直接访问到了恶意用户所指定的域名地址，其实施步骤如下： 一、获取劫持域名注册信息：首先攻击者会访问域名查询站点，通过MAKE CHANGES功能，输入要查询的域名以取得该域名注册信息。 二、控制该域名的E-MAIL帐号：此时攻击者会利用社会工程学或暴力破解学进行该E-MAIL密码破解，有能力的攻击者将直接对该E-MAIL进行入侵行为，以获取所需信息。 三、修改注册信息：当攻击者破获了E-MAIL后，会利用相关的MAKE CHANGES功能修改该域名的注册信息，包括拥有者信息，DNS服务器信息等。 四、使用E-MAIL收发确认函：此时的攻击者会在信件帐号的真正拥有者之前，截获网络公司回馈的网络确认注册信息更改件，并进行回件确认，随后网络公司将再次回馈成功修改信件，此时攻击者成功劫持域名。 缺点它不是很稳定，在某些网络速度快的地方，真实的IP地址返回得比窃持软件提供的假地址要快，因为监测和返回这么巨大的数据流量也是要花费一定时间的。 在网上查询域名的正确IP非常容易。一个是利用海外的一些在线IP地址查询服务，可以查找到网站的真实IP地址。在Google上搜索”nslookup”，会找到更多类似的服务。 4、流量限制流量限制是一个名词，指直接限制网络流量。 地位：最严厉的一种流量限制。 限制分类当前的虚拟主机主要分为三类流量限制: 一:流量限制 就是直接限制网络流量,这种限制通常是最严厉的一种流量限制,10个g的流量大体支持50人在线以内.当月流量超过后,在一个月内网站都不能正常访问了,解决办法是升级空间或加大流量! 假设一个网页的大小是10K Byte，那么访问这个网页一次就要产生10K的流量，1G流量就可以访问这个网页 1G/10K=100,000 次。 二:CPU限制 CPU限制看起来没有限IIS或网络流量,但由于每一个程序运行都需要一定的CPU配额,也是变相的流量限制,通常网页显示在线过多都是由于CPU限额过小引起的!通过刷新或15秒后可以得到暂时的正常运行,通常1%的CPU限额相当于20个IIS连接!这对于论坛空间很重要,论坛的CPU限额一旦过小就会不能正常运行! 三:IIS限制 IIS限制是现在用的最多的,也是被大多用户或主机商认可,是唯一宽松的流量限制,通常20个IIS就相当于1%CPU占用! 选择建议虚拟主机实际上没有不限流量的,总的可以分为以上三种方式,您如何选择,要看您的需要,如果您的程序占用CPU很少,是优化的程序可以选择限CPU的,这样您的在线就可以得到最大的发挥,如果您是初学者,或是论坛用户,或网站程序中有BBS,选择IIS限制或直接流量限制是一个好的选择!","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"科幻小说死亡开关在数据方面真的能实现吗？","date":"2021-02-25T05:32:58.542Z","path":"2021/02/25/科幻小说死亡开关在数据方面真的能实现吗？/","text":"每个人的生命只有一次，没人能说清死后的世界是什么样的。 作者 戴维·伊格尔曼（大卫·伊格曼）David Eagleman，生于1971年，美国神经科学家，斯坦福大学副教授，NeoSensory（似乎是一家植入传感器设备公司）的CEO。本篇《死亡开关》选自作者2009年出版的图书《死亡的故事》（Sum: Forty Tales from the afterlives）第二十五章，也曾在《Nature》上发表过（是的，Nature也会接收一些科普和科幻小说），严格来说——这篇与其说是科幻小说，倒不如说是一篇科幻随笔——可以看作是科幻小说的构思，大刘、韩松、吴岩等国内科幻大佬也出版过类似的科幻随笔。 总的来说看了一下，也就是他所写的《死亡的故事》中的一个随笔故事，篇幅几百字左右。里面讲了死亡开关，电脑每周会向你发出密码提示，确认你还活着，如果一段时间过去了，你却一直没有输入密码，那么电脑就会做出你已经死亡的推断，并自动将密码发送给第二号负责人。 人们利用死亡开关将瑞士银行的账号转交给自己的继承人，在争论中强辩到底，或是坦诚道出有生之年无法开口说出的秘密。 我感觉吧，根本不可能实现，信息的积累只会是越来越大，虽然现在是大数据时代，将来将会是巨大数据时代，但是数据的存储也是有限的，如果人们死后会进行数据的积累，那么数据只会越来越大，而且是叠加增长，先前拥有的死亡人的数据会增加，新来的也增加。现如今，世界人口已经增长到75亿人次。根据联合国公布z、的数字，现在的每秒出生的人数平均有5人次，死亡的人数每秒为2人次。也就是说世界人口每秒就增加3人次，那么一分钟就是增加180人次，一小时也就是增加10800人次，以此类推的话，一年大概要增加将近1亿人次。接下来我们再算算死亡人数，每秒2人次，一分钟就是120人次，一小时就是7200人次，同样以此类推，每年死亡的人口大概在6400万人次。一个人只保留1Mb的数据，一年存储数据为64000000MB，64000GB，64T。 计算机报上看到荷兰银行的20个数据中心有大约7PB磁盘和超过20PB的磁带存储，而且每年50%~70%存储量的增长，计算一下27PB大约为 500个64TB的大小，也就是500个第一年开始进行死亡开关这场游戏的数据。 由于是叠加增长，第一年会产生一个64TB 第二年会是第一年产生的，加上新产生的总和，2+1=3 第三年3+2+1=6 第四年4+3+2+1=10 这里我用Java写了一个测试代码，看看500个64TB能够几年使用完 12345678910111213public class HelloWorld &#123; public static void main(String []args) &#123; int num=0; for(int i = 0;;i++)&#123; num = num + i; if(num&gt;500)&#123; System.out.println(i); break; &#125; &#125; &#125;&#125;结果：32 也就是用了32年会将荷兰银行的这些数据存储完，但之后的数据存储会持续叠加上升，为无线等差数列和 等差数列和的函数为n^2，之后看看第二个荷兰银行数据存储会多久存满，结果是第45年，也就是用了13年就会存满，之后会越来越少，等到有一天，n=500的时候，也就会是每天将会存储一个荷兰银行的20个数据中心。 综上所述，我觉得这是一个不现实的问题。 mobi文件mobi是亚马逊的私有格式，目前市面上的 mobi 文件大部分是来自两种途径：epub、pdf 或者 txt 转换成的 mobi，从 Amazon 商店流出来的 mobi。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"翻墙(上)","date":"2021-02-25T02:03:23.942Z","path":"2021/02/25/翻墙(上）/","text":"科普所谓翻墙，是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问。境外公司曾发布几款突破网络封锁以访问海外敏感网站或邮件的翻墙软件。由于此类软件不断升级，要实现对该类软件行为的监测或封锁就显得尤为困难和重要，如果能够在网关处将数据截获，分析数据包的行为特征，将部分数据包进行劫持还原，这将对公安机关的调查取证起到积极的作用。 该解释引自《典型翻墙软件的网络通信特征研究》，作者官国静，此外我还会讲解一下它的这篇文章 由于内容过多下半部分放在了下一篇，想了解关于软件和caj文件解释的可以看看，以下定义摘抄自百度，为了是能够自己了解所以写在了下面，觉得不够详细的可以百度搜索。 1、ip 封锁（IP Block）ip 封锁是指防火墙维护一张 ip 黑名单，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。 缺点：采用黑名单禁止模式有一定的漏洞 目的：屏蔽对目的主机的访问 提供服务的服务器亦可能使用类似的方法，以控制可存取的范围，通常可设定白名单只允许某个网段或某个国家的 ip 存取，也可设定黑名单以禁止某网段或某些国家的 ip 存取。例如一些线上游戏营运商或线上影片服务为确保本国玩家的权益及版权限制，只允许本国的 ip 连线。 缺点这种对被封禁的网站采用黑名单而不是对被允许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在。 常见情况封锁 ip — 当计算机或系统受到外部攻击时，管理员可以通过屏蔽攻击源 ip 地址来抵御攻击。通过防火墙和路由器配置，可以封锁某个 ip，禁止与其连接，从而达到抵御攻击的作用。但事实上大多数的攻击，管理员根本没有时间反应，一般在反应过来后系统已经崩溃。 1、多次发布谩骂、侮辱言论； 2、发布大量商业广告、或无用废帖（即 “爆吧” ） 3、其他严重违反贴吧规定的情况。 2、内容过滤content filter内容过滤是对网络内容进行监控，防止某些特定内容在网络上进行传输的技术。主要实现有 软件(点击跳转)和硬件两种。 性质为非营利性，开始启用时间为1995年，含义为对网络内容进行监控。 解释在因特网上，内容过滤（content filtering），也被称作信息过滤（information filtering），是将Web网页或电子邮件中令人讨厌的信息屏蔽和拒绝存取或使用的技术。内容过滤被公司或家用电脑拥有者用作网络防火墙的一部分，尤其是父母可以为他们的孩子屏蔽掉那些不想让其访问的内容。 内容过滤通常使用特征字符串进行工作，如果内容和字符串相符，则会把这部分内容屏蔽掉。被过滤的典型是那些带有色情、暴力、仇恨倾向的内容，==内容过滤程序的批评者指出，它可能在无形中将想要的内容同时过滤掉。== 内容过滤和提供这项服务的产品分为网页过滤——屏蔽网站或页面的信息、邮件过滤——屏蔽电子邮件中的垃圾信息或其它令人讨厌的信息。 方法简介（先软件后硬件）软件过滤方式内容过滤的软件方式主要是一项1995年开始启用的技术标准“Internet内容选择平台”，它是由一家非营利性Internet开放商联盟――万维网联盟(W3C)为解除1995年年末出台的美国《通讯正派条例》(该条例于1997年被否决)的威胁而推出的。Internet内容选择平台的设计理念是鼓励自由表达、保护未成年人的权益，把工具交给父母或其他人，让他们为自己和自己的孩子过滤内容。 这类工具同时还可以将孩子或雇员送出的不恰当信息滤掉，比如家庭地址、信用卡号码、或机密的公司信息等等。 软件过滤主要使用关键词匹配的方式，将特定内容移除。随着互联网应用的开展，软件过滤无法处理飞速增长的流量，于是硬件过滤应运而生。 硬件过滤方式硬件过滤方式就是将关键词匹配功能集成在控制有大量流量的交换机或路由器中，以对网络中的流量进行监控。 目的为防止暴力、恐怖、色情、颠覆主义等内容在互联网上传播，维护网络安全，净化网络，为广大网民提供绿色上网环境。 软件指按照特定顺序组织的计算机数据和指令的集合 软件（中国大陆及香港用语，台湾称作软体，英文：software）是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。软件并不只是包括可以在计算机（这里的计算机是指广义的计算机）上运行的电脑程序，与这些电脑程序相关的文档一般也被认为是软件的一部分。简单的说软件就是程序加文档的集合体。另也泛指社会结构中的管理系统、思想意识形态、思想政治觉悟、法律法规等等。 开发语言为Java、C/C++、Basic、python等 应用类别系统软件、应用软件等 定义国标中对软件的定义为：与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。 其它定义： 1．运行时，能够提供所要求功能和性能的指令或计算机程序集合。 2．程序能够满意地处理信息的数据结构。 3．描述程序功能需求以及程序如何操作和使用所要求的文档。 以开发语言作为描述语言，可以认为：软件=程序+数据+文档 特点1、无形的，没有物理形态，只能通过运行状况来了解功能、特性、和质量 2、软件渗透了大量的脑力劳动，人的逻辑思维、智能活动和技术水平是软件产品的关键 3、软件不会像硬件一样老化磨损，但存在缺陷维护和技术更新 4、软件的开发和运行必须依赖于特定的计算机系统环境，对于硬件有依赖性，为了减少依赖，开发中提出了软件的可移植性 5、软件具有可复用性，软件开发出来很容易被复制，从而形成多个副本 分类应用类别按应用范围划分，一般来讲软件被划分为==系统软件==、==应用软件==和==介于这两者之间的中间件==。 系统软件 系统软件为计算机使用提供最基本的功能，可分为操作系统和支撑软件，其中操作系统是最基本的软件。 系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。 1．操作系统是一管理计算机硬件与软件资源的程序，同时也是计算机系统的内核与基石。操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统交互的操作接口。 2．支撑软件是支撑各种软件的开发与维护的软件，又称为软件开发环境（SDE）。它主要包括环境数据库、各种接口软件和工具组。著名的软件开发环境有IBM公司的Web Sphere,微软公司的等。 包括一系列基本的工具（比如编译器、数据库管理、存储器格式化、文件系统管理、用户身份验证、驱动管理、网络连接等方面的工具）。 应用软件 系统软件并不针对某一特定应用领域，而应用软件则相反，不同的应用软件根据用户和所服务的领域提供不同的功能。 应用软件是为了某种特定的用途而被开发的软件。它可以是一个特定的程序，比如一个图像浏览器。也可以是一组功能联系紧密，可以互相协作的程序的集合，比如微软的Office软件。也可以是一个由众多独立程序组成的庞大的软件系统，比如数据库管理系统。 如今智能手机得到了极大的普及，运行在手机上的应用软件简称手机软件。所谓手机软件就是可以安装在手机上的软件，完善原始系统的不足与个性化。随着科技的发展，手机的功能也越来越多，越来越强大。不是像过去的那么简单死板,发展到了可以和掌上电脑相媲美。手机软件与电脑一样，下载手机软件时还要考虑你购买这一款手机所安装的系统来决定要下相对应的软件。手机主流系统有以下：[Windows Phone](https://baike.baidu.com/item/Windows Phone)、Symbian、iOS、Android。 授权类别不同的软件一般都有对应的软件授权，软件的用户必须在同意所使用软件的许可证的情况下才能够合法的使用软件。从另一方面来讲，特定软件的许可条款也不能够与法律相违背。 依据许可方式的不同，大致可将软件区分为几类： 专属软件：此类授权通常不允许用户随意的复制、研究、修改或散布该软件。违反此类授权通常会有严重的法律责任。传统的商业软件公司会采用此类授权，例如微软的Windows和办公软件。专属软件的源码通常被公司视为私有财产而予以严密的保护。 自由软件：此类授权正好与专属软件相反，赋予用户复制、研究、修改和散布该软件的权利，并提供源码供用户自由使用，仅给予些许的其它限制。以Linux、Firefox 和OpenOffice 可做为此类软件的代表。 共享软件：通常可免费的取得并使用其试用版，但在功能或使用期间上受到限制。开发者会鼓励用户付费以取得功能完整的商业版本。根据共享软件作者的授权，用户可以从各种渠道免费得到它的拷贝，也可以自由传播它。 免费软件：可免费取得和转载，但并不提供源码，也无法修改。 公共软件：原作者已放弃权利，著作权过期，或作者已经不可考究的软件。使用上无任何限制。 相关概念开发流程软件开发是根据用户要求建造出软件系统或者系统中的软件部分的过程。软件开发是一项包括需求捕捉，需求分析，设计，实现和测试的系统工程。软件一般是用某种程序设计语言来实现的。通常采用软件开发工具可以进行开发。 软件开发流程即Software development process。 软件设计思路和方法的一般过程，包括设计软件的功能和实现的算法和方法、软件的总体结构设计和模块设计、编程和调试、程序联调和测试以及编写、提交程序。 1 相关系统分析员和用户初步了解需求，然后列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。 2 系统分析员深入了解和分析需求，根据自己的经验和需求做出一份文档系统的功能需求文档。这次的文档会清楚例用系统大致的大功能模块，大功能模块有哪些小功能模块，并且还例出相关的界面和界面功能。 3 系统分析员和用户再次确认需求。 4 系统分析员根据确认的需求文档所例用的界面和功能需求，用迭代的方式对每个界面或功能做系统的概要设计。 5 系统分析员把写好的概要设计文档给程序员，程序员根据所例出的功能一个一个的编写。 6 测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能，然后验收。 软件工程师一般指从事软件开发职业的人。软件工程师10余年来一直占据高薪职业排行榜的前列，作为高科技行业的代表，技术含量很高，职位的争夺也异常激烈。软件开发是一个系统的过程，需要经过市场需求分析、软件代码编写、软件测试、软件维护等程序。软件开发工程师在整个过程中扮演着非常重要的角色，主要从事根据需求开发项目软件工作。 法律保护计算机软件作为一种知识产品，其要获得法律保护，必须具备以下必要条件： （一）原创性。即软件应该是开发者独立设计、独立编制的编码组合。 （二）可感知性。受保护的软件须固定在某种有形物体上，通过客观手段表达出来并为人们所知悉。 （三）可再现性。即把软件转载在有形物体上的可能性。 著作权归属根据《计算机软件保护条例》第10条的规定，计算机软件著作权归属软件开发者。因此，确定计算机著作权归属的一般原则是“谁开发谁享有著作权”。软件开发者指实际组织进行开发工作，提供工作条件完成软件开发，并对软件承担责任的法人或者非法人单位，以及依靠自己具有的条件完成软件开发，并对软件承担责任的公民。 载体软件的载体可以是硬盘、光盘、U盘、软盘等数据存储设备。 使用许可不同的软件一般都有对应的软件授权，软件的使用者必须在同意所使用软件的许可证的情况下才能够合法的使用软件。 依据许可方式的不同，大致可将软件区分为几类： 专属软件、自由软件、共享软件、免费软件、公共软件。 生命周期软件生命周期是指从软件定义、开发、使用、维护到报废为止的整个过程，一般包括问题定义、可行性分析、需求分析、总体设计、详细设计、编码、测试和维护。 问题定义就是确定开发任务到底“要解决的问题是什么”，系统分析员通过对用户的访问调查，最后得出一份双方都满意的关于问题性质、工程目标和规模的书面报告。 可行性分析就是分析上一个阶段所确定的问题到底“可行吗”，系统分析员对系统要进行更进一步的分析，更准确、更具体地确定工程规模与目标，论证在经济上和技术上是否可行，从而在理解工作范围和代价的基础上，做出软件计划。 需求分析即使对用户要求进行具体分析，明确“目标系统要做什么”，把用户对软件系统的全部要求以需求说明书的形式表达出来。 总体设计就是把软件的功能转化为所需要的体系结构，也就是决定系统的模块结构，并给出模块的相互调用关系、模块间传达的数据及每个模块的功能说明。 详细设计就是决定模块内部的算法与数据结构，也是明确“怎么样具体实现这个系统”。 编码就是选取适合的程序设计语言对每个模板进行编码，并进行模块调试。 测试就是通过各种类型的测试使软件达到预定的要求。 维护就是软件交付给用户使用后，对软件不断查错、纠错和修改，使系统持久地满足用户的需求。 软件的生命周期也可以分为3个大的阶段，分别是计划阶段、开发阶段和维护阶段。 软件生命周期模型软件生命周期模型也称为软件过程模型，反映软件生存周期各个阶段的工作如何组织、衔接，常用的有瀑布模型、原型模型、螺旋模型、增量模型、喷泉模型，还有建造-修补模型、MSF过程模型、快速原型模型。 [1] 常见的软件生命周期模型瀑布模型 有时也称为V模型，它是一种线型顺序模型，是项目自始至终按照一定顺序的步骤从需求分析进展到系统测试直到提交用户使用，它提供了一种结构化的、自顶向下的软件开发方法，每阶段主要工作成果从一个阶段传递到下一个阶段，必须经过严格的评审或测试，以判定是否可以开始下一阶段工作，各阶段相互独立、不重叠。瀑布模型是所有软件生命周期模型的基础。 [1] 原型+瀑布模型 原型模型本身是一个迭代的模型，是为了解决在产品开发的早期阶段存在的不确定性、二义性和不完整性等问题，通过建立原型使开发者进一步确定其应开发的产品，使开发者的想象更具体化，也更易于被客户所理解。原型只是真实系统的一部分或一个模型，完全可能不完成任何有用的事情，通常包括抛弃型和进化型两种，抛弃型指原型建立、分析之后要扔掉，整个系统重新分析和设计；进化型则是对需求的定义较清楚的情形，原型建立之后要保留，作为系逐渐增加的基础，采用进化型一定要重视软件设计的系统性和完整性，并且在质量要求方面没有捷径，因此，对于描述相同的功能，建立进化型原型比建立抛弃型原型所花的时间要多。原型建立确认需求之后采用瀑布模型的方式完成项目开发。 [1] 增量模型 与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 一些大型系统往往需要很多年才能完成或者客户急于实现系统，各子系统往往采用增量开发的模式，先实现核心的产品，即实现基本的需求，但很多补充的特性(其中一些是已知的，另外一些是未知的)在下一期发布。增量模型强调每一个增量均发布一个可操作产品，每个增量构建仍然遵循设计-编码-测试的瀑布模型。 [1] 迭代模型 早在20世纪50年代末期，软件领域中就出现了迭代模型。最早的迭代过程可能被描述为“分段模型”。迭代，包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。所以，在某种程度上，开发迭代是一次完整地经过所有工作流程的过程：（至少包括）需求工作流程、分析设计工作流程、实施工作流程和测试工作流程。 实质上，它类似小型的瀑布式项目。所有的阶段（需求及其它）都可以细分为迭代。每一次的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 [1] 开发语言O语言O语言是一款中文计算机语言（或称套装：O汇编语言、O中间语言、O高级语言） Java语言作为跨平台的语言，可以运行在Windows和Unix/Linux下面，长期成为用户的首选。自JDK6.0以来，整体性能得到了极大的提高，市场使用率超过20%。可能已经达到了其鼎盛时期了，不知道后面能维持多长时间。 易语言（E语言）易语言是一个自主开发，适合国情，不同层次不同专业的人员易学易用的汉语编程语言。易语言降低了广大电脑用户编程的门槛，尤其是根本不懂英文或者英文了解很少的用户，可以通过使用本语言极其快速地进入Windows程序编写的大门。 [2] C/C++语言以上2个作为传统的语言，一直在效率第一的领域发挥着极大的影响力。像Java这类的语言，其核心都是用C/C++写的。在高并发和实时处理，工控等领域更是首选。 习语言习语言即中文版的C语言 Basic美国计算机科学家约翰·凯梅尼和托马斯·库尔茨于1959年研制的一种“初学者通用符号指令代码”，简称BASIC。由于BASIC语言易学易用，它很快就成为流行的计算机语言之一。 PHP同样是跨平台的脚本语言，在网站编程上成为了大家的首选，支持PHP的主机非常便宜，PHP+Linux+MySQL+Apache的组合简单有效。 Perl脚本语言的先驱，其优秀的文本处理能力，特别是正则表达式，成为了以后许多基于网站开发语言(比如PHP,Java,C#)的这方面的基础。 PythonPython是一种面向对象的解释性的计算机程序设计语言，也是一种功能强大而完善的通用型语言，已经具有十多年的发展历史，成熟且稳定。Python 具有脚本语言中最丰富和强大的类库，足以支持绝大多数日常应用。 这种语言具有非常简捷而清晰的语法特点，适合完成各种高层任务，几乎可以在所有的操作系统中运行。 基于这种语言的相关技术正在飞速的发展，用户数量急剧扩大，相关的资源非常多。 C#C#是微软公司发布的一种面向对象的、运行于NET Framework之上的高级程序设计语言，并定于在微软职业开发者论坛(PDC)上登台亮相。C#是微软公司研究员Anders Hejlsberg的最新成果。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、界面，与Java几乎同样的语法，和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM(组件对象模型)是直接集成的，而且它是微软公司.NET Windows网络框架的主角。 JavaScriptJavaScript是一种由Netscape的LiveScript发展而来的脚本语言，主要目的是为了解决服务器终端语言，比如Perl，遗留的速度问题。当时服务端需要对数据进行验证，由于网络速度相当缓慢，只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。 Ruby一种为简单快捷面向对象编程（面向对象程序设计）而创的脚本语言，由日本人松本行弘（まつもとゆきひろ，英译：Yukihiro Matsumoto，外号matz）开发，遵守GPL协议和Ruby License。Ruby的作者认为Ruby &gt; (Smalltalk + Perl) / 2，表示Ruby是一个语法像Smalltalk一样完全面向对象、脚本执行、又有Perl强大的文字处理功能的编程语言。 Fortran在科学计算软件领域，Fortran曾经是最主要的编程语言。比较有代表性的有Fortran 77、Watcom Fortran、NDP Fortran等。 Objective C这是一种运行在苹果公司的[Mac OS X](https://baike.baidu.com/item/Mac OS X/470629)，iOS操作系统上的语言。这两种操作系统的上层图形环境，应用程序编程框架都是使用该语言实现的。随著iPhone,iPad的流行，这种语言也开始在全世界流行。 PascalPascal是一种计算机通用的高级程序设计语言。Pascal的取名是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal。它由瑞士Niklaus Wirth教授于六十年代末设计并创立。Pascal语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。 SwiftSwift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C共同运行于[Mac OS](https://baike.baidu.com/item/Mac OS)和iOS平台，用于搭建基于苹果平台的应用程序。 caj文件caj文件是中国期刊网提供的一种文件格式,现在网络的很多文献都采用了 caj 文件格式。在浏览 caj 格式文件的时候,你也必须使用相应的阅读器才可以,通用的caj阅读器为CAJViewer。","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"日记","date":"2021-02-24T07:59:00.706Z","path":"2021/02/24/时间管理法/","text":"每月小结，看看自己这个月用于什么的时间是多少，如上课，认真学习，玩 同时年度总结，对自己本月进行反思 记录尽可能准确的记录时间被用在了哪里， 统计以每周每个月或每年为单位，统计每件事情用了多少时间 分析，分析在过去这段时间里，哪些运用时间的方法是高效的，哪些是可以改进的 反馈根据自己分析得出的结论做出改变，让自己更加有效的利用时间 记录–》统计–》分析–》反馈要点： 首先是记录的及时性，不要连续做了好几件事情再回过头来一件一件的记，要一事一记，同时要保持时间记录的真实性、准确性。要保证记录的误差不要大于15分钟就可以了。 其次，选择记录的时间段要相对固定并且有代表性，如果你要记录自己在某项相对重复的工作上花费了多少时间，最好是每天固定的时间段来做这项工作，人在固定时段的状态是相对稳定的。 最后你还要根据记录情况，及时调整时间分配计划，在每周或每月总结的时候要找出上一段计划当中实际消耗时间与计划消耗时间之间的差额，然后结合自己的工作效率重新分配下一时间段。 坚持是在时间管理方面必不可少的品质。 时间管理法的五大法则：恰当运用这五大法则，可以让时间管理法不会成为你的一种镣铐，而是成为运用自如的乐器。 不要为了完成工作而放弃自己的兴趣爱好。对作者而说，不论工作有多困难，任务有多繁重，只要他愿意，就一定能在自己预估的时间里按部就班的完成，但事实上，作者并不是像我们想象中的那么从一而终，很多时候它的本质工作，是要为兴趣让路的。没有什么比满足自己的求知欲和好奇重要，与其被迫在完成工作和满足好奇心之间做出选择，不如索性大方拒绝那些必须完成的任务而选择兴趣。 不接受紧急的任务。因为接受紧急的任务可能会因为由于时间仓促而无法做到尽善其美，更重要的是，它会打破你原有的节奏，引起一系列的连锁反应，最后反而是更费时间的。 一累了就马上停止工作去休息。 保证睡眠时间，每天10小时左右。没有这条守则，时间管理方法将永远是纸上谈兵。作者认为，休息是需要规划、记录、安排再规划的，因为这种方法并不是一种间歇性的方法，而是一种长期性的计划，这是一种很容易让人产生压迫感的方法，如果睡的不好，没有足够的休息，当你面对一张慢慢当当的计划表的时候，很容易陷入被计划牵着鼻子走的恶训循环，一旦陷入这样的恶训循环，就离放弃不远了。 把累人的工作和愉快的工作结合在一起。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"搭建博客以及优化","date":"2021-02-23T09:09:39.356Z","path":"2021/02/23/搭建博客以及优化/","text":"不会吧不会吧，难道你还没有属于自己的博客？ 目录不显示文章标题，tags标签怎么加，文章截断 标签这个东西可以在我们写完一个博客文章之后在最上方添加，这样比较方便，对应 yilia 主题你会发现没有这个你的文章没有标题，是空白的。 还有一个是文章截断问题，默认是主页显示整篇的文章，写完文章后，用记事本打开，再需要的地方加上截断代码 &lt;!--more--&gt; 图片加载-采用 lazyload 图片懒加载 图片加载只需要两步 配置，在hexo目录下，执行以下命令，插入模块 1npm install hexo-lazyload-image --save 然后在你的 hexo 目录的配置文件 _config.xml 中添加配置： 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片. loadingImg - 图片未加载时的代替图 不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes\\next\\source\\images 目录下, 然后引用时: loadingImg: /images/图片文件名 借鉴的有简书的这位好友，很感谢带给我的帮助，帮我处理了很多日常写博客的问题https://www.jianshu.com/p/f6f19b02c661 还有就是新手们怎么搭建博客，这里推荐一位好友www.codesheep.cn","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]