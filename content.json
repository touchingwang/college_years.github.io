[{"title":"Java入门","date":"2021-04-10T01:32:34.887Z","path":"2021/04/10/Java入门/","text":"JavaSE故事：Java帝国的诞生 一场旷日持久的战争 C&amp;C++1972年C诞生 贴近硬件，运行极快，效率极高。 操作系统，编译器，数据库，网络系统等 指针和内存管理 1982年C++诞生 面向对象 兼容C 图形领域、游戏等 反抗我们要建立一个新的语言： 语法有点像C 没有指针 没有内存管理 真正的可移植性，编译一次，到处运行 面向对象 类型安全 高质量和的类库 …… Java初生 1995年的网页简单而粗糙，缺乏互动性。 图形界面的程序（Applet） Bill Gates说：这是迄今为止设计的最好的语言！ Java 2 标准版(J2SE)：去占领桌面 Java 2 移动版(J2ME)：去占领手机 Java 2 企业版(J2EE)：去占领服务器 大量的巨头加入 Java发展 他们基于Java开发了巨多的平台，系统，工具 构建工具：Ant，Maven，Jekins 应用服务器：Tomcat，Jetty，Jboss，Websphere，weblogic Web开发：Struts，Spring，Hibernate，myBatis 开发工具：Eclipse，Netbean，intellij idea，Jbuilder …… 2006：Hadoop（大数据领域） 2008：Android（手机端） ==一个伟大的帝国诞生了== Java特性和优势 简单性 面向对象 可移植性 高性能 分布式 动态性 多线程 安全性 健壮性 Java三大版本 Write Once、Run Anywhere JavaSE：标准版(桌面程序，控制台开发……) JavaME：嵌入式开发(手机，小家电……) JavaEE(web端，服务器开发……) JDK JRE JVM JDK：Java Development Kit JRE：Java Runtime Enviroment JVM：Java Virtual Machine 搭建开发环境 JDK下载与安装 卸载JDK 删除 java 的安装目录 删除JAVA_HOME 删除 path 下关于java的目录 java -version 安装JDK 百度搜索JDK8，找到下载地址 同意协议 下载电脑对应的版本 双击安装JDK 记住安装的路径 配置环境变量 环境变量添加JAVA_HOME 配置 path 变量 测试JDK是否安装成功 配置环境变量 环境变量添加JAVA_HOME 配置 path 变量 JDK目录介绍 HelloWorld及简单语法规则 Notepad++安装和使用 HelloWorld 新建一个文件夹，存放代码 新建一个java文件 文件后缀名为.java Hello.java 系统可能没有显示文件后缀名，我们需要手动打开 编写代码 12345public class Hello()&#123; public static void main(String args[])&#123; System.out.print(&quot;Hello,World!&quot;); &#125;&#125; 编译javac Hello.java，会生成一个 class 文件 运行 class 文件，java hello 可能会遇到的问题 单词大小写不能出现问题 尽量使用英文 文件名和类型保持一致 符号);使用了中文 Java程序运行机制 编译型 解释型 程序运行机制","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"SpringMVC执行原理","date":"2021-04-08T09:35:46.512Z","path":"2021/04/08/SpringMVC三幻神/","text":"什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 中心控制器Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类) SpringMVC执行原理 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 12345678910111213141516171819package com.kuang.controller; import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 1&lt;body&gt;$&#123;msg&#125;&lt;/body&gt; 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置版权声明：本文为CSDN博主「狂神说」的原创文章，遵循CC 4.0 BY-SA版权协议。原文链接：https://blog.csdn.net/qq_33369905/article/details/106647319","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"Java中Calendar类的常用方法","date":"2021-04-07T04:55:52.305Z","path":"2021/04/07/Calendar类/","text":"Java中Calendar类的常用方法认识Calendar可分为两种，一种入门简单了解的，另一种为深入了解基础，个人查找的。 Calendar基础了解获取时间(get)123456789// 使用默认时区和语言环境获得一个日历 Calendar cal = Calendar.getInstance(); // 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1 sout(&quot;年:&quot; + cal.get(Calendar.YEAR)); sout(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1)); sout(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH)); sout(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY)); sout(&quot;分:&quot; + cal.get(Calendar.MINUTE)); sout(&quot;秒:&quot; + cal.get(Calendar.SECOND)); 结果为： 123456年:2021月:4日:7时:11分:32秒:24 设置时间(set)月份的下标从 0 开始，设置时同样需要注意，比如我们设置为 4 月 30 日除夕当晚的倒计时的最后一秒： 2021-04-30 23:59:59 12345Calendar cal = Calendar.getInstance();// 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1// cal.set(year, month, date, hourOfDay, minute, second);cal.set(2021, 4, 30, 23, 59, 59);System.out.println(cal.getTime(); 细节：如果设置的为1月32号，则时间计算会自动进行换算，跳到2月1号，对于其他换算也是如此。 时间计算(add)add方法： 比如在金今天(4/7)当晚最后一秒，add 一秒： 12345Calendar cal = Calendar.getInstance();System.out.println(cal.getTime());cal.set(2021, 4, 7, 23, 59, 59);cal.add(Calendar.SECOND, 1);System.out.println(cal.getTime()); 打印时间结果如下，日期会自动进入下一天： 12Wed Apr 07 11:39:16 CST 2021Sat May 08 00:00:00 CST 2021 再比如 1 月 30 号的时候，月份加一，会出现怎样结果：(已知2月没有30号) 12345Calendar cal = Calendar.getInstance();cal.set(2021, 0, 31, 8, 0, 0);System.out.println(cal.getTime());cal.add(Calendar.MONTH,1);System.out.println(cal.getTime()); 运行结果： 12Sun Jan 31 08:00:00 CST 2021Sun Feb 28 08:00:00 CST 2021 说明 add 月份时，会将不存在的日期归为当月日历的最后一天。 学到这对一般的日历用法够了，想继续深入了解可以参照下面 Calendar深入了解项目当中，我们经常会涉及到对时间的处理。Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，而是更推荐使用 Calendar 类进行时间和日期的处理。 原理简介Calendar类被abstract所修饰，说明不能通过new的方式来获得实例，对此，Calendar提供了一个类方法getInstance，以获得此类型的一个通用的对象，getInstance方法返回一个Calendar对象（该对象为Calendar的子类对象），其日历字段已由当前日期和时间初始化： 1Calendar cal = Calendar.getInstance(); 之所以说返回的是Calendar的子类对象，是因为每个国家地区都有自己的一套日历算法，比如西方国家的第一个星期大部分为星期日，而中国则为星期一。我们来看看getInstance方法获取实例的源码： 1234public static Calendar getInstance()&#123; return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));&#125; 其中参数TimeZone.getDefaultRef()代表的就是时区，createCalendar方法就是根据不同国家地区返回对应的日期子类。 常用方法为了更加便捷的对日期进行操作，Calendar类对YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 时间获取123456789101112131415161718192021222324252627282930313233343536373839404142434445Calendar cal = Calendar.getInstance(); //Calendar类的实例化SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //时间的格式化System.out.println(cal.getTime()); //date=Wed Apr 07 12:45:14 CST 2021System.out.println(sdf.format(cal.getTime())); //nowTime=2021-04-07 12:45:14//当前日：两种方法等价int day_of_month = cal.get(Calendar.DAY_OF_MONTH); //day_of_month=97int day = cal.get(Calendar.DATE); //day=97//获取当月day的最大值！！int max_day_of_month = cal.getActualMaximum(Calendar.DAY_OF_MONTH);System.out.println(max_day_of_month);//当前时钟：24小时制int hour24 = cal.get(Calendar.HOUR_OF_DAY);System.out.println(hour24);//当前时钟：12小时制int hour12 = cal.get(Calendar.HOUR);System.out.println(hour12);//星期几：用数字（1~7）表示（星期日~星期六），使用时通常会-1int day_of_week = cal.get(Calendar.DAY_OF_WEEK) - 1;System.out.println(day_of_week);//上午-0；下午-1int amOrPm = cal.get(Calendar.AM_PM);System.out.println(amOrPm);//当前年的第几周int week_of_year = cal.get(Calendar.WEEK_OF_YEAR);System.out.println(week_of_year);//当前月的星期数int week_of_month = cal.get(Calendar.WEEK_OF_MONTH);System.out.println(week_of_month);//当前月中的第几个星期int day_of_week_in_month = cal.get(Calendar.DAY_OF_WEEK_IN_MONTH);System.out.println(day_of_week_in_month);//当前年的第几天int day_of_year = cal.get(Calendar.DAY_OF_YEAR);System.out.println(day_of_year);int day_of_year = cal.get(Calendar.DAY_OF_YEAR); //day_of_year=27 设置时间与时间计算基础够了 小结 Calendar 类区分不同的时区输出时间格式； Calendar 类的计算优势非常明显，不需要考虑每个月有多少天，非常便利。举个例子：如果要计算昨天的日期，你要考虑昨天是不是某月的最后一天，某年的最后一天，要考虑平年、闰年，考虑上个月是31天，30天，29天还是28天…但是Calendar类省去了你所有的顾虑，直接减1天就可以输出正确的日期了； 参考链接：https://blog.csdn.net/weixin_44259720/article/details/86669177、https://blog.csdn.net/yx0628/article/details/79317440","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"pat1009","date":"2021-04-05T15:05:29.347Z","path":"2021/04/05/pat1009/","text":"1009. 说反话 (20) [字符串处理]给定⼀句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输⼊格式： 测试输⼊包含⼀个测试⽤例，在⼀⾏内给出总⻓度不超过80的字符串。字符串由若⼲单词和若⼲空格 组成，其中单词是由英⽂字⺟（⼤⼩写有区分）组成的字符串，单词之间⽤1个空格分开，输⼊保证句 ⼦末尾没有多余的空格。 输出格式： 每个测试⽤例的输出占⼀⾏，输出倒序后的句⼦。 输⼊样例： 1Hello World Here I Come 输出样例： 1Come I Here World Hello 分析：将输⼊的每个单词s都分别v.push(s)压⼊栈中，再输出栈顶v.top()，然后将栈顶元素弹出 v.pop()，直到栈空为⽌～ 123456789101112131415#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;string&gt; v; string s; while(cin &gt;&gt; s) v.push(s); cout &lt;&lt; v.top(); v.pop(); while(!v.empty()) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; v.top(); v.pop(); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#x33;&#x30;&#x34;&#x37;&#x30;&#x33;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1008","date":"2021-04-05T15:05:29.343Z","path":"2021/04/05/pat1008/","text":"1008. 数组元素循环右移问题 (20) [模拟]⼀个数组A中存有N（N&gt;0）个整数，在不允许使⽤另外数组的前提下，将每个整数循环向右移 M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1） （最后M个数循环移⾄最前⾯的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输⼊格式： 每个输⼊包含⼀个测试⽤例，第1⾏输⼊N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2⾏输⼊N个整数，之间⽤空格分隔。 输出格式： 在⼀⾏中输出循环右移M位以后的整数序列，之间⽤空格分隔，序列结尾不能有多余空格。 输⼊样例： 126 21 2 3 4 5 6 输出样例： 15 6 1 2 3 4 分析：数组⻓度为n，要想把数组循环右移m位，只需要先将整个数组a倒置，再将数组前m位倒置， 最后将数组后n-m位倒置即可完成循环右移m位～reverse函数可以实现将⼀个数组或者vector中元素倒 置，这个函数在algorithm头⽂件中～（如果m⼤于n，那么循环右移m位相当于循环右移m%n位，因为 那些n倍数位的移动是多余的，所以在使⽤m之前，先将m = m%n） 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; m %= n; if (m != 0) &#123; reverse(begin(a), begin(a) + n); reverse(begin(a), begin(a) + m); reverse(begin(a) + m, begin(a) + n); &#125; for (int i = 0; i &lt; n - 1; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; a[n - 1]; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#48;&#x32;&#x33;&#x30;&#52;&#55;&#x30;&#x33;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1012","date":"2021-04-05T15:04:41.538Z","path":"2021/04/05/pat1012/","text":"1012. 数字分类给定⼀系列正整数，请按要求对数字进⾏分类，并输出以下5个数字： A1 = 能被5整除的数字中所有偶数的和； A2 = 将被5除后余1的数字按给出顺序进⾏交错求和，即计算n1-n2+n3-n4…； A3 = 被5除后余2的数字的个数； A4 = 被5除后余3的数字的平均数，精确到⼩数点后1位； A5 = 被5除后余4的数字中最⼤数字。 输⼊格式： 每个输⼊包含1个测试⽤例。每个测试⽤例先给出⼀个不超过1000的正整数N， 随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出格式： 对给定的N个正整数，按题⽬要求计算A1~A5并在⼀⾏中顺序输出。 数字间以空格分隔，但⾏末不得有多余空格。 若其中某⼀类数字不存在，则在相应位置输出“N”。 输⼊样例1： 113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 130 11 2 9.7 9 输⼊样例2： 18 1 2 4 5 6 7 9 16 输出样例2： 1N 11 2 N 9 分析：将每⼀个数字按照取余后的结果i保存在v[i]数组中，然后对v[i]中的每⼀个元素按照不同i分类计 算出A1 A2…A5～ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, num, A1 = 0, A2 = 0, A5 = 0; double A4 = 0.0; cin &gt;&gt; n; vector&lt;int&gt; v[5]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; v[num%5].push_back(num);//把所有的数看成5进制，厉害 &#125; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; v[i].size(); j++) &#123; if (i == 0 &amp;&amp; v[i][j] % 2 == 0) A1 += v[i][j];//A1结果出来了 if (i == 1 &amp;&amp; j % 2 == 0) A2 += v[i][j]; if (i == 1 &amp;&amp; j % 2 == 1) A2 -= v[i][j];//A2结果出来了 if (i == 3) A4 += v[i][j];//求出的为满足5进制A4的所有数总和 if (i == 4 &amp;&amp; v[i][j] &gt; A5) A5 = v[i][j];//A5最大值结果出来了 &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123; if (i != 0) printf(&quot; &quot;);//这种方法和动态sql语句很像 if (i == 0 &amp;&amp; A1 == 0 || i != 0 &amp;&amp; v[i].size() == 0) &#123;//为(i==0&amp;&amp; A1== 0)||(i!=0&amp;&amp;v[i].size()==0),一个复杂短路或运算 printf(&quot;N&quot;); continue; &#125; if (i == 0) printf(&quot;%d&quot;, A1); if (i == 1) printf(&quot;%d&quot;, A2); if (i == 2) printf(&quot;%d&quot;, v[2].size());//返回A3个数，正好为放进去的个数 if (i == 3) printf(&quot;%.1f&quot;, A4 / v[3].size());//A4平均数 if (i == 4) printf(&quot;%d&quot;, A5); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#48;&#x32;&#51;&#x30;&#x34;&#x37;&#48;&#51;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1013","date":"2021-04-05T15:04:41.538Z","path":"2021/04/05/pat1013/","text":"1013. 数素数 (20)令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 10^4，请输出PM到PN的所有素数。 输⼊格式： 输⼊在⼀⾏中给出M和N，其间以空格分隔。 输出格式： 输出从PM到PN的所有素数，每10个数字占1⾏，其间以空格分隔，但⾏末不得有多余空格。 输⼊样例： 15 27 输出样例： 12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 分析：vector中保存第M到第N个素数，⽤cnt标记输出了多少个，如果当前已经输出的个数为10的倍 数，则输出⼀个空⾏～ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool isprime(int a) &#123; //判断传过来的是不是质数，如果不是返回false，是返回true for (int i = 2; i * i &lt;= a; i++) if(a % i == 0) return false; return true;&#125;int main() &#123; int M, N, num = 2, cnt = 0; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; v; while (cnt &lt; N) &#123; if (isprime(num)) &#123; cnt++; if (cnt &gt;= M) v.push_back(num); &#125; num++; &#125; cnt = 0; //剩下部分用来解决输出相关问题，包括空格、一行10个 for (int i = 0; i &lt; v.size(); i++) &#123; cnt++; if (cnt % 10 != 1) printf(&quot; &quot;); printf(&quot;%d&quot;, v[i]); if (cnt % 10 == 0) printf(&quot;\\n&quot;); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#50;&#x33;&#x30;&#52;&#x37;&#x30;&#51;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1011","date":"2021-04-05T15:04:40.454Z","path":"2021/04/05/pat1011/","text":"1010. A+B和C题⽬描述： 给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否⼤于C。 输⼊格式： 输⼊第1⾏给出正整数T(&lt;=10)，是测试⽤例的个数。随后给出T组测试⽤例，每组占⼀⾏，顺序给出 A、B和C。整数间以空格分隔。 输出格式： 对每组测试⽤例，在⼀⾏中输出“Case #X: true”如果 A+B&gt;C，否则输出“Case #X: false”，其中X是测试⽤例的编号（从1开始）。 输⼊样例： 1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例： 1234Case #1: falseCase #2: trueCase #3: trueCase #4: false 分析：使⽤long long int存储a、b和c，当a + b &gt; c的时候输出true，否则输出false～ 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; long long int a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); printf(&quot;Case #%d: %s\\n&quot;, i + 1, a + b &gt; c ? &quot;true&quot; : &quot;false&quot;); &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#50;&#x33;&#x30;&#52;&#55;&#x30;&#51;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1010","date":"2021-04-05T14:52:44.410Z","path":"2021/04/05/pat1010/","text":"1010. ⼀元多项式求导 (25) [模拟]设计函数求⼀元多项式的导数。（注：xn（n为整数）的⼀阶导数为n*xn-1。） 输⼊格式： 以指数递降⽅式输⼊多项式⾮零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式： 以与输⼊相同的格式输出导数多项式⾮零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。 输⼊样例： 13 4 -5 2 6 1 -2 0 输出样例： 112 3 -10 1 6 0 分析： flag⽤来判断是否已经有过输出～ 当b!=0时，因为给出的是所有⾮零项系数，所以必定会有输出，先判断flag是否为1，如果为1表示已 经有过输出，那么在前⾯要先输出⼀个空格 输出 a * b 和 b – 1，然后将flag标记为1表示已经有过输出 4.最后判断当没有输出并且b==0的时候， 输出“0 0” 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, flag = 0; while (cin &gt;&gt; a &gt;&gt; b) &#123; if (b != 0) &#123; if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a * b &lt;&lt; &quot; &quot; &lt;&lt; b - 1; flag = 1; &#125; &#125; if (flag == 0) cout &lt;&lt; &quot;0 0&quot;; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#50;&#x33;&#x30;&#52;&#x37;&#x30;&#51;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"MyBatisPlus概述","date":"2021-04-05T14:42:13.244Z","path":"2021/04/05/MyBatisPlus/","text":"MyBatisPlus概述需要的基础：SSM就可以学习这个了！ 为什么要学习它呢？MyBatisPlus 可以节省我们大量工作时间，所有的CRUD代码他都可以自动化完成！ JPA、tk-mapper、MyBatisPlus 偷懒的！ 简介是什么？MyBatis 本来就是简化 JDBC 而生 官网：为简化开发而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门地址：https://mp.baomidou.com/guide/quick-start.html#初始化工程 使用第三方组件： 导入对应的依赖 研究依赖如何配置 代码如何编写 提高扩展技术能力！ 步骤 创建数据库mybatis_plus 创建user表 1234567891011121314151617DROP TABLE IF EXISTS USER;CREATE TABLE USER( id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;, NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;, age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;, PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 编写项目，初始化项目！使用 SpringBoot 初始化！ 导入依赖 12345678910111213141516&lt;!--数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--mybatis_plus 是自己开发，并非官方的！--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 说明：我们使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus！版本的差异！ 连接数据库！这一步和 mybatis 相同 12345# mysql 8 驱动不同com.mysql.cj.jdbc.Driver需要增加时区的配置 serverTimeZone=Asia.Shanghaispring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 传统方式pojo-dao（连接mybatis，配置mapper.xml）-service-controller 使用了mybatis-plus 之后 pojo 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String smail;&#125; mapper接口 123456// 在对应的Mapper上面继承基本的类 BaseMapper@Repository //代表持久层public interface Usermapper extends BaseMapper &#123; //所有的CRUD操作都已经编写完成了 //你不需要像以前的配置一大堆文件了！&#125; 注意点，我们需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(&quot;com.kuang.mapper&quot;) 测试类中测试 配置日志我们所有的 sql 现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！ 12# 配置日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上 Mybatis-Plus！ CRUD扩展插入操作123456789101112//测试插入@Testpublic void testInsert()&#123; User user = new User(); user.setName(&quot;狂神说Java&quot;); user.setAge(3); user.setEmail(&quot;27917232@qq.com&quot;); int result = userMapper.insert(user);//帮我们自动生成id System.out.println(result);//受影响的行数 System.out.println(user);//发现，id会自动回填&#125; 数据库插入的id默认值为：全局的唯一id主键生成策略123@TableId(IdType.NONE)默认 * 用户输入ID * 该类型可以通过自己注册自动填充插件进行填充 分布式系统唯一id生成 雪花算法： snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。 可以查看表单的ID生成 123456789101112131415161718192021222324252627/** * 数据库ID自增 */AUTO(0),/** * 该类型为未设置主键类型 */NONE(1),/** * 用户输入ID * 该类型可以通过自己注册自动填充插件进行填充 */INPUT(2),/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *//** * 全局唯一ID (idWorker) */ID_WORKER(3),/** * 全局唯一ID (UUID) */UUID(4),/** * 字符串全局唯一ID (idWorker 的字符串表示) */ID_WORKER_STR(5); 主键自增 我们需要配置主键自增 实体类字段上@TableId(type=IdType.AUTO) 数据库字段一定要是自增的！ 再次测试插入即可！ 更新操作12345678910111213//测试更新@Testpublic void testUpdate()&#123; User user = new User(); //通过条件自动拼接动态sql user.setId(6L); user.setName(&quot;关注公众号：狂神说&quot;); user.setAge(18); //注意：updateById 但是参数是一个对象！ int i = userMapper.updateById(user); System.out.println(i);&#125; 所有的 sql 都是自动帮你动态配置的！ 自动填充创建时间、修改时间！这些个操作一般都是自动化完成的，我们不希望手动更新！ 阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！并且需要自动化！ 方式一：数据库级别（工作中不允许修改数据库的） 在表中新增字段create_time，update_time，默认为CURRENT_TIMESTAMP 再次测试插入方法，我们需要先把实体类同步！ 12private Date createTime;private Date updateTime; 方式二：代码级别 删除数据库中的默认值、更新操作！ 实体类字段属性上需要增加注解 12345//字段添加填充内容@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 编写处理器来处理这个注解即可！ 123456789101112131415161718@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill.....&quot;); this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125; //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill.....&quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125;&#125; 测试插入 测试更新，观察时间即可！ 乐观锁在面试过程中，我们经常参观会被问道乐观锁，悲观锁！这个其实非常简单！ 乐观锁：故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现问题，再次更新值测试 乐观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作 我们这里主要讲解 乐观锁机制！ 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 给数据库增加version字段； 我们实体类加对应的字段 12@Version //乐观锁Version注解private Integer version; 注册组件 1234567891011//扫描我们的mapper文件@MapperScan(&quot;com.kuang.mapper&quot;)@EnableTransactionManagement@Configuration //配置类public class MyBatisPlusConfig &#123; //注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor()&#123; return new OptimisticLockerInterceptor(); &#125;&#125; 测试 查询操作123456789101112131415161718192021222324//测试查询@Testpublic void testSelectById()&#123; User user = userMapper.selectById(1L); System.out.println(user);&#125;//测试批量查询@Testpublic void testSelectBatchIds()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println);&#125;//按条件查询之一 使用map操作@Testpublic void testSelectByMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //自定义查询 map.put(&quot;name&quot;,&quot;狂神说Java&quot;); map.put(&quot;age&quot;,3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println);&#125; 分页查询分页在网页使用的十分之多！ 原始的 limit 进行分页 pageHelper 第三方插件 MP 其实也内置了分页插件！ 如何使用 配置拦截器组件即可！ 12345//分页插件@Beanpublic PaginationInterceptor paginationInterceptor()&#123; return new PaginationInterceptor();&#125; 直接使用Page对象即可！ 12345678910@Testpublic void testPage()&#123; //参数一：当前页 //参数二：页面大小 //使用了分页插件之后，所有的分页操作也变得简单了！ Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println);&#125; 删除操作基本的删除操作 12345678910111213141516171819//测试删除@Testpublic void testDeleteById()&#123; userMapper.deleteById(1378534644579885060L);&#125;//通过id批量删除@Testpublic void test()&#123; userMapper.deleteBatchIds(Arrays.asList(1378534644579885058L,1378534644579885059L));&#125;//通过map删除@Testpublic void testDeleteMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;狂神说Java&quot;); userMapper.deleteByMap(map);&#125; 我们在工作中回遇到一些问题，逻辑删除！ 逻辑删除 物理删除：从数据库中直接移除 逻辑删除：在数据库中没有被移除，而是通过一个变量来让它生效！delete = 0 =&gt;delete = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站 测试一下： 在数据表中增加一个 deleted 字段 实体类中增加属性 12345//逻辑删除组件!@Beanpublic ISqlInjector sqlInjector()&#123; return new LogicSqlInjector();&#125; 配置！ 123# 配置逻辑删除mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0 测试删除数据 走的是更新操作，并不是删除操作 查询的时候会自动过滤被逻辑删除的字段 以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高工作和写项目的效率！ 性能分析插件我们在平时的开发中，会遇到一些慢 sql。测试！druid… 作用：性能分析拦截器，用于输出每条SQL语句及其执行时间 MP也提供性能分析插件，如果超过这个时间就停止运行！ 导入插件 1234567891011&#x2F;** sql执行效率插件*&#x2F;@Bean@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)&#x2F;&#x2F;设置 dev test 环境启动，保证我们的效率 public PerformanceInterceptor performanceInterceptor()&#123; PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100);&#x2F;&#x2F;ms 设置sql执行的最大时间，如果超过了则会报错 performanceInterceptor.setFormat(true);&#x2F;&#x2F;是否格式化代码 return performanceInterceptor;&#125; 记住，要在SpringBoot中配置环境为dev或者test环境！ 测试使用！只要超过规定的时间就会抛出异常 1234567@Testvoid contextLoads() &#123; //参数是一个Wrapper 条件构造器，这里我们先不用 null //查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println);&#125; 使用性能分析插件，可以帮助我们提高效率！ 条件构造器十分重要：Wrapper 我们写一些复杂的 sql 就可以使用它来代替！ 测试一 12345678910@Testvoid contextLoads() &#123; //查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(&quot;name&quot;) .isNotNull(&quot;email&quot;) .ge(&quot;age&quot;,12); userMapper.selectList(wrapper).forEach(System.out::println);//和我们刚才学习的map对比一下！&#125; 测试二 12345678@Testpublic void test2()&#123; //查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;name&quot;,&quot;狂神说&quot;); User user = userMapper.selectOne(wrapper);//查询一个数据，出现多个结果使用List 或者 Map System.out.println(user);&#125; 测试三 12345678@Testpublic void test3()&#123; //查询年龄在20-30之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(&quot;age&quot;,20,30);//区间 Integer count = userMapper.selectCount(wrapper);//查询结果数 System.out.println(count);&#125; 测试四，记住查看输出的SQL进行分析 12345678910@Testpublic void test4()&#123; //查询年龄在20-30之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //左和右 %e% wrapper.notLike(&quot;name&quot;,&quot;e&quot;) .likeRight(&quot;email&quot;,&quot;t&quot;); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);//查询结果数 maps.forEach(System.out::println);&#125; 测试五 12345678@Testpublic void test5()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //id 在子查询中查出来 wrapper.inSql(&quot;id&quot;,&quot;select id from user where id&lt;3&quot;); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);//查询结果数 objects.forEach(System.out::println);&#125; 测试六 123456789@Testpublic void test6()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //通过id进行排序 wrapper.orderByDesc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(wrapper);//查询结果数 users.forEach(System.out::println);&#125; 其余的测试，可以自己下去多练习！ 代码自动生成器dao、pojo、service、controller都给我自己去编写完成！ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"}]},{"title":"git","date":"2021-04-05T14:42:13.241Z","path":"2021/04/05/git/","text":"git学习 git 之前，我们需要先明白一个概念，版本控制！ 版本控制 什么是版本控制 版本迭代，新的版本！版本管理器 版本控制是一种在开发的过程中用管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便回复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发，提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事务性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。 无论是工作还是学习，或者自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！ 多人开发就必须要使用，都在代价会比较大 常见的版本控制工具 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制产品非常的多，现影响力最大且使用最广泛的是Git 版本控制分类 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。 集中版本控制 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 分布式版本控制 Git 每个人都有全部的代码！安全隐患！ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN最主要的区别 SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git 是分布式版本控制系统，没有中央服务器，每一个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己的电脑上改了文件A，其他人也在电脑上改了文件A，这时，它们俩只需把各自的修改推送给对方，就可以互相看到对方的修改了。 ==Git 是目前世界上最先进的分布式版本控制系统。== 聊聊Git历史同生活中的很多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众广的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991-2002年间）。到2002年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 Linux 社区中存在许多的大佬！破解研究 BitKeeper！ 到了2005年，开发BitKeeper的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是Linux的缔造者 Linux Torvalds）基于使用BitKeeper 时的经验教训，开发出自己的版本系统。（两周左右）也就是后来的Git！ Git环境配置 软件下载 打开[git官网]，下载git对应操作系统的版本。 所有东西下载慢的话就可以去找镜像！ 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows 卸载 直接反安装即可、然后清理环境变量 下载对应的版本即可安装！ 安装：无脑下一步即可！安装完毕就可以使用了！ 启动Git 安装成功后在开始菜单中会有Git选项，菜单下有3个程序：任意文件夹下右键 Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格的命令行 Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 常用的Linux命令学习 cd：改变目录。 cd..：退回到上一个目录，直接cd进入默认目录 pwd：显示当前所在的目录路径 ls(ll)：都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 touch：新建一个文件，如touching index.js 就会在当前目录下新建一个index.js 文件 rm：删除一个文件，rm index.js 就会把 index.js 文件删除 mkdir：新建一个目录，就是新建一个文件夹 rm -r：删除一个文件夹，rm -r -src 删除src目录 mv：移动文件，mv index.html src index.html 是我们要移动的文件，src 是目标文件夹，当然，这样写 reset：重新初始化终端/清屏 clear：清屏 history：查看命令历史 help：帮助 exit：退出 #：表示注释 Git 配置 查看配置git config -l查看不同级别的配置文件 12345# 查看系统configgit config --system --list# 查看当前用户(global)配置git config --global --list Git相关的配置文件 Git\\etc\\gitconfig：Git安装目录下的 gitconfig –System 系统级 C:\\user\\Administrator\\.gitconfig 只适用于当前登录用户的配置 –global 全局 这里可以直接编辑配置文件，通过命令设置后会影响到这里 设置用户名和邮箱(用户标识,必要) 当你安装Git后首先要做的事情是设置你的用户名和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： 12git config --global user.name &quot;touchingwang&quot; #名称git config --global user.email touchingwang@163.com #邮箱 Git基本理论（核心所有的实践都需要源于这个理论） 工作区域 Git 本地有三个工作区域：工作目录(Working Directory)、暂存区(Stage/Index)、资源库(Respository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域了。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是你平时存放项目代码的地方 Stage/Index：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Respository：仓库区(或本地仓库)：就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你的项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本 Directory：使用Git管理的一个目录，也就是一个仓库，包括我们的工作空间和Git的管理空间 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新去，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Satsh：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域； 将暂存区域的文件提交到git仓库 因此，git管理的文件有三种状态：已修改(modified)，已暂存(staged)，已提交(committed) Git项目搭建 创建工作目录与常见指令 工作目录(WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住6个命令： 本地仓库搭建 创建全新的仓库，需要用Git管理的项目的根目录执行： 12# 在当前目录新建一个Git代码库git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 12# 克隆一个项目和它的整个代码历史(版本信息)git clone [url] https://gitee.com/XXX 去gitee或者github上克隆一个测试！ Git文件操作 文件4中状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。通过git add状态变为Straged。 Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变成Modified.如果使用git rm移出版本库，则成为Untracked文件 Modefied：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过git add可进入暂存staged状态，使用git checkout则丢弃修改过，返回到unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改！ Staged：暂存状态，执行git commit则将修改同步到库，这时库中的文件和本地文件又变为一致，文件为Unmodify状态。执行git reset HEAD filename取消暂存，文件状态为Modified 查看文件状态 上面说文件有4种状态，通过如下命令可以查看到文件的状态： 12345678# 查看指定文件状态git status [filename]# 查看所有文件状态git status# git add . 添加所有文件到暂存区# git commit -m 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下规则： 忽略文件中的空行或以井号(#)开始的行将会被忽略。 可以使用Linux通配符。例如：星号(*)代表任意多个字符，问号(?)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,…})代表可选的符号串等。 如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略。 如果名称的最前面有一个路径分分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面有一个路径分分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)。 123456# 为注解*.txt #忽略所有 .txt结尾的文件，这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件，不包括其他目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略doc/notes.txt 但不包括 doc/sercer/arch.txt 使用码云 github 是由墙的，比较慢，在国内的话，我们一般使用gitee，公司中有时候会搭建自己的gielab服务器 这个其实可以作为大家未来找工作的一个重要信息！ 注册登录码云，完善个人信息 设置本机绑定SSH公钥，实现免密码登录！(免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！) 123# 进入 C:\\User\\Administrator\\.ssh 目录# 生成公钥ssh-keygen 将公钥信息public key添加到码云账户中即可！ 使用码云创建一个自己的仓库！ 克隆到本地！ IDEA中集成Git 新建项目，绑定git。 将我们远程的git文件目录拷贝到项目中即可！ 注意观察idea中的变化 修改文件，使用IDEA操作git 提交测试 这些都是单个人的操作！ 说明：GIT分支git分支中常用的命令 123456789101112131415161718192021# 列出所有本地分支 git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支git merge [branch]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 多个分支如果并行执行，就会导致我们代码冲突，也就是同时存在多个版本！ web-api -A web-admin -B 会调用A（修改了A的代码！） web-app -C 会调用 B 和 A 的代码 如果冲突了就需要协商即可！ 如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！ master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 团队很重要！","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"服务器相关知识","date":"2021-04-05T14:42:13.239Z","path":"2021/04/05/服务器相关知识/","text":"服务器相关知识 为什么程序员都需要一个自己的服务器 你作为一个程序员，必须要发布自己的网站和项目！ 练习Linux操作 自己的远程仓库、远程数据库、远程tomcat…..搭建在服务器上 练习，Linux进行任意的环境部署操作！Window下开发，你不熟悉Linux …… 服务器如何购买 尽量趁打折，购买，便宜！ 如果是学生或者24岁一下的小伙伴，可以购买学生机，100多一年 香港服务器可以避免备案，但是尽量不要自己挂VPN，会被封！ 买完服务器之后该做什么 服务器就是一个远程Linux 在阿里云购买的，需要开通安全组设置；端口映射（端口映射都需要在） 获取服务器的公网 ip 地址；修改实例名和密码，第一次修改需要重启。使用 xshell 远程连接 连接到服务器之后，我们需要搭建环境！ 傻瓜式 宝塔面板安装教学 下载完毕之后，就可以得到一个地址：宝塔的管理面板！ url： username： password： 自定义安装服务器环境 一键部署应用 比如tomcat 就可以放到 webapps 目录下！ 特殊的网站：开源项目，就按照自己操作来！ 上传文件尽量使用XFTP 命令式（原生）","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Mybatis知识笔记","date":"2021-03-28T10:13:19.300Z","path":"2021/03/28/Mybatis/","text":"Mybatis-2.10环境： JDK 1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。最好的方式：看官网文档； 1、简介1.1、什么是 MyBatis 是一款优秀的持久层框架 支持定制化 SQL、存储过程以及高级映射架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 如何获取 Mybatis maven仓库 1.2、持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io 文件持久化 为什么需要持久化？ 有一些对象，不能让他丢掉 内存太贵了 1.3、持久层Dao层(Data Access Objects数据持久层对象)，Service层，Controller层… 完成持久化工作的代码块 层界限十分明显。 1.4、为什么需要Mybatis? 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。技术没有高低之分 优点： 简单易学 灵活 sql 的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组件维护 提供 xml 标签，支持编写动态 sql 使用的人多 Spring SpringMVC SpringBoot 2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 连接数据库会出现serverTimeZone设置时区问题将其改为Asia/Shanghai 2.1、搭建环境搭建数据库 12345678910111213CREATE DATABASE `mybatis`;SHOW DATABASES;USE `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;213123&#x27;) 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!----&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、创建一个模块123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 12345678910111213141516171819202122//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static&#123; try &#123; //使用Myabatis第一步 获取sqlSessionFactory对象 String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。 //SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 //而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 public static SqlSession getSqlSession()&#123; return SqlSessionFactory sqlSessionFactory.openSession(); &#125;&#125; 2.3、编写代码 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//实体类public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wang.dao.UserDao&quot;&gt;&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2.4、测试注意点：org.apache.ibatis.binding.BindingException: Type interface com.wang.dao.UserDao is not known to the MapperRegistry.（UserDao类型接口没有在注册中心显示） MapperRegistry是什么？ 核心配置文件中注册 mappers junit 测试 12345678910111213141516@Testpublic void test()&#123; //第一步：获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一:getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close();&#125; 可能会遇到的问题： 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD1、namespacenamespace中的包命要和 Dao/mapper 接口的包名一致！ 2、select选择，查询语句； id：就是对应的namespace中的方法名； resultType：Sql 语句执行的返回值！ parameterType：参数类型！ 编写接口 12//根据ID查询用户User getUserById(Int id); 编写对应的mapper中的sql语句 1234&lt;!--select查询语句--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.wang.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 1234567891011@Testpublic void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close();&#125; 3、Insert123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt; 4、update123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.wang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;&lt;/update&gt; 5、Delete123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;;&lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范 NullPointerException，没有注册到资源！ 输出的xml文件中存在中文乱码的问题 maven资源没有导出问题！ 7、万能map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 123//万能的Mapint addUser2(Map&lt;String,Object&gt; map); 1234&lt;!--对象中的属性，可以直接取出来 传递map的key--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id,pwd) values (#&#123;userid&#125;,#&#123;password&#125;);&lt;/insert&gt; 123456789101112131415@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,5); map.put(&quot;password&quot;,&quot;22223333&quot;); mapper.addUser2(map); sqlSession.commit(); sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！【parameterType=”map“】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object“】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8、思考题模糊查询怎么写？ Java代码执行的时候，传递通配符%% 1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符！ 1select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot; 4、配置解析1、核心配置文件 mybatis-config.xml Mybatis 的配置文件包含了会深深影响Mybatis 行为和设置的属性信息 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 2、环境配置（enviroments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是JDBC，连接池：POOLED 3、属性（property）我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 意思是可以的Java属性文件中配置，也可以在db.properties中去配置【db.properties】 将properties标签放在后面，出现这段话的意思是，在xml中，所有的标签都可以规定其顺序，即按照它所给的标签顺序写入，否则会报错 编写一个配置文件 db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF8username=rootpassword=123456 在核心配置文件中映入 12345&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/properties&gt; 可以直接引入外部配置文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，官方文档说首先读取在 properties 元素体内指定的属性。意思是先读取标签元素体内的属性，在去读取外部文件的属性，这样外部的会把标签内的覆盖掉，这样就会读取到外部配置文件的属性。 4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.wang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，Mybatis 会在包名下面搜索需要的Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！ 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.wang.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种不行，如果非要该，需要在实体上增加注解 12@Alias(&quot;user&quot;)public class User &#123;&#125; 5、设置这是Mybatis 中极为重要的调整设置，它们会改变 Mybatis 的运行时行为。 6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用 mapper 7、映射器（mapper）MapperRegistty：注册绑定我们的Mapper文件； 方式一： 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/wang/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二：使用 class 文件绑定注册 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;package name=&quot;com.wang.dao&quot; /&gt;&lt;/mappers&gt; 注意点： 接口和它的Mapper配置文件必须同名！ 接口和它的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口和 UserMappper.xml 改为一致！并且放在同一个包下！ 3、生命周期和作用域作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuider： 一旦创建了SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 连接池的一个连接（请求）! SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用。 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题1、问题数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 12345public class User &#123; private int id; private String name; private String password;&#125; 测试出现问题 发现属性名与字段名不一致的提取不出来所需要的值 123//select * from mybatis.user where id = #&#123;id&#125;//类型处理器//select id,name,pwd from mybatis.user where id = #&#123;id&#125; 解决方法： 起别名 2、resultMap结果集映射 12id name pwdid name password 1234567&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。 6、日志6.1、日志工程如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout，debug 现在：日志工厂！ SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING【掌握】 NO_LOGGING 在Mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ 6.2、Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入LOG4J的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/wang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 12345 &lt;settings&gt; &lt;!--标准的日志工厂实现--&gt;&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; Log4j的使用！直接测试运行刚才的查询 简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 123logger.info(&quot;info:进入了testLog4j&quot;);logger.debug(&quot;debug:进入了testLog4j&quot;);logger.error(&quot;error:进入了testLog4j&quot;); 7、分页思考：为什么要分页？ 减少数据的处理量 7.1、使用Limit分页123语法:SELECT * FORM lIMIT startIndex,pageSize;select *from user limit 2,2; 笔记： 0,3 意思是每页显示 3 个从第0个开始查询 使用Mybatis实现分页，核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!--分页--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 这里返回的为resultMap结果集映射，其中的UserMap为对应的章节的映射，我这里就出错了。 测试 12345678910111213141516@Testpublic void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,0); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userByLimit = mapper.getUserByLimit(map); for (User user : userByLimit) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.2、RowBounds分页不再使用SQL实现分页 接口 12//分页2List&lt;User&gt; getUserByRowBounds(); mapper.xml 1234&lt;!--分页2--&gt;&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 123456789101112131415@Testpublic void getUserByRowBounds()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.wang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.3、分页插件 PageHelper了解即可，万一以后公司的架构师，说要使用，你需要知道它是什么东西！ 8、使用注解开发8.1、面向接口编程大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因：==解耦==，可扩展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得很容易，规范性很好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现租户的，对系统来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体（abstract class） 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface） 一个体有可能有多个抽象面。抽象面与抽象面是由区别的。 三个面向区别 面向对象是指，我们考虑问题是，以对象为单位，考虑它的属性及方法。 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现。 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题。更多的体现就是对系统整体的构架。 8.2、使用注解开发 注解在接口上实现 12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口！ 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.wang.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ 8.3、注解的CRUD我们可以在工具类创建的时候实现自动提交事务！(util里） 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注解 123456789101112131415161718public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解 @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserByID(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name = #&#123;name&#125;,pwd=#&#123;password&#125; where id = &#123;#id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);&#125; 测试类 【注意：我们必须要将接口注册绑定到我们的核心配置文件中！】 8.4、关于@Param（）注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的@Param（）中设定的属性名！ #{} ${}区别 9、Lombok12Project Lombok is a java library that automatically plugs插件 into your editor（在你的代码里面） and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs 插件 build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 12345&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;version&gt;1.18.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 在实体类上加注解 123@Data@AllArgsConstructor@NoArgsConstructor 12345678910111213141516@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows 说明： 123456@Data：无参构造、get、set、tostring、hashcode、equals@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode@ToString@Getter 10、多对一处理多对一： 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 对于老师而言，集合，一个老师，有很多学生 SQL： 123456789101112131415161718192021222324252627CREATE TABLE &#96;teacher&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INDELETE FROM &#96;mybatis&#96;.&#96;user&#96; WHERE &#96;id&#96; &#x3D; &#39;id&#39; ;TO teacher(&#96;id&#96;, &#96;name&#96;) VALUES (1, &#39;秦老师&#39;); CREATE TABLE &#96;student&#96; ( &#96;id&#96; INT(10) NOT NULL, &#96;name&#96; VARCHAR(30) DEFAULT NULL, &#96;tid&#96; INT(10) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;fktid&#96; (&#96;tid&#96;), CONSTRAINT &#96;fktid&#96; FOREIGN KEY (&#96;tid&#96;) REFERENCES &#96;teacher&#96; (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;); INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;); 测试环境搭建 导入 lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或文件！【方式很多，随心选】 测试查询是否能够成功！ 按照查询嵌套处理12345678910111213141516171819&lt;!-- 思路： 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 按照结果嵌套处理1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 回顾Mysql多对一查询方式： 子查询 连表查询 11、一对多处理比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系 环境搭建，和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结构嵌套处理1234567891011121314151617181920&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection javatype=&quot;&quot; 指定属性的类型！ 集合中的泛型信息，我们使用oftype获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理1234567891011&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudents2&quot;&gt; select * from mybatis.teacher where id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudents2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志，建议使用Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ 12、动态SQL==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态SQL这一特性可以彻底摆脱这种痛苦 1234ifchoose (when, otherwise)trim (where, set)foreach 搭建环境1234567CREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口 和 Mapper.XML文件 if123456789&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; choose(when, otherwise)1234567891011121314select * from mybatis.blog&lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/where&gt; trim(where,set)123456789select * from mybatis.blog&lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/where&gt; ==所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码== if where，set，choose，when SQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 1234select * from mybatis.blog&lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;&lt;/where&gt; 在需要使用的地方使用 Include 标签引用即可 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 注意事项： 最好基于单表来定义SQL片段！ 不要存在 where 标签 Foreach1234567891011&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map，这map中可以存在一个集合！ --&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and(&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 现在 Mysql 中写出完整的SQL，在对应的去修改成为我们的动态SQL实现通用即可！ 13、缓存13.1、简介12查询 ： 连接数据库 ， 耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--》内存：缓存 什么是缓存【cache】？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地指定和配置缓存。缓存可以极大的提高查询效率。 Mybatis系统中默认定义了二级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.3、一级缓存 一级缓存也交本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库； 测试步骤： 开启日志！ 测试在一个Session中查询两次记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于 namspace 级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存指定数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 12&lt;!--在当前Mapper.xml中开启二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题：如果只写&lt;cache/&gt;会出现序列化缓存的问题，如果开启了eadOnly=&quot;true&quot;就可以了 1Caused by: java.io.NotSerializableException: com.wang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ 13.5、缓存原理 13.6、自定义缓存-ehcache1Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用 ehcache，先要导包！ 在 mapper 中指定使用我们的Ehcache 缓存实现！ Redis 数据库来做缓存！","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"}]},{"title":"UUID的故事","date":"2021-03-27T14:49:46.670Z","path":"2021/03/27/UUID/","text":"UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。 如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID） 1.简介UUID 是国际标准化组织（ISO-International Organization for Standardization）提出的一个概念。UUID 是一个128比特的数值，这个数值可以通过一定的算法计算出来。 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。 UUID 由以下几部分的组合： 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 2.重复机率随机产生的 UUID 的128个比特中，有122个比特是随机产生，4个比特在此版本被使用，还有2个在其变体中被使用。 与被陨石击中的机率比较的话，已知一个人每年被陨石击中的机率估计为170亿分之1，也就是说机率大约是0.00000000006 (6 x 10^-11)，等同于在一年内置立数十兆笔GUID并发生一次重复。换句话说，每秒产生10亿笔UUID，100年后只产生一次重复的机率是50%。如果地球上每个人都各有6亿笔GUID，发生一次重复的机率是50%。 3.版本UUID具有多个版本，每个版本的算法不同，应用范围也不同。 基于时间的UUID基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。 基于名字的UUID（MD5）基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"pat1007","date":"2021-03-27T06:58:57.578Z","path":"2021/03/27/pat1007/","text":"1007. 素数对猜想 (20) [素数]让我们定义 dn 为：dn = pn+1 – pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数 对猜想”认为“存在⽆穷多对相邻且差为2的素数”。 现给定任意正整数N (&lt; 105)，请计算不超过N的满⾜猜想的素数对的个数。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数N。 输出格式： 每个测试⽤例的输出占⼀⾏，不超过N的满⾜猜想的素数对的个数。 输⼊样例： 120 输出样例： 14 分析：判断素数的函数isprime这样写：对于数字a，i从2到根号a，如果a能够被其中⼀个i整除，说明i 不是素数，return false，否则说明a是素数return true；对于输⼊数据N，for循环中的i从5到N依次判断 i-2和i是否是素数，如果都是素数，则统计个数的cnt++，最后输出cnt即可～ 123456789101112131415#include &lt;iostream&gt;using namespace std;bool isprime(int a) &#123; for (int i = 2; i * i &lt;= a; i++) if (a % i == 0) return false; return true;&#125;int main() &#123; int N, cnt = 0; cin &gt;&gt; N; for (int i = 5; i &lt;= N; i++) if (isprime(i-2) &amp;&amp; isprime(i)) cnt++; cout &lt;&lt; cnt; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#x30;&#50;&#51;&#x30;&#52;&#55;&#48;&#51;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1006","date":"2021-03-27T06:53:10.558Z","path":"2021/03/27/pat1006/","text":"1006. 换个格式输出整数 (15) [字符串处理]让我们⽤字⺟B来表示“百”、字⺟S表示“⼗”，⽤“12…n”来表示个位数字n（&lt;10），换个格式来输出任 ⼀个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“⼗”、以及个位的 4。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数n（&lt;1000）。 输出格式： 每个测试⽤例的输出占⼀⾏，⽤规定的格式输出n。 输⼊样例： 1234 输出样例： 1BBSSS1234 输⼊样例2： 123 输出样例2： 1SS123 分析：因为n⼩于1000，所以数字不会超过百位～输⼊数据⾸先保存在a中，然后将a的每⼀个数字保存 在int b[3]中，然后将b[2]、b[1]、b[0]中存储的数字看作输出次数依次输出B、S和12..b[0]～ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int a, i = 0; cin &gt;&gt; a; int b[3] = &#123;0&#125;; while (a != 0) &#123; b[i++] = a % 10; a = a / 10; &#125; for (int k = 0; k &lt; b[2]; k++) cout &lt;&lt; &quot;B&quot;; for (int k = 0; k &lt; b[1]; k++) cout &lt;&lt; &quot;S&quot;; for (int k = 0; k &lt; b[0]; k++) cout &lt;&lt; k + 1; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#x33;&#48;&#x34;&#x37;&#48;&#x33;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1005","date":"2021-03-27T06:49:05.269Z","path":"2021/03/27/pat1005/","text":"1005.继续(3n+1)猜想 (25) [Hash散列]卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题⽬⾥，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每⼀个数。例如对 n=3进⾏验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进⾏验证的时候，就 可以直接判定卡拉兹猜想的真伪，⽽不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我 们称5、8、4、2是被3“覆盖”的数。我们称⼀个数列中的某个数n为“关键数”，如果n不能被数列中的其 他数字所覆盖。 现在给定⼀系列待验证的数字，我们只需要验证其中的⼏个关键数，就可以不必再重复验证余下的数 字。你的任务就是找出这些关键数字，并按从⼤到⼩的顺序输出它们。 输⼊格式： 每个测试输⼊包含1个测试⽤例，第1⾏给出⼀个正整数K(&lt;100)，第2⾏给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间⽤空格隔开。 输出格式： 每个测试⽤例的输出占⼀⾏，按从⼤到⼩的顺序输出关键数字。数字间⽤1个空格隔开，但⼀⾏中最后 ⼀个数字后没有空格。 输⼊样例： 1263 5 6 7 8 11 输出样例： 17 6 分析：对每⼀个输⼊的数字n进⾏验证，把验证过的数字对应的arr标记为1，然后对这些输⼊的数字从 ⼤到⼩排序，输出所有arr=0的数字即为关键数字～ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int arr[10000];bool cmp(int a, int b) &#123;return a &gt; b;&#125;int main() &#123; int k, n, flag = 0; cin &gt;&gt; k; vector&lt;int&gt; v(k); for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; v[i] = n; while (n != 1) &#123; if (n % 2 != 0) n = 3 * n + 1; n = n / 2; if (arr[n] == 1) break; arr[n] = 1; &#125; &#125; sort(v.begin(), v.end(), cmp); for (int i = 0; i &lt; v.size(); i++) &#123; if (arr[v[i]] == 0) &#123; if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; v[i]; flag = 1; &#125; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#x32;&#x33;&#x30;&#x34;&#x37;&#48;&#51;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1004","date":"2021-03-27T06:34:53.933Z","path":"2021/03/27/pat1004/","text":"1004. 成绩排名 (20) [查找元素]读⼊n名学⽣的姓名、学号、成绩，分别输出成绩最⾼和成绩最低学⽣的姓名和学号。 输⼊格式： 每个测试输⼊包含1个测试⽤例，格式为 第1⾏：正整数n 第2⾏：第1个学⽣的姓名 学号 成绩 第3⾏：第2个学⽣的姓名 学号 成绩 … … … 第n+1⾏：第n个学⽣的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的⼀个整数，这⾥保证在⼀组测试 ⽤例中没有两个学⽣的成绩是相同的。 输出格式： 对每个测试⽤例输出2⾏，第1⾏是成绩最⾼学⽣的姓名和学号，第2⾏是成绩最低学⽣的姓名和学号， 字符串间有1空格。 输⼊样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 分析：in = 101。遍历所有数据，如果当前学⽣数据的分数⽐最⼤值⼤，那么更新max的值，并将 他的姓名学号保存在maxname和maxnum中；如果当前学⽣数据的分数⽐最⼩值⼩，那么更新min的 值，并将他的姓名学号保存在minname和minnum中。最后输出maxname、maxnum、minname和 minnum～ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main() &#123; int n, max = -1, min = 101, score; cin &gt;&gt; n; string maxname, minname, maxnum, minnum, name, num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; num &gt;&gt; score; if (max &lt; score) &#123; max = score; maxname = name; maxnum = num; &#125; if (min &gt; score) &#123; min = score; minname = name; minnum = num; &#125; &#125; cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnum &lt;&lt; endl &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnum; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#48;&#x32;&#x33;&#x30;&#x34;&#x37;&#x30;&#x33;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1003","date":"2021-03-27T06:16:00.089Z","path":"2021/03/27/pat1003/","text":"1003.我要通过！(20) [数学题]“答案正确”是⾃动判题系统给出的最令⼈欢喜的回复。本题属于PAT的“答案正确”⼤派送 —— 只要读⼊ 的字符串满⾜下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字⺟ A 组 成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字 ⺟ A 组成的字符串。 现在就请你为PAT写⼀个⾃动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输⼊格式： 每个测试输⼊包含1个测试⽤例。第1⾏给出⼀个⾃然数n (&lt;10)，是需要检测的字符串个数。接下来每 个字符串占⼀⾏，字符串⻓度不超过100，且不包含空格。 输出格式： 每个字符串的检测结果占⼀⾏，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。 输⼊样例： 1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例： 12345678YESYESYESYESNONONONO 分析： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本题解析：本题我做的时候是很很难的，即使第二次看也用了一个小时才搞明白，这道题按答案解析，主要在于理解题目，以及如果查找出a，b，c。 首先，题目给出了 3 个很有迷惑性的 “正确答案” 的条件，第 1 条，必须有仅有PAT三种字符很好理解，第二个为 XPATX，X 为空或 ’A‘，”AA“，”AAA“，··· 也好理解。关键第 3 个条件，如果aPbTc是正确的，那么aPbATca正确，也可以继续推第三代，第四代 ···，那么就需要考虑第一代原型是什么，而此时的第二个条件就为原型，且只有第二个条件为原型，这一定要理解，不然这题就废了。这样一看，原型也是有规律的，即b必须为一个A，且原型 a 的A和C的A个数相等，即原型为PAT,APATA,AAPATAA…再将每一个原型代入第三个条件进行推导会发现一个对所有字符串（满足条件1）都适用的规律，即c=a*b。接下来就好多了，一个for循环，判断s[i]==&#39;P&#39;和s[i]==&#39;T&#39;，找出 P 和 T 个数为 1。之后 y&gt;x ,这道题基本难点也讲完了。 1s.find(P)=x,s.dind(y)=y,y&gt;x 本系列(PAT算法)作者mail：&#49;&#x33;&#48;&#x32;&#51;&#x30;&#x34;&#55;&#x30;&#51;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"MySQL三种常见引擎","date":"2021-03-16T13:48:07.242Z","path":"2021/03/16/Mysql引擎/","text":"MySQL三种常见引擎 一.InnoDB存储引擎InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是 InnoDB。 InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。 InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。 InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。 二.MyISAM存储引擎MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。 MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。 MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。 三.MEMORY存储引擎MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 友链(本篇为理解，没有我写的成分)：https://blog.csdn.net/qq_41118581/article/details/90173117","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://example.com/tags/MYSQL/"}]},{"title":"pat1002","date":"2021-03-12T05:23:22.295Z","path":"2021/03/12/pat1002/","text":"1002. 写出这个数 (20) [字符串处理]读⼊⼀个⾃然数n，计算其各位数字之和，⽤汉语拼⾳写出和的每⼀位数字。 输⼊格式：每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。这⾥保证n⼩于10100。 输出格式： 在⼀⾏内输出n的各位数字之和的每⼀位，拼⾳数字间有1 空格，但⼀⾏中最后⼀个拼⾳数字后没有空 格。 输⼊样例： 11234567890987654321123456789 输出样例： 1yi san wu 分析：⽤string接收输⼊，string的每⼀位数字累加到sum⾥⾯，再将sum转化为string类型的num，对 num的每⼀位输出对应中⽂拼⾳～ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#x33;&#x30;&#x32;&#x33;&#48;&#52;&#x37;&#48;&#x33;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1001","date":"2021-03-11T15:01:17.326Z","path":"2021/03/11/pat1001/","text":"1001. 害死⼈不偿命的(3n+1)猜想(15) [模拟]卡拉兹(Callatz)猜想： 对任何⼀个⾃然数n，如果它是偶数，那么把它砍掉⼀半；如果它是奇数，那么把(3n+1)砍掉⼀半。这 样⼀直反复砍下去，最后⼀定在某⼀步得到n=1。卡拉兹在1950年的世界数学家⼤会上公布了这个猜 想，传说当时耶鲁⼤学师⽣⻬动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学⽣们⽆⼼学 业，⼀⼼只证(3n+1)，以⾄于有⼈说这是⼀个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题⽬不是证明卡拉兹猜想，⽽是对给定的任⼀不超过1000的正整数n，简单地数⼀下，需要 多少步（砍⼏下）才能得到n=1？ 输⼊格式： 每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。 输出格式： 输出从n计算到1需要的步数。 输⼊样例： 13 输出样例： 15 分析：count从0开始统计需要的步数，(n % 2 != 0) 表示n为奇数，当n为奇数，就令n = 3*n+1；之后将 其砍掉⼀半，步数count+1，直到n == 1为⽌，最后输出count～ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int num=0,n; cin &gt;&gt;n; while(n!=1)&#123; if(n%2)n=(3*n+1); n=n/2; num++; &#125; cout&lt;&lt;num; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#50;&#x33;&#48;&#52;&#x37;&#48;&#x33;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;(非本人)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"数据库学习之《mysql必知必会》","date":"2021-02-28T03:32:20.437Z","path":"2021/02/28/数据库学习之《mysql必知必会》/","text":"之前买了一本《MySQL必知必会》，最终拖拖拉拉用来一个星期的时间才把它看完，关于此书我觉得前面没有多大的难度，和《计算机网络自顶向下》 比起 还是很简单的，在我觉得比较困难的是存储过程，触发器的那几章，还有的是懂得了一门语言不是重点，重要的是要会使用和经常使用，这两点我还不行。下面我说说学习《MySQL必知必会》遇到的几个问题。 关于导入《MySQL必知必会》样例表的问题。一开始我并不打算使用这本书的数据库，后来发现有些知识点比较难懂于是又开始去寻找如何下载，下面是我的总结。 首先去网页下载两个SQL脚本文件，所需要获得和运行的一切东西都可以在https://forta.com/books/0672327120 上找到。 之后会有这个 点击自己选择一个名字 如text，则底下会出现一个这个 再接下来点击进入其中选择schemas 创建一个数据源，这一步和简单，你可以选择在命令行中进行，根据MySQL必知必会，选择名字crashcourse比较好， 然后再在菜单栏中，选择File-&gt;Open SQL Script，分别找到create.sql脚本，点击下图位置运行 对于populate.sql文件，重复导入脚本以及运行步骤即可 最后选中数据源并右键，选择Refresh All！！！（很重要） 今天学到了MySQL第十四章，对子查询这一步感到惊叹，能想出这样的方法— 真是老牛下蛋，牛逼坏了。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"用故事讲解md","date":"2021-02-28T03:27:14.304Z","path":"2021/02/28/用故事讲解Markdown/","text":"Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬 John Gruber 和 Aaron Swartz 。2010年，确定了其标准语法 CommonMark，2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站… 人人都应学Markdown1.1Markdown是什么​ Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬John Gruber和 Aaron Swartz。Makedown本质是一个标记语言，与HTML非常相似，兼容HTML。起初用于网络写作，现在记笔记，写文档，写README.md。2010年，确定了其标准语法 CommonMark，虽然有了定义但是标准语法的核心功能还是太少了，于是不断扩展，知道2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站。 1.2推荐使用​ 需要文字排版但无特殊要求 ​ 可以很方便的转换位Word 1.3如何学习使用Markdown 编写Markdown源码 &gt; 编辑器 &gt; 各种样式 语法学习 2.1基础语法所有标记符号都必须是半角标点符号 标题 语法：”# + 空格 + 标题内容” 行首插入 # “#”的个数=标题的等级 建议在#后面加个空格 支持最多六个标题 粗体和斜体 粗体，由两个*或两个_包裹 斜体，由一个*或一个_包裹 列表 有序列表，数字符号 + 英文句号 + 空格 + 列表内容 有序列表1 有序列表2 无序列表，-*/+/- + 空格 + 列表内容 无序列表1 无序列表2 嵌套列表，下层列表前按Tab键 有序列表和无序列表可以互相嵌套 分割线 三个或三个以上的_来标记 图片 语法，！[图片代替文字](图片地址) 图片替代文字不是必须，可以为空 图片地址，可以是本地路径，也可以是网络路径 本地图片支持相对路径和绝对路径两种 链接 文字链接 语法，[链接文字](链接地址) 链接过多后，可读性变差 引用链接 语法，[链接文字] [链接标记][链接标记]: 链接地址 链接标记可以是字母，数字，空格和标点符号 链接标记不区分大小写 定义的链接可任意位置放置，建议放在页尾 链接地址为网络地址需以http/https开头 网址链接 语法，&lt;url 或邮箱地址&gt; 无需以 http/https 开头 行内代码与代码块 行内代码：用包裹 代码块：以tab键或4个空格开头 1echo &quot;hello word&quot; 引用 语法，&gt; + 引用内容 在引用中可以嵌套引用 在引用中可以使用其他的 Markdown 语法 扩展语法2.1删除线 语法，~~被删除的文字~~ 2.2表情符号 语法，使用:包裹表情代码，:表情代码 表情符号代码，请参考webpagefx，或搜索Markdown emoji code 2.3表格 语法 1234|表头1|表头2|表头3||-|--|---||内容1|内容2|内容3||内容1|内容2|内容3| 表头1 表头2 表头3 内容1 内容2 内容3 内容1 内容2 内容3 2.4任务列表 语法，- + 空格 + [空格] + 空格 +文字内容 未勾选，-[] 已勾选，-[X/x] 语法说明 x可大写或小写，但有些编辑器不支持大写，故推荐使用小写的x 2.5围栏代码块 使用规范 使用连续的3个` 行内代码使用`包裹 1echo &#x27;hello word&#x27; 2.6锚点[锚点描述](#锚点名) 2.7内联数学公式 语法，$数学公式$ 快捷键，control + M $f(x,y)=\\frac{x}{y}$","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"使用命令窗口发送邮件","date":"2021-02-28T03:18:13.645Z","path":"2021/02/28/使用命令窗口发送邮件/","text":"学习笔记之前建立了一个hexo的博客，但是两个月没用出现了，结果出现了’使用子域名作为Github Pages的域名导致访问不了’的问题,对于才接触的我也没有解决的办法，只好重新安装了一个，以后如果再出现这个问题要解决掉，最近正在学计算机网络的应用层感觉用命令窗口发送qq邮箱很有趣，于是打算写一篇关于如何用命令窗口进行与邮件服务器进行链接的文章。我是使用win10 用qq邮箱进行发送的，如果以后有机会用163进行一次。 开启邮箱服务首先先开启qq邮箱的独立密码，进入设置-账户-独立密码，使邮箱开启POP3/SMTP，进入设置-账户-开启服务 接下来打开windows计算机上的telnet服务，打开控制面板-打功选中Telnet客户端、Telnet服务器，然后确定，等待完成 开始发送先打开命令窗口，输入 telnet smtp.qq.com 25,回复220，如果不是查看telnet服务是否开启 接着输入helo qq(后缀.com有时加有时不用)如果成功，服务器返回 250 ，不成功换一下 登录认证输入auth login，，会返回类似于：334 VXNlcm5hbWU6 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车回复334成功，其他失败 如果不知道可以 进行简单的代码运行得到1234import sun.misc.BASE64Encoder;public static void main(String[] args)&#123; System.out.println(Base64.encodeBase(&quot;xxxxx@qq.com&quot;.getBytes())); &#125; 输出即为。输入时如果太麻烦鼠标右键的话会直接粘贴，比较方便。 接下来输入独立密码的base64编码之后的字符串然后回车 回复235 Authentication successful成功，如果失败可能是因为独立密码失效 编写邮件输入 mail from:&lt;你自己的邮箱@qq.com&gt; 回车，成功返回250ok 输入 rcpt to:&lt;收件人邮箱，xxx@xxx.xxx&gt; 回车，成功返回250ok 输入 data 回车，回车后就可以开始写邮件内容了 输入 from：发件人名称 (可任意填) 输入 to：收件人名称(可任意填) 输入 subject：信件主题 在正文输入结束时输入一个.(英文)回车 服务器返回 250 Ok: queues as,表示邮件已经发送","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"翻墙(下)","date":"2021-02-28T02:08:16.679Z","path":"2021/02/28/翻墙(下)/","text":"3、域名劫持 Domain name hijacking一般情况下, 使用浏览器去连接互联网站点时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来。当使用翻墙软件时, 各种翻墙软件是采用在境外服务器和境内服务器之间建立一条安全隧道的方式，借助代理服务器对敏感数据进行加密访问。此时, 浏览器先向代理服务器发出请求, 再由代理服务器取回浏览器所需信息并传送给浏览器。摘自：典型翻墙软件的网络通信特征研究在中国知网查看：点击跳转 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 目的是无法访问目标网站，限制在特定的被劫持的网络范围内，是互联网攻击的一种方式。 DNS（Domain Name System，域名bai系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简介定义域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。 域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 原理：域名解析 (DNS) 的基本原理是把网络地址（域名，以一个字符串的形式）对应到真是计算机能够识别的网络地址（IP地址，比如216.239.53.99 这样的形式），以便计算机能够进一步通信，传递网址和内容等。 由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。 过程由于域名劫持只能在特定的网络范围内进行，所以范围外的域名服务器(DNS)能返回正常IP地址。攻击者正是利用此点在范围内封锁正常DNS的IP地址，使用域名劫持技术，通过冒充原域名以E-MAIL方式修改公司的注册域名记录，或将域名转让到其他组织，通过修改注册信息后在所指定的DNS服务器加进该域名记录，让原域名指向另一IP的服务器，让多数网民无法正确访问，从而使得某些用户直接访问到了恶意用户所指定的域名地址，其实施步骤如下： 一、获取劫持域名注册信息：首先攻击者会访问域名查询站点，通过MAKE CHANGES功能，输入要查询的域名以取得该域名注册信息。 二、控制该域名的E-MAIL帐号：此时攻击者会利用社会工程学或暴力破解学进行该E-MAIL密码破解，有能力的攻击者将直接对该E-MAIL进行入侵行为，以获取所需信息。 三、修改注册信息：当攻击者破获了E-MAIL后，会利用相关的MAKE CHANGES功能修改该域名的注册信息，包括拥有者信息，DNS服务器信息等。 四、使用E-MAIL收发确认函：此时的攻击者会在信件帐号的真正拥有者之前，截获网络公司回馈的网络确认注册信息更改件，并进行回件确认，随后网络公司将再次回馈成功修改信件，此时攻击者成功劫持域名。 缺点它不是很稳定，在某些网络速度快的地方，真实的IP地址返回得比窃持软件提供的假地址要快，因为监测和返回这么巨大的数据流量也是要花费一定时间的。 在网上查询域名的正确IP非常容易。一个是利用海外的一些在线IP地址查询服务，可以查找到网站的真实IP地址。在Google上搜索”nslookup”，会找到更多类似的服务。 4、流量限制流量限制是一个名词，指直接限制网络流量。 地位：最严厉的一种流量限制。 限制分类当前的虚拟主机主要分为三类流量限制: 一:流量限制 就是直接限制网络流量,这种限制通常是最严厉的一种流量限制,10个g的流量大体支持50人在线以内.当月流量超过后,在一个月内网站都不能正常访问了,解决办法是升级空间或加大流量! 假设一个网页的大小是10K Byte，那么访问这个网页一次就要产生10K的流量，1G流量就可以访问这个网页 1G/10K=100,000 次。 二:CPU限制 CPU限制看起来没有限IIS或网络流量,但由于每一个程序运行都需要一定的CPU配额,也是变相的流量限制,通常网页显示在线过多都是由于CPU限额过小引起的!通过刷新或15秒后可以得到暂时的正常运行,通常1%的CPU限额相当于20个IIS连接!这对于论坛空间很重要,论坛的CPU限额一旦过小就会不能正常运行! 三:IIS限制 IIS限制是现在用的最多的,也是被大多用户或主机商认可,是唯一宽松的流量限制,通常20个IIS就相当于1%CPU占用! 选择建议虚拟主机实际上没有不限流量的,总的可以分为以上三种方式,您如何选择,要看您的需要,如果您的程序占用CPU很少,是优化的程序可以选择限CPU的,这样您的在线就可以得到最大的发挥,如果您是初学者,或是论坛用户,或网站程序中有BBS,选择IIS限制或直接流量限制是一个好的选择!","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"科幻小说死亡开关在数据方面真的能实现吗？","date":"2021-02-25T05:32:58.542Z","path":"2021/02/25/科幻小说死亡开关在数据方面真的能实现吗？/","text":"每个人的生命只有一次，没人能说清死后的世界是什么样的。 作者 戴维·伊格尔曼（大卫·伊格曼）David Eagleman，生于1971年，美国神经科学家，斯坦福大学副教授，NeoSensory（似乎是一家植入传感器设备公司）的CEO。本篇《死亡开关》选自作者2009年出版的图书《死亡的故事》（Sum: Forty Tales from the afterlives）第二十五章，也曾在《Nature》上发表过（是的，Nature也会接收一些科普和科幻小说），严格来说——这篇与其说是科幻小说，倒不如说是一篇科幻随笔——可以看作是科幻小说的构思，大刘、韩松、吴岩等国内科幻大佬也出版过类似的科幻随笔。 总的来说看了一下，也就是他所写的《死亡的故事》中的一个随笔故事，篇幅几百字左右。里面讲了死亡开关，电脑每周会向你发出密码提示，确认你还活着，如果一段时间过去了，你却一直没有输入密码，那么电脑就会做出你已经死亡的推断，并自动将密码发送给第二号负责人。 人们利用死亡开关将瑞士银行的账号转交给自己的继承人，在争论中强辩到底，或是坦诚道出有生之年无法开口说出的秘密。 我感觉吧，根本不可能实现，信息的积累只会是越来越大，虽然现在是大数据时代，将来将会是巨大数据时代，但是数据的存储也是有限的，如果人们死后会进行数据的积累，那么数据只会越来越大，而且是叠加增长，先前拥有的死亡人的数据会增加，新来的也增加。现如今，世界人口已经增长到75亿人次。根据联合国公布z、的数字，现在的每秒出生的人数平均有5人次，死亡的人数每秒为2人次。也就是说世界人口每秒就增加3人次，那么一分钟就是增加180人次，一小时也就是增加10800人次，以此类推的话，一年大概要增加将近1亿人次。接下来我们再算算死亡人数，每秒2人次，一分钟就是120人次，一小时就是7200人次，同样以此类推，每年死亡的人口大概在6400万人次。一个人只保留1Mb的数据，一年存储数据为64000000MB，64000GB，64T。 计算机报上看到荷兰银行的20个数据中心有大约7PB磁盘和超过20PB的磁带存储，而且每年50%~70%存储量的增长，计算一下27PB大约为 500个64TB的大小，也就是500个第一年开始进行死亡开关这场游戏的数据。 由于是叠加增长，第一年会产生一个64TB 第二年会是第一年产生的，加上新产生的总和，2+1=3 第三年3+2+1=6 第四年4+3+2+1=10 这里我用Java写了一个测试代码，看看500个64TB能够几年使用完 12345678910111213public class HelloWorld &#123; public static void main(String []args) &#123; int num=0; for(int i = 0;;i++)&#123; num = num + i; if(num&gt;500)&#123; System.out.println(i); break; &#125; &#125; &#125;&#125;结果：32 也就是用了32年会将荷兰银行的这些数据存储完，但之后的数据存储会持续叠加上升，为无线等差数列和 等差数列和的函数为n^2，之后看看第二个荷兰银行数据存储会多久存满，结果是第45年，也就是用了13年就会存满，之后会越来越少，等到有一天，n=500的时候，也就会是每天将会存储一个荷兰银行的20个数据中心。 综上所述，我觉得这是一个不现实的问题。 mobi文件mobi是亚马逊的私有格式，目前市面上的 mobi 文件大部分是来自两种途径：epub、pdf 或者 txt 转换成的 mobi，从 Amazon 商店流出来的 mobi。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"翻墙(上)","date":"2021-02-25T02:03:23.942Z","path":"2021/02/25/翻墙(上）/","text":"科普所谓翻墙，是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问。境外公司曾发布几款突破网络封锁以访问海外敏感网站或邮件的翻墙软件。由于此类软件不断升级，要实现对该类软件行为的监测或封锁就显得尤为困难和重要，如果能够在网关处将数据截获，分析数据包的行为特征，将部分数据包进行劫持还原，这将对公安机关的调查取证起到积极的作用。 该解释引自《典型翻墙软件的网络通信特征研究》，作者官国静，此外我还会讲解一下它的这篇文章 由于内容过多下半部分放在了下一篇，想了解关于软件和caj文件解释的可以看看，以下定义摘抄自百度，为了是能够自己了解所以写在了下面，觉得不够详细的可以百度搜索。 1、ip 封锁（IP Block）ip 封锁是指防火墙维护一张 ip 黑名单，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。 缺点：采用黑名单禁止模式有一定的漏洞 目的：屏蔽对目的主机的访问 提供服务的服务器亦可能使用类似的方法，以控制可存取的范围，通常可设定白名单只允许某个网段或某个国家的 ip 存取，也可设定黑名单以禁止某网段或某些国家的 ip 存取。例如一些线上游戏营运商或线上影片服务为确保本国玩家的权益及版权限制，只允许本国的 ip 连线。 缺点这种对被封禁的网站采用黑名单而不是对被允许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在。 常见情况封锁 ip — 当计算机或系统受到外部攻击时，管理员可以通过屏蔽攻击源 ip 地址来抵御攻击。通过防火墙和路由器配置，可以封锁某个 ip，禁止与其连接，从而达到抵御攻击的作用。但事实上大多数的攻击，管理员根本没有时间反应，一般在反应过来后系统已经崩溃。 1、多次发布谩骂、侮辱言论； 2、发布大量商业广告、或无用废帖（即 “爆吧” ） 3、其他严重违反贴吧规定的情况。 2、内容过滤content filter内容过滤是对网络内容进行监控，防止某些特定内容在网络上进行传输的技术。主要实现有 软件(点击跳转)和硬件两种。 性质为非营利性，开始启用时间为1995年，含义为对网络内容进行监控。 解释在因特网上，内容过滤（content filtering），也被称作信息过滤（information filtering），是将Web网页或电子邮件中令人讨厌的信息屏蔽和拒绝存取或使用的技术。内容过滤被公司或家用电脑拥有者用作网络防火墙的一部分，尤其是父母可以为他们的孩子屏蔽掉那些不想让其访问的内容。 内容过滤通常使用特征字符串进行工作，如果内容和字符串相符，则会把这部分内容屏蔽掉。被过滤的典型是那些带有色情、暴力、仇恨倾向的内容，==内容过滤程序的批评者指出，它可能在无形中将想要的内容同时过滤掉。== 内容过滤和提供这项服务的产品分为网页过滤——屏蔽网站或页面的信息、邮件过滤——屏蔽电子邮件中的垃圾信息或其它令人讨厌的信息。 方法简介（先软件后硬件）软件过滤方式内容过滤的软件方式主要是一项1995年开始启用的技术标准“Internet内容选择平台”，它是由一家非营利性Internet开放商联盟――万维网联盟(W3C)为解除1995年年末出台的美国《通讯正派条例》(该条例于1997年被否决)的威胁而推出的。Internet内容选择平台的设计理念是鼓励自由表达、保护未成年人的权益，把工具交给父母或其他人，让他们为自己和自己的孩子过滤内容。 这类工具同时还可以将孩子或雇员送出的不恰当信息滤掉，比如家庭地址、信用卡号码、或机密的公司信息等等。 软件过滤主要使用关键词匹配的方式，将特定内容移除。随着互联网应用的开展，软件过滤无法处理飞速增长的流量，于是硬件过滤应运而生。 硬件过滤方式硬件过滤方式就是将关键词匹配功能集成在控制有大量流量的交换机或路由器中，以对网络中的流量进行监控。 目的为防止暴力、恐怖、色情、颠覆主义等内容在互联网上传播，维护网络安全，净化网络，为广大网民提供绿色上网环境。 软件指按照特定顺序组织的计算机数据和指令的集合 软件（中国大陆及香港用语，台湾称作软体，英文：software）是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。软件并不只是包括可以在计算机（这里的计算机是指广义的计算机）上运行的电脑程序，与这些电脑程序相关的文档一般也被认为是软件的一部分。简单的说软件就是程序加文档的集合体。另也泛指社会结构中的管理系统、思想意识形态、思想政治觉悟、法律法规等等。 开发语言为Java、C/C++、Basic、python等 应用类别系统软件、应用软件等 定义国标中对软件的定义为：与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。 其它定义： 1．运行时，能够提供所要求功能和性能的指令或计算机程序集合。 2．程序能够满意地处理信息的数据结构。 3．描述程序功能需求以及程序如何操作和使用所要求的文档。 以开发语言作为描述语言，可以认为：软件=程序+数据+文档 特点1、无形的，没有物理形态，只能通过运行状况来了解功能、特性、和质量 2、软件渗透了大量的脑力劳动，人的逻辑思维、智能活动和技术水平是软件产品的关键 3、软件不会像硬件一样老化磨损，但存在缺陷维护和技术更新 4、软件的开发和运行必须依赖于特定的计算机系统环境，对于硬件有依赖性，为了减少依赖，开发中提出了软件的可移植性 5、软件具有可复用性，软件开发出来很容易被复制，从而形成多个副本 分类应用类别按应用范围划分，一般来讲软件被划分为==系统软件==、==应用软件==和==介于这两者之间的中间件==。 系统软件 系统软件为计算机使用提供最基本的功能，可分为操作系统和支撑软件，其中操作系统是最基本的软件。 系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。 1．操作系统是一管理计算机硬件与软件资源的程序，同时也是计算机系统的内核与基石。操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统交互的操作接口。 2．支撑软件是支撑各种软件的开发与维护的软件，又称为软件开发环境（SDE）。它主要包括环境数据库、各种接口软件和工具组。著名的软件开发环境有IBM公司的Web Sphere,微软公司的等。 包括一系列基本的工具（比如编译器、数据库管理、存储器格式化、文件系统管理、用户身份验证、驱动管理、网络连接等方面的工具）。 应用软件 系统软件并不针对某一特定应用领域，而应用软件则相反，不同的应用软件根据用户和所服务的领域提供不同的功能。 应用软件是为了某种特定的用途而被开发的软件。它可以是一个特定的程序，比如一个图像浏览器。也可以是一组功能联系紧密，可以互相协作的程序的集合，比如微软的Office软件。也可以是一个由众多独立程序组成的庞大的软件系统，比如数据库管理系统。 如今智能手机得到了极大的普及，运行在手机上的应用软件简称手机软件。所谓手机软件就是可以安装在手机上的软件，完善原始系统的不足与个性化。随着科技的发展，手机的功能也越来越多，越来越强大。不是像过去的那么简单死板,发展到了可以和掌上电脑相媲美。手机软件与电脑一样，下载手机软件时还要考虑你购买这一款手机所安装的系统来决定要下相对应的软件。手机主流系统有以下：[Windows Phone](https://baike.baidu.com/item/Windows Phone)、Symbian、iOS、Android。 授权类别不同的软件一般都有对应的软件授权，软件的用户必须在同意所使用软件的许可证的情况下才能够合法的使用软件。从另一方面来讲，特定软件的许可条款也不能够与法律相违背。 依据许可方式的不同，大致可将软件区分为几类： 专属软件：此类授权通常不允许用户随意的复制、研究、修改或散布该软件。违反此类授权通常会有严重的法律责任。传统的商业软件公司会采用此类授权，例如微软的Windows和办公软件。专属软件的源码通常被公司视为私有财产而予以严密的保护。 自由软件：此类授权正好与专属软件相反，赋予用户复制、研究、修改和散布该软件的权利，并提供源码供用户自由使用，仅给予些许的其它限制。以Linux、Firefox 和OpenOffice 可做为此类软件的代表。 共享软件：通常可免费的取得并使用其试用版，但在功能或使用期间上受到限制。开发者会鼓励用户付费以取得功能完整的商业版本。根据共享软件作者的授权，用户可以从各种渠道免费得到它的拷贝，也可以自由传播它。 免费软件：可免费取得和转载，但并不提供源码，也无法修改。 公共软件：原作者已放弃权利，著作权过期，或作者已经不可考究的软件。使用上无任何限制。 相关概念开发流程软件开发是根据用户要求建造出软件系统或者系统中的软件部分的过程。软件开发是一项包括需求捕捉，需求分析，设计，实现和测试的系统工程。软件一般是用某种程序设计语言来实现的。通常采用软件开发工具可以进行开发。 软件开发流程即Software development process。 软件设计思路和方法的一般过程，包括设计软件的功能和实现的算法和方法、软件的总体结构设计和模块设计、编程和调试、程序联调和测试以及编写、提交程序。 1 相关系统分析员和用户初步了解需求，然后列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。 2 系统分析员深入了解和分析需求，根据自己的经验和需求做出一份文档系统的功能需求文档。这次的文档会清楚例用系统大致的大功能模块，大功能模块有哪些小功能模块，并且还例出相关的界面和界面功能。 3 系统分析员和用户再次确认需求。 4 系统分析员根据确认的需求文档所例用的界面和功能需求，用迭代的方式对每个界面或功能做系统的概要设计。 5 系统分析员把写好的概要设计文档给程序员，程序员根据所例出的功能一个一个的编写。 6 测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能，然后验收。 软件工程师一般指从事软件开发职业的人。软件工程师10余年来一直占据高薪职业排行榜的前列，作为高科技行业的代表，技术含量很高，职位的争夺也异常激烈。软件开发是一个系统的过程，需要经过市场需求分析、软件代码编写、软件测试、软件维护等程序。软件开发工程师在整个过程中扮演着非常重要的角色，主要从事根据需求开发项目软件工作。 法律保护计算机软件作为一种知识产品，其要获得法律保护，必须具备以下必要条件： （一）原创性。即软件应该是开发者独立设计、独立编制的编码组合。 （二）可感知性。受保护的软件须固定在某种有形物体上，通过客观手段表达出来并为人们所知悉。 （三）可再现性。即把软件转载在有形物体上的可能性。 著作权归属根据《计算机软件保护条例》第10条的规定，计算机软件著作权归属软件开发者。因此，确定计算机著作权归属的一般原则是“谁开发谁享有著作权”。软件开发者指实际组织进行开发工作，提供工作条件完成软件开发，并对软件承担责任的法人或者非法人单位，以及依靠自己具有的条件完成软件开发，并对软件承担责任的公民。 载体软件的载体可以是硬盘、光盘、U盘、软盘等数据存储设备。 使用许可不同的软件一般都有对应的软件授权，软件的使用者必须在同意所使用软件的许可证的情况下才能够合法的使用软件。 依据许可方式的不同，大致可将软件区分为几类： 专属软件、自由软件、共享软件、免费软件、公共软件。 生命周期软件生命周期是指从软件定义、开发、使用、维护到报废为止的整个过程，一般包括问题定义、可行性分析、需求分析、总体设计、详细设计、编码、测试和维护。 问题定义就是确定开发任务到底“要解决的问题是什么”，系统分析员通过对用户的访问调查，最后得出一份双方都满意的关于问题性质、工程目标和规模的书面报告。 可行性分析就是分析上一个阶段所确定的问题到底“可行吗”，系统分析员对系统要进行更进一步的分析，更准确、更具体地确定工程规模与目标，论证在经济上和技术上是否可行，从而在理解工作范围和代价的基础上，做出软件计划。 需求分析即使对用户要求进行具体分析，明确“目标系统要做什么”，把用户对软件系统的全部要求以需求说明书的形式表达出来。 总体设计就是把软件的功能转化为所需要的体系结构，也就是决定系统的模块结构，并给出模块的相互调用关系、模块间传达的数据及每个模块的功能说明。 详细设计就是决定模块内部的算法与数据结构，也是明确“怎么样具体实现这个系统”。 编码就是选取适合的程序设计语言对每个模板进行编码，并进行模块调试。 测试就是通过各种类型的测试使软件达到预定的要求。 维护就是软件交付给用户使用后，对软件不断查错、纠错和修改，使系统持久地满足用户的需求。 软件的生命周期也可以分为3个大的阶段，分别是计划阶段、开发阶段和维护阶段。 软件生命周期模型软件生命周期模型也称为软件过程模型，反映软件生存周期各个阶段的工作如何组织、衔接，常用的有瀑布模型、原型模型、螺旋模型、增量模型、喷泉模型，还有建造-修补模型、MSF过程模型、快速原型模型。 [1] 常见的软件生命周期模型瀑布模型 有时也称为V模型，它是一种线型顺序模型，是项目自始至终按照一定顺序的步骤从需求分析进展到系统测试直到提交用户使用，它提供了一种结构化的、自顶向下的软件开发方法，每阶段主要工作成果从一个阶段传递到下一个阶段，必须经过严格的评审或测试，以判定是否可以开始下一阶段工作，各阶段相互独立、不重叠。瀑布模型是所有软件生命周期模型的基础。 [1] 原型+瀑布模型 原型模型本身是一个迭代的模型，是为了解决在产品开发的早期阶段存在的不确定性、二义性和不完整性等问题，通过建立原型使开发者进一步确定其应开发的产品，使开发者的想象更具体化，也更易于被客户所理解。原型只是真实系统的一部分或一个模型，完全可能不完成任何有用的事情，通常包括抛弃型和进化型两种，抛弃型指原型建立、分析之后要扔掉，整个系统重新分析和设计；进化型则是对需求的定义较清楚的情形，原型建立之后要保留，作为系逐渐增加的基础，采用进化型一定要重视软件设计的系统性和完整性，并且在质量要求方面没有捷径，因此，对于描述相同的功能，建立进化型原型比建立抛弃型原型所花的时间要多。原型建立确认需求之后采用瀑布模型的方式完成项目开发。 [1] 增量模型 与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 一些大型系统往往需要很多年才能完成或者客户急于实现系统，各子系统往往采用增量开发的模式，先实现核心的产品，即实现基本的需求，但很多补充的特性(其中一些是已知的，另外一些是未知的)在下一期发布。增量模型强调每一个增量均发布一个可操作产品，每个增量构建仍然遵循设计-编码-测试的瀑布模型。 [1] 迭代模型 早在20世纪50年代末期，软件领域中就出现了迭代模型。最早的迭代过程可能被描述为“分段模型”。迭代，包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。所以，在某种程度上，开发迭代是一次完整地经过所有工作流程的过程：（至少包括）需求工作流程、分析设计工作流程、实施工作流程和测试工作流程。 实质上，它类似小型的瀑布式项目。所有的阶段（需求及其它）都可以细分为迭代。每一次的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 [1] 开发语言O语言O语言是一款中文计算机语言（或称套装：O汇编语言、O中间语言、O高级语言） Java语言作为跨平台的语言，可以运行在Windows和Unix/Linux下面，长期成为用户的首选。自JDK6.0以来，整体性能得到了极大的提高，市场使用率超过20%。可能已经达到了其鼎盛时期了，不知道后面能维持多长时间。 易语言（E语言）易语言是一个自主开发，适合国情，不同层次不同专业的人员易学易用的汉语编程语言。易语言降低了广大电脑用户编程的门槛，尤其是根本不懂英文或者英文了解很少的用户，可以通过使用本语言极其快速地进入Windows程序编写的大门。 [2] C/C++语言以上2个作为传统的语言，一直在效率第一的领域发挥着极大的影响力。像Java这类的语言，其核心都是用C/C++写的。在高并发和实时处理，工控等领域更是首选。 习语言习语言即中文版的C语言 Basic美国计算机科学家约翰·凯梅尼和托马斯·库尔茨于1959年研制的一种“初学者通用符号指令代码”，简称BASIC。由于BASIC语言易学易用，它很快就成为流行的计算机语言之一。 PHP同样是跨平台的脚本语言，在网站编程上成为了大家的首选，支持PHP的主机非常便宜，PHP+Linux+MySQL+Apache的组合简单有效。 Perl脚本语言的先驱，其优秀的文本处理能力，特别是正则表达式，成为了以后许多基于网站开发语言(比如PHP,Java,C#)的这方面的基础。 PythonPython是一种面向对象的解释性的计算机程序设计语言，也是一种功能强大而完善的通用型语言，已经具有十多年的发展历史，成熟且稳定。Python 具有脚本语言中最丰富和强大的类库，足以支持绝大多数日常应用。 这种语言具有非常简捷而清晰的语法特点，适合完成各种高层任务，几乎可以在所有的操作系统中运行。 基于这种语言的相关技术正在飞速的发展，用户数量急剧扩大，相关的资源非常多。 C#C#是微软公司发布的一种面向对象的、运行于NET Framework之上的高级程序设计语言，并定于在微软职业开发者论坛(PDC)上登台亮相。C#是微软公司研究员Anders Hejlsberg的最新成果。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、界面，与Java几乎同样的语法，和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM(组件对象模型)是直接集成的，而且它是微软公司.NET Windows网络框架的主角。 JavaScriptJavaScript是一种由Netscape的LiveScript发展而来的脚本语言，主要目的是为了解决服务器终端语言，比如Perl，遗留的速度问题。当时服务端需要对数据进行验证，由于网络速度相当缓慢，只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。 Ruby一种为简单快捷面向对象编程（面向对象程序设计）而创的脚本语言，由日本人松本行弘（まつもとゆきひろ，英译：Yukihiro Matsumoto，外号matz）开发，遵守GPL协议和Ruby License。Ruby的作者认为Ruby &gt; (Smalltalk + Perl) / 2，表示Ruby是一个语法像Smalltalk一样完全面向对象、脚本执行、又有Perl强大的文字处理功能的编程语言。 Fortran在科学计算软件领域，Fortran曾经是最主要的编程语言。比较有代表性的有Fortran 77、Watcom Fortran、NDP Fortran等。 Objective C这是一种运行在苹果公司的[Mac OS X](https://baike.baidu.com/item/Mac OS X/470629)，iOS操作系统上的语言。这两种操作系统的上层图形环境，应用程序编程框架都是使用该语言实现的。随著iPhone,iPad的流行，这种语言也开始在全世界流行。 PascalPascal是一种计算机通用的高级程序设计语言。Pascal的取名是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal。它由瑞士Niklaus Wirth教授于六十年代末设计并创立。Pascal语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。 SwiftSwift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C共同运行于[Mac OS](https://baike.baidu.com/item/Mac OS)和iOS平台，用于搭建基于苹果平台的应用程序。 caj文件caj文件是中国期刊网提供的一种文件格式,现在网络的很多文献都采用了 caj 文件格式。在浏览 caj 格式文件的时候,你也必须使用相应的阅读器才可以,通用的caj阅读器为CAJViewer。","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"日记","date":"2021-02-24T07:59:00.706Z","path":"2021/02/24/时间管理法/","text":"每月小结，看看自己这个月用于什么的时间是多少，如上课，认真学习，玩 同时年度总结，对自己本月进行反思 记录尽可能准确的记录时间被用在了哪里， 统计以每周每个月或每年为单位，统计每件事情用了多少时间 分析，分析在过去这段时间里，哪些运用时间的方法是高效的，哪些是可以改进的 反馈根据自己分析得出的结论做出改变，让自己更加有效的利用时间 记录–》统计–》分析–》反馈要点： 首先是记录的及时性，不要连续做了好几件事情再回过头来一件一件的记，要一事一记，同时要保持时间记录的真实性、准确性。要保证记录的误差不要大于15分钟就可以了。 其次，选择记录的时间段要相对固定并且有代表性，如果你要记录自己在某项相对重复的工作上花费了多少时间，最好是每天固定的时间段来做这项工作，人在固定时段的状态是相对稳定的。 最后你还要根据记录情况，及时调整时间分配计划，在每周或每月总结的时候要找出上一段计划当中实际消耗时间与计划消耗时间之间的差额，然后结合自己的工作效率重新分配下一时间段。 坚持是在时间管理方面必不可少的品质。 时间管理法的五大法则：恰当运用这五大法则，可以让时间管理法不会成为你的一种镣铐，而是成为运用自如的乐器。 不要为了完成工作而放弃自己的兴趣爱好。对作者而说，不论工作有多困难，任务有多繁重，只要他愿意，就一定能在自己预估的时间里按部就班的完成，但事实上，作者并不是像我们想象中的那么从一而终，很多时候它的本质工作，是要为兴趣让路的。没有什么比满足自己的求知欲和好奇重要，与其被迫在完成工作和满足好奇心之间做出选择，不如索性大方拒绝那些必须完成的任务而选择兴趣。 不接受紧急的任务。因为接受紧急的任务可能会因为由于时间仓促而无法做到尽善其美，更重要的是，它会打破你原有的节奏，引起一系列的连锁反应，最后反而是更费时间的。 一累了就马上停止工作去休息。 保证睡眠时间，每天10小时左右。没有这条守则，时间管理方法将永远是纸上谈兵。作者认为，休息是需要规划、记录、安排再规划的，因为这种方法并不是一种间歇性的方法，而是一种长期性的计划，这是一种很容易让人产生压迫感的方法，如果睡的不好，没有足够的休息，当你面对一张慢慢当当的计划表的时候，很容易陷入被计划牵着鼻子走的恶训循环，一旦陷入这样的恶训循环，就离放弃不远了。 把累人的工作和愉快的工作结合在一起。","categories":[],"tags":[{"name":"更多知识","slug":"更多知识","permalink":"http://example.com/tags/%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"搭建博客以及优化","date":"2021-02-23T09:09:39.356Z","path":"2021/02/23/搭建博客以及优化/","text":"不会吧不会吧，难道你还没有属于自己的博客？ 目录不显示文章标题，tags标签怎么加，文章截断 标签这个东西可以在我们写完一个博客文章之后在最上方添加，这样比较方便，对应 yilia 主题你会发现没有这个你的文章没有标题，是空白的。 还有一个是文章截断问题，默认是主页显示整篇的文章，写完文章后，用记事本打开，再需要的地方加上截断代码 &lt;!--more--&gt; 图片加载-采用 lazyload 图片懒加载 图片加载只需要两步 配置，在hexo目录下，执行以下命令，插入模块 1npm install hexo-lazyload-image --save 然后在你的 hexo 目录的配置文件 _config.xml 中添加配置： 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片. loadingImg - 图片未加载时的代替图 不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes\\next\\source\\images 目录下, 然后引用时: loadingImg: /images/图片文件名 借鉴的有简书的这位好友，很感谢带给我的帮助，帮我处理了很多日常写博客的问题https://www.jianshu.com/p/f6f19b02c661 还有就是新手们怎么搭建博客，这里推荐一位好友www.codesheep.cn","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]