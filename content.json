[{"title":"pat1007","date":"2021-03-27T06:58:57.578Z","path":"2021/03/27/pat1007/","text":"1007. 素数对猜想 (20) [素数]让我们定义 dn 为：dn = pn+1 – pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数 对猜想”认为“存在⽆穷多对相邻且差为2的素数”。 现给定任意正整数N (&lt; 105)，请计算不超过N的满⾜猜想的素数对的个数。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数N。 输出格式： 每个测试⽤例的输出占⼀⾏，不超过N的满⾜猜想的素数对的个数。 输⼊样例： 120 输出样例： 14 分析：判断素数的函数isprime这样写：对于数字a，i从2到根号a，如果a能够被其中⼀个i整除，说明i 不是素数，return false，否则说明a是素数return true；对于输⼊数据N，for循环中的i从5到N依次判断 i-2和i是否是素数，如果都是素数，则统计个数的cnt++，最后输出cnt即可～ 123456789101112131415#include &lt;iostream&gt;using namespace std;bool isprime(int a) &#123; for (int i = 2; i * i &lt;= a; i++) if (a % i == 0) return false; return true;&#125;int main() &#123; int N, cnt = 0; cin &gt;&gt; N; for (int i = 5; i &lt;= N; i++) if (isprime(i-2) &amp;&amp; isprime(i)) cnt++; cout &lt;&lt; cnt; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#48;&#50;&#x33;&#x30;&#x34;&#55;&#x30;&#51;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1006","date":"2021-03-27T06:53:10.558Z","path":"2021/03/27/pat1006/","text":"1006. 换个格式输出整数 (15) [字符串处理]让我们⽤字⺟B来表示“百”、字⺟S表示“⼗”，⽤“12…n”来表示个位数字n（&lt;10），换个格式来输出任 ⼀个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“⼗”、以及个位的 4。 输⼊格式： 每个测试输⼊包含1个测试⽤例，给出正整数n（&lt;1000）。 输出格式： 每个测试⽤例的输出占⼀⾏，⽤规定的格式输出n。 输⼊样例： 1234 输出样例： 1BBSSS1234 输⼊样例2： 123 输出样例2： 1SS123 分析：因为n⼩于1000，所以数字不会超过百位～输⼊数据⾸先保存在a中，然后将a的每⼀个数字保存 在int b[3]中，然后将b[2]、b[1]、b[0]中存储的数字看作输出次数依次输出B、S和12..b[0]～ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int a, i = 0; cin &gt;&gt; a; int b[3] = &#123;0&#125;; while (a != 0) &#123; b[i++] = a % 10; a = a / 10; &#125; for (int k = 0; k &lt; b[2]; k++) cout &lt;&lt; &quot;B&quot;; for (int k = 0; k &lt; b[1]; k++) cout &lt;&lt; &quot;S&quot;; for (int k = 0; k &lt; b[0]; k++) cout &lt;&lt; k + 1; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#50;&#x33;&#x30;&#52;&#x37;&#48;&#x33;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1005","date":"2021-03-27T06:49:05.269Z","path":"2021/03/27/pat1005/","text":"1005.继续(3n+1)猜想 (25) [Hash散列]卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题⽬⾥，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每⼀个数。例如对 n=3进⾏验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进⾏验证的时候，就 可以直接判定卡拉兹猜想的真伪，⽽不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我 们称5、8、4、2是被3“覆盖”的数。我们称⼀个数列中的某个数n为“关键数”，如果n不能被数列中的其 他数字所覆盖。 现在给定⼀系列待验证的数字，我们只需要验证其中的⼏个关键数，就可以不必再重复验证余下的数 字。你的任务就是找出这些关键数字，并按从⼤到⼩的顺序输出它们。 输⼊格式： 每个测试输⼊包含1个测试⽤例，第1⾏给出⼀个正整数K(&lt;100)，第2⾏给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间⽤空格隔开。 输出格式： 每个测试⽤例的输出占⼀⾏，按从⼤到⼩的顺序输出关键数字。数字间⽤1个空格隔开，但⼀⾏中最后 ⼀个数字后没有空格。 输⼊样例： 1263 5 6 7 8 11 输出样例： 17 6 分析：对每⼀个输⼊的数字n进⾏验证，把验证过的数字对应的arr标记为1，然后对这些输⼊的数字从 ⼤到⼩排序，输出所有arr=0的数字即为关键数字～ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int arr[10000];bool cmp(int a, int b) &#123;return a &gt; b;&#125;int main() &#123; int k, n, flag = 0; cin &gt;&gt; k; vector&lt;int&gt; v(k); for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; n; v[i] = n; while (n != 1) &#123; if (n % 2 != 0) n = 3 * n + 1; n = n / 2; if (arr[n] == 1) break; arr[n] = 1; &#125; &#125; sort(v.begin(), v.end(), cmp); for (int i = 0; i &lt; v.size(); i++) &#123; if (arr[v[i]] == 0) &#123; if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; v[i]; flag = 1; &#125; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#x33;&#x30;&#50;&#x33;&#48;&#52;&#55;&#x30;&#x33;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1004","date":"2021-03-27T06:34:53.933Z","path":"2021/03/27/pat1004/","text":"1004. 成绩排名 (20) [查找元素]读⼊n名学⽣的姓名、学号、成绩，分别输出成绩最⾼和成绩最低学⽣的姓名和学号。 输⼊格式： 每个测试输⼊包含1个测试⽤例，格式为 第1⾏：正整数n 第2⾏：第1个学⽣的姓名 学号 成绩 第3⾏：第2个学⽣的姓名 学号 成绩 … … … 第n+1⾏：第n个学⽣的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的⼀个整数，这⾥保证在⼀组测试 ⽤例中没有两个学⽣的成绩是相同的。 输出格式： 对每个测试⽤例输出2⾏，第1⾏是成绩最⾼学⽣的姓名和学号，第2⾏是成绩最低学⽣的姓名和学号， 字符串间有1空格。 输⼊样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 分析：in = 101。遍历所有数据，如果当前学⽣数据的分数⽐最⼤值⼤，那么更新max的值，并将 他的姓名学号保存在maxname和maxnum中；如果当前学⽣数据的分数⽐最⼩值⼩，那么更新min的 值，并将他的姓名学号保存在minname和minnum中。最后输出maxname、maxnum、minname和 minnum～ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main() &#123; int n, max = -1, min = 101, score; cin &gt;&gt; n; string maxname, minname, maxnum, minnum, name, num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; num &gt;&gt; score; if (max &lt; score) &#123; max = score; maxname = name; maxnum = num; &#125; if (min &gt; score) &#123; min = score; minname = name; minnum = num; &#125; &#125; cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnum &lt;&lt; endl &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnum; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#x30;&#x32;&#x33;&#x30;&#52;&#x37;&#x30;&#51;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1003","date":"2021-03-27T06:16:00.089Z","path":"2021/03/27/pat1003/","text":"1003.我要通过！(20) [数学题]“答案正确”是⾃动判题系统给出的最令⼈欢喜的回复。本题属于PAT的“答案正确”⼤派送 —— 只要读⼊ 的字符串满⾜下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字⺟ A 组 成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字 ⺟ A 组成的字符串。 现在就请你为PAT写⼀个⾃动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输⼊格式： 每个测试输⼊包含1个测试⽤例。第1⾏给出⼀个⾃然数n (&lt;10)，是需要检测的字符串个数。接下来每 个字符串占⼀⾏，字符串⻓度不超过100，且不包含空格。 输出格式： 每个字符串的检测结果占⼀⾏，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。 输⼊样例： 1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例： 12345678YESYESYESYESNONONONO 分析： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本题解析：本题我做的时候是很很难的，即使第二次看也用了一个小时才搞明白，这道题按答案解析，主要在于理解题目，以及如果查找出a，b，c。 首先，题目给出了 3 个很有迷惑性的 “正确答案” 的条件，第 1 条，必须有仅有PAT三种字符很好理解，第二个为 XPATX，X 为空或 ’A‘，”AA“，”AAA“，··· 也好理解。关键第 3 个条件，如果aPbTc是正确的，那么aPbATca正确，也可以继续推第三代，第四代 ···，那么就需要考虑第一代原型是什么，而此时的第二个条件就为原型，且只有第二个条件为原型，这一定要理解，不然这题就废了。这样一看，原型也是有规律的，即b必须为一个A，且原型 a 的A和C的A个数相等，即原型为PAT,APATA,AAPATAA…再将每一个原型代入第三个条件进行推导会发现一个对所有字符串（满足条件1）都适用的规律，即c=a*b。接下来就好多了，一个for循环，判断s[i]==&#39;P&#39;和s[i]==&#39;T&#39;，找出 P 和 T 个数为 1。之后 y&gt;x ,这道题基本难点也讲完了。 1s.find(P)=x,s.dind(y)=y,y&gt;x 本系列(PAT算法)作者mail：&#49;&#51;&#x30;&#50;&#51;&#48;&#52;&#x37;&#48;&#x33;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"MySQL三种常见引擎","date":"2021-03-16T13:48:07.242Z","path":"2021/03/16/Mysql引擎/","text":"MySQL三种常见引擎 一.InnoDB存储引擎InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是 InnoDB。 InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。 InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。 InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。 二.MyISAM存储引擎MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。 MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。 MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。 三.MEMORY存储引擎MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 友链(本篇为理解，没有我写的成分)：https://blog.csdn.net/qq_41118581/article/details/90173117","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://example.com/tags/MYSQL/"}]},{"title":"pat1002","date":"2021-03-12T05:23:22.295Z","path":"2021/03/12/pat1002/","text":"1002. 写出这个数 (20) [字符串处理]读⼊⼀个⾃然数n，计算其各位数字之和，⽤汉语拼⾳写出和的每⼀位数字。 输⼊格式：每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。这⾥保证n⼩于10100。 输出格式： 在⼀⾏内输出n的各位数字之和的每⼀位，拼⾳数字间有1 空格，但⼀⾏中最后⼀个拼⾳数字后没有空 格。 输⼊样例： 11234567890987654321123456789 输出样例： 1yi san wu 分析：⽤string接收输⼊，string的每⼀位数字累加到sum⾥⾯，再将sum转化为string类型的num，对 num的每⼀位输出对应中⽂拼⾳～ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - &#x27;0&#x27;); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; str[num[i] - &#x27;0&#x27;]; &#125; return 0;&#125; 本系列(PAT算法)作者mail：&#49;&#51;&#48;&#x32;&#51;&#x30;&#52;&#x37;&#x30;&#x33;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"pat1001","date":"2021-03-11T15:01:17.326Z","path":"2021/03/11/pat1001/","text":"1001. 害死⼈不偿命的(3n+1)猜想(15) [模拟]卡拉兹(Callatz)猜想： 对任何⼀个⾃然数n，如果它是偶数，那么把它砍掉⼀半；如果它是奇数，那么把(3n+1)砍掉⼀半。这 样⼀直反复砍下去，最后⼀定在某⼀步得到n=1。卡拉兹在1950年的世界数学家⼤会上公布了这个猜 想，传说当时耶鲁⼤学师⽣⻬动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学⽣们⽆⼼学 业，⼀⼼只证(3n+1)，以⾄于有⼈说这是⼀个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题⽬不是证明卡拉兹猜想，⽽是对给定的任⼀不超过1000的正整数n，简单地数⼀下，需要 多少步（砍⼏下）才能得到n=1？ 输⼊格式： 每个测试输⼊包含1个测试⽤例，即给出⾃然数n的值。 输出格式： 输出从n计算到1需要的步数。 输⼊样例： 13 输出样例： 15 分析：count从0开始统计需要的步数，(n % 2 != 0) 表示n为奇数，当n为奇数，就令n = 3*n+1；之后将 其砍掉⼀半，步数count+1，直到n == 1为⽌，最后输出count～ 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int num=0,n; cin &gt;&gt;n; while(n!=1)&#123; if(n%2)n=(3*n+1); n=n/2; num++; &#125; cout&lt;&lt;num; return 0;&#125; 本系列(PAT算法)作者mail：&#x31;&#51;&#x30;&#x32;&#51;&#x30;&#52;&#55;&#x30;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"pat","slug":"pat","permalink":"http://example.com/tags/pat/"}]},{"title":"数据库学习之《mysql必知必会》","date":"2021-02-28T03:32:20.437Z","path":"2021/02/28/数据库学习之《mysql必知必会》/","text":"之前买了一本《MySQL必知必会》，最终拖拖拉拉用来一个星期的时间才把它看完，关于此书我觉得前面没有多大的难度，和《计算机网络自顶向下》 比起 还是很简单的，在我觉得比较困难的是存储过程，触发器的那几章，还有的是懂得了一门语言不是重点，重要的是要会使用和经常使用，这两点我还不行。下面我说说学习《MySQL必知必会》遇到的几个问题。 关于导入《MySQL必知必会》样例表的问题。一开始我并不打算使用这本书的数据库，后来发现有些知识点比较难懂于是又开始去寻找如何下载，下面是我的总结。 首先去网页下载两个SQL脚本文件，所需要获得和运行的一切东西都可以在https://forta.com/books/0672327120 上找到。 之后会有这个 点击自己选择一个名字 如text，则底下会出现一个这个 再接下来点击进入其中选择schemas 创建一个数据源，这一步和简单，你可以选择在命令行中进行，根据MySQL必知必会，选择名字crashcourse比较好， 然后再在菜单栏中，选择File-&gt;Open SQL Script，分别找到create.sql脚本，点击下图位置运行 对于populate.sql文件，重复导入脚本以及运行步骤即可 最后选中数据源并右键，选择Refresh All！！！（很重要） 今天学到了MySQL第十四章，对子查询这一步感到惊叹，能想出这样的方法— 真是老牛下蛋，牛逼坏了。","categories":[],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://example.com/tags/MYSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"用故事讲解md","date":"2021-02-28T03:27:14.304Z","path":"2021/02/28/用故事讲解Markdown/","text":"Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬 John Gruber 和 Aaron Swartz 。2010年，确定了其标准语法 CommonMark，2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站… 人人都应学Markdown1.1Markdown是什么​ Makedown 诞生于2004年，是一个相对于比较新的语言，它是由两位大佬John Gruber和 Aaron Swartz。Makedown本质是一个标记语言，与HTML非常相似，兼容HTML。起初用于网络写作，现在记笔记，写文档，写README.md。2010年，确定了其标准语法 CommonMark，虽然有了定义但是标准语法的核心功能还是太少了，于是不断扩展，知道2017年诞生了我们现在用的最多的一个扩展语法 GFM(GIthub Flavored Markdown)，而Github是全球最大的程序员同性交友网站。 1.2推荐使用​ 需要文字排版但无特殊要求 ​ 可以很方便的转换位Word 1.3如何学习使用Markdown 编写Markdown源码 &gt; 编辑器 &gt; 各种样式 语法学习 2.1基础语法所有标记符号都必须是半角标点符号 标题 语法：”# + 空格 + 标题内容” 行首插入 # “#”的个数=标题的等级 建议在#后面加个空格 支持最多六个标题 粗体和斜体 粗体，由两个*或两个_包裹 斜体，由一个*或一个_包裹 列表 有序列表，数字符号 + 英文句号 + 空格 + 列表内容 有序列表1 有序列表2 无序列表，-*/+/- + 空格 + 列表内容 无序列表1 无序列表2 嵌套列表，下层列表前按Tab键 有序列表和无序列表可以互相嵌套 分割线 三个或三个以上的_来标记 图片 语法，！[图片代替文字](图片地址) 图片替代文字不是必须，可以为空 图片地址，可以是本地路径，也可以是网络路径 本地图片支持相对路径和绝对路径两种 链接 文字链接 语法，[链接文字](链接地址) 链接过多后，可读性变差 引用链接 语法，[链接文字] [链接标记][链接标记]: 链接地址 链接标记可以是字母，数字，空格和标点符号 链接标记不区分大小写 定义的链接可任意位置放置，建议放在页尾 链接地址为网络地址需以http/https开头 网址链接 语法，&lt;url 或邮箱地址&gt; 无需以 http/https 开头 行内代码与代码块 行内代码：用包裹 代码块：以tab键或4个空格开头 1echo &quot;hello word&quot; 引用 语法，&gt; + 引用内容 在引用中可以嵌套引用 在引用中可以使用其他的 Markdown 语法 扩展语法2.1删除线 语法，~~被删除的文字~~ 2.2表情符号 语法，使用:包裹表情代码，:表情代码 表情符号代码，请参考webpagefx，或搜索Markdown emoji code 2.3表格 语法 1234|表头1|表头2|表头3||-|--|---||内容1|内容2|内容3||内容1|内容2|内容3| 表头1 表头2 表头3 内容1 内容2 内容3 内容1 内容2 内容3 2.4任务列表 语法，- + 空格 + [空格] + 空格 +文字内容 未勾选，-[] 已勾选，-[X/x] 语法说明 x可大写或小写，但有些编辑器不支持大写，故推荐使用小写的x 2.5围栏代码块 使用规范 使用连续的3个` 行内代码使用`包裹 1echo &#x27;hello word&#x27; 2.6锚点[锚点描述](#锚点名) 2.7内联数学公式 语法，$数学公式$ 快捷键，control + M $f(x,y)=\\frac{x}{y}$","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"使用命令窗口发送邮件","date":"2021-02-28T03:18:13.645Z","path":"2021/02/28/使用命令窗口发送邮件/","text":"学习笔记之前建立了一个hexo的博客，但是两个月没用出现了，结果出现了’使用子域名作为Github Pages的域名导致访问不了’的问题,对于才接触的我也没有解决的办法，只好重新安装了一个，以后如果再出现这个问题要解决掉，最近正在学计算机网络的应用层感觉用命令窗口发送qq邮箱很有趣，于是打算写一篇关于如何用命令窗口进行与邮件服务器进行链接的文章。我是使用win10 用qq邮箱进行发送的，如果以后有机会用163进行一次。 开启邮箱服务首先先开启qq邮箱的独立密码，进入设置-账户-独立密码，使邮箱开启POP3/SMTP，进入设置-账户-开启服务 接下来打开windows计算机上的telnet服务，打开控制面板-打功选中Telnet客户端、Telnet服务器，然后确定，等待完成 开始发送先打开命令窗口，输入 telnet smtp.qq.com 25,回复220，如果不是查看telnet服务是否开启 接着输入helo qq(后缀.com有时加有时不用)如果成功，服务器返回 250 ，不成功换一下 登录认证输入auth login，，会返回类似于：334 VXNlcm5hbWU6 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车回复334成功，其他失败 如果不知道可以 进行简单的代码运行得到1234import sun.misc.BASE64Encoder;public static void main(String[] args)&#123; System.out.println(Base64.encodeBase(&quot;xxxxx@qq.com&quot;.getBytes())); &#125; 输出即为。输入时如果太麻烦鼠标右键的话会直接粘贴，比较方便。 接下来输入独立密码的base64编码之后的字符串然后回车 回复235 Authentication successful成功，如果失败可能是因为独立密码失效 编写邮件输入 mail from:&lt;你自己的邮箱@qq.com&gt; 回车，成功返回250ok 输入 rcpt to:&lt;收件人邮箱，xxx@xxx.xxx&gt; 回车，成功返回250ok 输入 data 回车，回车后就可以开始写邮件内容了 输入 from：发件人名称 (可任意填) 输入 to：收件人名称(可任意填) 输入 subject：信件主题 在正文输入结束时输入一个.(英文)回车 服务器返回 250 Ok: queues as,表示邮件已经发送","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"翻墙(下)","date":"2021-02-28T02:08:16.679Z","path":"2021/02/28/翻墙(下)/","text":"3、域名劫持 Domain name hijacking一般情况下, 使用浏览器去连接互联网站点时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来。当使用翻墙软件时, 各种翻墙软件是采用在境外服务器和境内服务器之间建立一条安全隧道的方式，借助代理服务器对敏感数据进行加密访问。此时, 浏览器先向代理服务器发出请求, 再由代理服务器取回浏览器所需信息并传送给浏览器。摘自：典型翻墙软件的网络通信特征研究在中国知网查看：点击跳转 域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。 目的是无法访问目标网站，限制在特定的被劫持的网络范围内，是互联网攻击的一种方式。 DNS（Domain Name System，域名bai系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简介定义域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。 域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 原理：域名解析 (DNS) 的基本原理是把网络地址（域名，以一个字符串的形式）对应到真是计算机能够识别的网络地址（IP地址，比如216.239.53.99 这样的形式），以便计算机能够进一步通信，传递网址和内容等。 由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。 过程由于域名劫持只能在特定的网络范围内进行，所以范围外的域名服务器(DNS)能返回正常IP地址。攻击者正是利用此点在范围内封锁正常DNS的IP地址，使用域名劫持技术，通过冒充原域名以E-MAIL方式修改公司的注册域名记录，或将域名转让到其他组织，通过修改注册信息后在所指定的DNS服务器加进该域名记录，让原域名指向另一IP的服务器，让多数网民无法正确访问，从而使得某些用户直接访问到了恶意用户所指定的域名地址，其实施步骤如下： 一、获取劫持域名注册信息：首先攻击者会访问域名查询站点，通过MAKE CHANGES功能，输入要查询的域名以取得该域名注册信息。 二、控制该域名的E-MAIL帐号：此时攻击者会利用社会工程学或暴力破解学进行该E-MAIL密码破解，有能力的攻击者将直接对该E-MAIL进行入侵行为，以获取所需信息。 三、修改注册信息：当攻击者破获了E-MAIL后，会利用相关的MAKE CHANGES功能修改该域名的注册信息，包括拥有者信息，DNS服务器信息等。 四、使用E-MAIL收发确认函：此时的攻击者会在信件帐号的真正拥有者之前，截获网络公司回馈的网络确认注册信息更改件，并进行回件确认，随后网络公司将再次回馈成功修改信件，此时攻击者成功劫持域名。 缺点它不是很稳定，在某些网络速度快的地方，真实的IP地址返回得比窃持软件提供的假地址要快，因为监测和返回这么巨大的数据流量也是要花费一定时间的。 在网上查询域名的正确IP非常容易。一个是利用海外的一些在线IP地址查询服务，可以查找到网站的真实IP地址。在Google上搜索”nslookup”，会找到更多类似的服务。 4、流量限制流量限制是一个名词，指直接限制网络流量。 地位：最严厉的一种流量限制。 限制分类当前的虚拟主机主要分为三类流量限制: 一:流量限制 就是直接限制网络流量,这种限制通常是最严厉的一种流量限制,10个g的流量大体支持50人在线以内.当月流量超过后,在一个月内网站都不能正常访问了,解决办法是升级空间或加大流量! 假设一个网页的大小是10K Byte，那么访问这个网页一次就要产生10K的流量，1G流量就可以访问这个网页 1G/10K=100,000 次。 二:CPU限制 CPU限制看起来没有限IIS或网络流量,但由于每一个程序运行都需要一定的CPU配额,也是变相的流量限制,通常网页显示在线过多都是由于CPU限额过小引起的!通过刷新或15秒后可以得到暂时的正常运行,通常1%的CPU限额相当于20个IIS连接!这对于论坛空间很重要,论坛的CPU限额一旦过小就会不能正常运行! 三:IIS限制 IIS限制是现在用的最多的,也是被大多用户或主机商认可,是唯一宽松的流量限制,通常20个IIS就相当于1%CPU占用! 选择建议虚拟主机实际上没有不限流量的,总的可以分为以上三种方式,您如何选择,要看您的需要,如果您的程序占用CPU很少,是优化的程序可以选择限CPU的,这样您的在线就可以得到最大的发挥,如果您是初学者,或是论坛用户,或网站程序中有BBS,选择IIS限制或直接流量限制是一个好的选择!","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"科幻小说死亡开关在数据方面真的能实现吗？","date":"2021-02-25T05:32:58.542Z","path":"2021/02/25/科幻小说死亡开关在数据方面真的能实现吗？/","text":"每个人的生命只有一次，没人能说清死后的世界是什么样的。 作者 戴维·伊格尔曼（大卫·伊格曼）David Eagleman，生于1971年，美国神经科学家，斯坦福大学副教授，NeoSensory（似乎是一家植入传感器设备公司）的CEO。本篇《死亡开关》选自作者2009年出版的图书《死亡的故事》（Sum: Forty Tales from the afterlives）第二十五章，也曾在《Nature》上发表过（是的，Nature也会接收一些科普和科幻小说），严格来说——这篇与其说是科幻小说，倒不如说是一篇科幻随笔——可以看作是科幻小说的构思，大刘、韩松、吴岩等国内科幻大佬也出版过类似的科幻随笔。 总的来说看了一下，也就是他所写的《死亡的故事》中的一个随笔故事，篇幅几百字左右。里面讲了死亡开关，电脑每周会向你发出密码提示，确认你还活着，如果一段时间过去了，你却一直没有输入密码，那么电脑就会做出你已经死亡的推断，并自动将密码发送给第二号负责人。 人们利用死亡开关将瑞士银行的账号转交给自己的继承人，在争论中强辩到底，或是坦诚道出有生之年无法开口说出的秘密。 我感觉吧，根本不可能实现，信息的积累只会是越来越大，虽然现在是大数据时代，将来将会是巨大数据时代，但是数据的存储也是有限的，如果人们死后会进行数据的积累，那么数据只会越来越大，而且是叠加增长，先前拥有的死亡人的数据会增加，新来的也增加。现如今，世界人口已经增长到75亿人次。根据联合国公布z、的数字，现在的每秒出生的人数平均有5人次，死亡的人数每秒为2人次。也就是说世界人口每秒就增加3人次，那么一分钟就是增加180人次，一小时也就是增加10800人次，以此类推的话，一年大概要增加将近1亿人次。接下来我们再算算死亡人数，每秒2人次，一分钟就是120人次，一小时就是7200人次，同样以此类推，每年死亡的人口大概在6400万人次。一个人只保留1Mb的数据，一年存储数据为64000000MB，64000GB，64T。 计算机报上看到荷兰银行的20个数据中心有大约7PB磁盘和超过20PB的磁带存储，而且每年50%~70%存储量的增长，计算一下27PB大约为 500个64TB的大小，也就是500个第一年开始进行死亡开关这场游戏的数据。 由于是叠加增长，第一年会产生一个64TB 第二年会是第一年产生的，加上新产生的总和，2+1=3 第三年3+2+1=6 第四年4+3+2+1=10 这里我用Java写了一个测试代码，看看500个64TB能够几年使用完 12345678910111213public class HelloWorld &#123; public static void main(String []args) &#123; int num=0; for(int i = 0;;i++)&#123; num = num + i; if(num&gt;500)&#123; System.out.println(i); break; &#125; &#125; &#125;&#125;结果：32 也就是用了32年会将荷兰银行的这些数据存储完，但之后的数据存储会持续叠加上升，为无线等差数列和 等差数列和的函数为n^2，之后看看第二个荷兰银行数据存储会多久存满，结果是第45年，也就是用了13年就会存满，之后会越来越少，等到有一天，n=500的时候，也就会是每天将会存储一个荷兰银行的20个数据中心。 综上所述，我觉得这是一个不现实的问题。 mobi文件mobi是亚马逊的私有格式，目前市面上的 mobi 文件大部分是来自两种途径：epub、pdf 或者 txt 转换成的 mobi，从 Amazon 商店流出来的 mobi。","categories":[],"tags":[{"name":"死亡开关","slug":"死亡开关","permalink":"http://example.com/tags/%E6%AD%BB%E4%BA%A1%E5%BC%80%E5%85%B3/"},{"name":"兴趣","slug":"兴趣","permalink":"http://example.com/tags/%E5%85%B4%E8%B6%A3/"}]},{"title":"翻墙(上)","date":"2021-02-25T02:03:23.942Z","path":"2021/02/25/翻墙(上）/","text":"科普所谓翻墙，是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问。境外公司曾发布几款突破网络封锁以访问海外敏感网站或邮件的翻墙软件。由于此类软件不断升级，要实现对该类软件行为的监测或封锁就显得尤为困难和重要，如果能够在网关处将数据截获，分析数据包的行为特征，将部分数据包进行劫持还原，这将对公安机关的调查取证起到积极的作用。 该解释引自《典型翻墙软件的网络通信特征研究》，作者官国静，此外我还会讲解一下它的这篇文章 由于内容过多下半部分放在了下一篇，想了解关于软件和caj文件解释的可以看看，以下定义摘抄自百度，为了是能够自己了解所以写在了下面，觉得不够详细的可以百度搜索。 1、ip 封锁（IP Block）ip 封锁是指防火墙维护一张 ip 黑名单，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。 缺点：采用黑名单禁止模式有一定的漏洞 目的：屏蔽对目的主机的访问 提供服务的服务器亦可能使用类似的方法，以控制可存取的范围，通常可设定白名单只允许某个网段或某个国家的 ip 存取，也可设定黑名单以禁止某网段或某些国家的 ip 存取。例如一些线上游戏营运商或线上影片服务为确保本国玩家的权益及版权限制，只允许本国的 ip 连线。 缺点这种对被封禁的网站采用黑名单而不是对被允许访问的网站采用白名单的过滤机制，难免会有漏网之鱼的存在。 常见情况封锁 ip — 当计算机或系统受到外部攻击时，管理员可以通过屏蔽攻击源 ip 地址来抵御攻击。通过防火墙和路由器配置，可以封锁某个 ip，禁止与其连接，从而达到抵御攻击的作用。但事实上大多数的攻击，管理员根本没有时间反应，一般在反应过来后系统已经崩溃。 1、多次发布谩骂、侮辱言论； 2、发布大量商业广告、或无用废帖（即 “爆吧” ） 3、其他严重违反贴吧规定的情况。 2、内容过滤content filter内容过滤是对网络内容进行监控，防止某些特定内容在网络上进行传输的技术。主要实现有 软件(点击跳转)和硬件两种。 性质为非营利性，开始启用时间为1995年，含义为对网络内容进行监控。 解释在因特网上，内容过滤（content filtering），也被称作信息过滤（information filtering），是将Web网页或电子邮件中令人讨厌的信息屏蔽和拒绝存取或使用的技术。内容过滤被公司或家用电脑拥有者用作网络防火墙的一部分，尤其是父母可以为他们的孩子屏蔽掉那些不想让其访问的内容。 内容过滤通常使用特征字符串进行工作，如果内容和字符串相符，则会把这部分内容屏蔽掉。被过滤的典型是那些带有色情、暴力、仇恨倾向的内容，==内容过滤程序的批评者指出，它可能在无形中将想要的内容同时过滤掉。== 内容过滤和提供这项服务的产品分为网页过滤——屏蔽网站或页面的信息、邮件过滤——屏蔽电子邮件中的垃圾信息或其它令人讨厌的信息。 方法简介（先软件后硬件）软件过滤方式内容过滤的软件方式主要是一项1995年开始启用的技术标准“Internet内容选择平台”，它是由一家非营利性Internet开放商联盟――万维网联盟(W3C)为解除1995年年末出台的美国《通讯正派条例》(该条例于1997年被否决)的威胁而推出的。Internet内容选择平台的设计理念是鼓励自由表达、保护未成年人的权益，把工具交给父母或其他人，让他们为自己和自己的孩子过滤内容。 这类工具同时还可以将孩子或雇员送出的不恰当信息滤掉，比如家庭地址、信用卡号码、或机密的公司信息等等。 软件过滤主要使用关键词匹配的方式，将特定内容移除。随着互联网应用的开展，软件过滤无法处理飞速增长的流量，于是硬件过滤应运而生。 硬件过滤方式硬件过滤方式就是将关键词匹配功能集成在控制有大量流量的交换机或路由器中，以对网络中的流量进行监控。 目的为防止暴力、恐怖、色情、颠覆主义等内容在互联网上传播，维护网络安全，净化网络，为广大网民提供绿色上网环境。 软件指按照特定顺序组织的计算机数据和指令的集合 软件（中国大陆及香港用语，台湾称作软体，英文：software）是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。软件并不只是包括可以在计算机（这里的计算机是指广义的计算机）上运行的电脑程序，与这些电脑程序相关的文档一般也被认为是软件的一部分。简单的说软件就是程序加文档的集合体。另也泛指社会结构中的管理系统、思想意识形态、思想政治觉悟、法律法规等等。 开发语言为Java、C/C++、Basic、python等 应用类别系统软件、应用软件等 定义国标中对软件的定义为：与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。 其它定义： 1．运行时，能够提供所要求功能和性能的指令或计算机程序集合。 2．程序能够满意地处理信息的数据结构。 3．描述程序功能需求以及程序如何操作和使用所要求的文档。 以开发语言作为描述语言，可以认为：软件=程序+数据+文档 特点1、无形的，没有物理形态，只能通过运行状况来了解功能、特性、和质量 2、软件渗透了大量的脑力劳动，人的逻辑思维、智能活动和技术水平是软件产品的关键 3、软件不会像硬件一样老化磨损，但存在缺陷维护和技术更新 4、软件的开发和运行必须依赖于特定的计算机系统环境，对于硬件有依赖性，为了减少依赖，开发中提出了软件的可移植性 5、软件具有可复用性，软件开发出来很容易被复制，从而形成多个副本 分类应用类别按应用范围划分，一般来讲软件被划分为==系统软件==、==应用软件==和==介于这两者之间的中间件==。 系统软件 系统软件为计算机使用提供最基本的功能，可分为操作系统和支撑软件，其中操作系统是最基本的软件。 系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。 1．操作系统是一管理计算机硬件与软件资源的程序，同时也是计算机系统的内核与基石。操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统交互的操作接口。 2．支撑软件是支撑各种软件的开发与维护的软件，又称为软件开发环境（SDE）。它主要包括环境数据库、各种接口软件和工具组。著名的软件开发环境有IBM公司的Web Sphere,微软公司的等。 包括一系列基本的工具（比如编译器、数据库管理、存储器格式化、文件系统管理、用户身份验证、驱动管理、网络连接等方面的工具）。 应用软件 系统软件并不针对某一特定应用领域，而应用软件则相反，不同的应用软件根据用户和所服务的领域提供不同的功能。 应用软件是为了某种特定的用途而被开发的软件。它可以是一个特定的程序，比如一个图像浏览器。也可以是一组功能联系紧密，可以互相协作的程序的集合，比如微软的Office软件。也可以是一个由众多独立程序组成的庞大的软件系统，比如数据库管理系统。 如今智能手机得到了极大的普及，运行在手机上的应用软件简称手机软件。所谓手机软件就是可以安装在手机上的软件，完善原始系统的不足与个性化。随着科技的发展，手机的功能也越来越多，越来越强大。不是像过去的那么简单死板,发展到了可以和掌上电脑相媲美。手机软件与电脑一样，下载手机软件时还要考虑你购买这一款手机所安装的系统来决定要下相对应的软件。手机主流系统有以下：[Windows Phone](https://baike.baidu.com/item/Windows Phone)、Symbian、iOS、Android。 授权类别不同的软件一般都有对应的软件授权，软件的用户必须在同意所使用软件的许可证的情况下才能够合法的使用软件。从另一方面来讲，特定软件的许可条款也不能够与法律相违背。 依据许可方式的不同，大致可将软件区分为几类： 专属软件：此类授权通常不允许用户随意的复制、研究、修改或散布该软件。违反此类授权通常会有严重的法律责任。传统的商业软件公司会采用此类授权，例如微软的Windows和办公软件。专属软件的源码通常被公司视为私有财产而予以严密的保护。 自由软件：此类授权正好与专属软件相反，赋予用户复制、研究、修改和散布该软件的权利，并提供源码供用户自由使用，仅给予些许的其它限制。以Linux、Firefox 和OpenOffice 可做为此类软件的代表。 共享软件：通常可免费的取得并使用其试用版，但在功能或使用期间上受到限制。开发者会鼓励用户付费以取得功能完整的商业版本。根据共享软件作者的授权，用户可以从各种渠道免费得到它的拷贝，也可以自由传播它。 免费软件：可免费取得和转载，但并不提供源码，也无法修改。 公共软件：原作者已放弃权利，著作权过期，或作者已经不可考究的软件。使用上无任何限制。 相关概念开发流程软件开发是根据用户要求建造出软件系统或者系统中的软件部分的过程。软件开发是一项包括需求捕捉，需求分析，设计，实现和测试的系统工程。软件一般是用某种程序设计语言来实现的。通常采用软件开发工具可以进行开发。 软件开发流程即Software development process。 软件设计思路和方法的一般过程，包括设计软件的功能和实现的算法和方法、软件的总体结构设计和模块设计、编程和调试、程序联调和测试以及编写、提交程序。 1 相关系统分析员和用户初步了解需求，然后列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。 2 系统分析员深入了解和分析需求，根据自己的经验和需求做出一份文档系统的功能需求文档。这次的文档会清楚例用系统大致的大功能模块，大功能模块有哪些小功能模块，并且还例出相关的界面和界面功能。 3 系统分析员和用户再次确认需求。 4 系统分析员根据确认的需求文档所例用的界面和功能需求，用迭代的方式对每个界面或功能做系统的概要设计。 5 系统分析员把写好的概要设计文档给程序员，程序员根据所例出的功能一个一个的编写。 6 测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能，然后验收。 软件工程师一般指从事软件开发职业的人。软件工程师10余年来一直占据高薪职业排行榜的前列，作为高科技行业的代表，技术含量很高，职位的争夺也异常激烈。软件开发是一个系统的过程，需要经过市场需求分析、软件代码编写、软件测试、软件维护等程序。软件开发工程师在整个过程中扮演着非常重要的角色，主要从事根据需求开发项目软件工作。 法律保护计算机软件作为一种知识产品，其要获得法律保护，必须具备以下必要条件： （一）原创性。即软件应该是开发者独立设计、独立编制的编码组合。 （二）可感知性。受保护的软件须固定在某种有形物体上，通过客观手段表达出来并为人们所知悉。 （三）可再现性。即把软件转载在有形物体上的可能性。 著作权归属根据《计算机软件保护条例》第10条的规定，计算机软件著作权归属软件开发者。因此，确定计算机著作权归属的一般原则是“谁开发谁享有著作权”。软件开发者指实际组织进行开发工作，提供工作条件完成软件开发，并对软件承担责任的法人或者非法人单位，以及依靠自己具有的条件完成软件开发，并对软件承担责任的公民。 载体软件的载体可以是硬盘、光盘、U盘、软盘等数据存储设备。 使用许可不同的软件一般都有对应的软件授权，软件的使用者必须在同意所使用软件的许可证的情况下才能够合法的使用软件。 依据许可方式的不同，大致可将软件区分为几类： 专属软件、自由软件、共享软件、免费软件、公共软件。 生命周期软件生命周期是指从软件定义、开发、使用、维护到报废为止的整个过程，一般包括问题定义、可行性分析、需求分析、总体设计、详细设计、编码、测试和维护。 问题定义就是确定开发任务到底“要解决的问题是什么”，系统分析员通过对用户的访问调查，最后得出一份双方都满意的关于问题性质、工程目标和规模的书面报告。 可行性分析就是分析上一个阶段所确定的问题到底“可行吗”，系统分析员对系统要进行更进一步的分析，更准确、更具体地确定工程规模与目标，论证在经济上和技术上是否可行，从而在理解工作范围和代价的基础上，做出软件计划。 需求分析即使对用户要求进行具体分析，明确“目标系统要做什么”，把用户对软件系统的全部要求以需求说明书的形式表达出来。 总体设计就是把软件的功能转化为所需要的体系结构，也就是决定系统的模块结构，并给出模块的相互调用关系、模块间传达的数据及每个模块的功能说明。 详细设计就是决定模块内部的算法与数据结构，也是明确“怎么样具体实现这个系统”。 编码就是选取适合的程序设计语言对每个模板进行编码，并进行模块调试。 测试就是通过各种类型的测试使软件达到预定的要求。 维护就是软件交付给用户使用后，对软件不断查错、纠错和修改，使系统持久地满足用户的需求。 软件的生命周期也可以分为3个大的阶段，分别是计划阶段、开发阶段和维护阶段。 软件生命周期模型软件生命周期模型也称为软件过程模型，反映软件生存周期各个阶段的工作如何组织、衔接，常用的有瀑布模型、原型模型、螺旋模型、增量模型、喷泉模型，还有建造-修补模型、MSF过程模型、快速原型模型。 [1] 常见的软件生命周期模型瀑布模型 有时也称为V模型，它是一种线型顺序模型，是项目自始至终按照一定顺序的步骤从需求分析进展到系统测试直到提交用户使用，它提供了一种结构化的、自顶向下的软件开发方法，每阶段主要工作成果从一个阶段传递到下一个阶段，必须经过严格的评审或测试，以判定是否可以开始下一阶段工作，各阶段相互独立、不重叠。瀑布模型是所有软件生命周期模型的基础。 [1] 原型+瀑布模型 原型模型本身是一个迭代的模型，是为了解决在产品开发的早期阶段存在的不确定性、二义性和不完整性等问题，通过建立原型使开发者进一步确定其应开发的产品，使开发者的想象更具体化，也更易于被客户所理解。原型只是真实系统的一部分或一个模型，完全可能不完成任何有用的事情，通常包括抛弃型和进化型两种，抛弃型指原型建立、分析之后要扔掉，整个系统重新分析和设计；进化型则是对需求的定义较清楚的情形，原型建立之后要保留，作为系逐渐增加的基础，采用进化型一定要重视软件设计的系统性和完整性，并且在质量要求方面没有捷径，因此，对于描述相同的功能，建立进化型原型比建立抛弃型原型所花的时间要多。原型建立确认需求之后采用瀑布模型的方式完成项目开发。 [1] 增量模型 与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 一些大型系统往往需要很多年才能完成或者客户急于实现系统，各子系统往往采用增量开发的模式，先实现核心的产品，即实现基本的需求，但很多补充的特性(其中一些是已知的，另外一些是未知的)在下一期发布。增量模型强调每一个增量均发布一个可操作产品，每个增量构建仍然遵循设计-编码-测试的瀑布模型。 [1] 迭代模型 早在20世纪50年代末期，软件领域中就出现了迭代模型。最早的迭代过程可能被描述为“分段模型”。迭代，包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。所以，在某种程度上，开发迭代是一次完整地经过所有工作流程的过程：（至少包括）需求工作流程、分析设计工作流程、实施工作流程和测试工作流程。 实质上，它类似小型的瀑布式项目。所有的阶段（需求及其它）都可以细分为迭代。每一次的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 [1] 开发语言O语言O语言是一款中文计算机语言（或称套装：O汇编语言、O中间语言、O高级语言） Java语言作为跨平台的语言，可以运行在Windows和Unix/Linux下面，长期成为用户的首选。自JDK6.0以来，整体性能得到了极大的提高，市场使用率超过20%。可能已经达到了其鼎盛时期了，不知道后面能维持多长时间。 易语言（E语言）易语言是一个自主开发，适合国情，不同层次不同专业的人员易学易用的汉语编程语言。易语言降低了广大电脑用户编程的门槛，尤其是根本不懂英文或者英文了解很少的用户，可以通过使用本语言极其快速地进入Windows程序编写的大门。 [2] C/C++语言以上2个作为传统的语言，一直在效率第一的领域发挥着极大的影响力。像Java这类的语言，其核心都是用C/C++写的。在高并发和实时处理，工控等领域更是首选。 习语言习语言即中文版的C语言 Basic美国计算机科学家约翰·凯梅尼和托马斯·库尔茨于1959年研制的一种“初学者通用符号指令代码”，简称BASIC。由于BASIC语言易学易用，它很快就成为流行的计算机语言之一。 PHP同样是跨平台的脚本语言，在网站编程上成为了大家的首选，支持PHP的主机非常便宜，PHP+Linux+MySQL+Apache的组合简单有效。 Perl脚本语言的先驱，其优秀的文本处理能力，特别是正则表达式，成为了以后许多基于网站开发语言(比如PHP,Java,C#)的这方面的基础。 PythonPython是一种面向对象的解释性的计算机程序设计语言，也是一种功能强大而完善的通用型语言，已经具有十多年的发展历史，成熟且稳定。Python 具有脚本语言中最丰富和强大的类库，足以支持绝大多数日常应用。 这种语言具有非常简捷而清晰的语法特点，适合完成各种高层任务，几乎可以在所有的操作系统中运行。 基于这种语言的相关技术正在飞速的发展，用户数量急剧扩大，相关的资源非常多。 C#C#是微软公司发布的一种面向对象的、运行于NET Framework之上的高级程序设计语言，并定于在微软职业开发者论坛(PDC)上登台亮相。C#是微软公司研究员Anders Hejlsberg的最新成果。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、界面，与Java几乎同样的语法，和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM(组件对象模型)是直接集成的，而且它是微软公司.NET Windows网络框架的主角。 JavaScriptJavaScript是一种由Netscape的LiveScript发展而来的脚本语言，主要目的是为了解决服务器终端语言，比如Perl，遗留的速度问题。当时服务端需要对数据进行验证，由于网络速度相当缓慢，只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。 Ruby一种为简单快捷面向对象编程（面向对象程序设计）而创的脚本语言，由日本人松本行弘（まつもとゆきひろ，英译：Yukihiro Matsumoto，外号matz）开发，遵守GPL协议和Ruby License。Ruby的作者认为Ruby &gt; (Smalltalk + Perl) / 2，表示Ruby是一个语法像Smalltalk一样完全面向对象、脚本执行、又有Perl强大的文字处理功能的编程语言。 Fortran在科学计算软件领域，Fortran曾经是最主要的编程语言。比较有代表性的有Fortran 77、Watcom Fortran、NDP Fortran等。 Objective C这是一种运行在苹果公司的[Mac OS X](https://baike.baidu.com/item/Mac OS X/470629)，iOS操作系统上的语言。这两种操作系统的上层图形环境，应用程序编程框架都是使用该语言实现的。随著iPhone,iPad的流行，这种语言也开始在全世界流行。 PascalPascal是一种计算机通用的高级程序设计语言。Pascal的取名是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal。它由瑞士Niklaus Wirth教授于六十年代末设计并创立。Pascal语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。 SwiftSwift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C共同运行于[Mac OS](https://baike.baidu.com/item/Mac OS)和iOS平台，用于搭建基于苹果平台的应用程序。 caj文件caj文件是中国期刊网提供的一种文件格式,现在网络的很多文献都采用了 caj 文件格式。在浏览 caj 格式文件的时候,你也必须使用相应的阅读器才可以,通用的caj阅读器为CAJViewer。","categories":[],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://example.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"日记","date":"2021-02-24T07:59:00.706Z","path":"2021/02/24/时间管理法/","text":"每月小结，看看自己这个月用于什么的时间是多少，如上课，认真学习，玩 同时年度总结，对自己本月进行反思 记录尽可能准确的记录时间被用在了哪里， 统计以每周每个月或每年为单位，统计每件事情用了多少时间 分析，分析在过去这段时间里，哪些运用时间的方法是高效的，哪些是可以改进的 反馈根据自己分析得出的结论做出改变，让自己更加有效的利用时间 记录–》统计–》分析–》反馈要点： 首先是记录的及时性，不要连续做了好几件事情再回过头来一件一件的记，要一事一记，同时要保持时间记录的真实性、准确性。要保证记录的误差不要大于15分钟就可以了。 其次，选择记录的时间段要相对固定并且有代表性，如果你要记录自己在某项相对重复的工作上花费了多少时间，最好是每天固定的时间段来做这项工作，人在固定时段的状态是相对稳定的。 最后你还要根据记录情况，及时调整时间分配计划，在每周或每月总结的时候要找出上一段计划当中实际消耗时间与计划消耗时间之间的差额，然后结合自己的工作效率重新分配下一时间段。 坚持是在时间管理方面必不可少的品质。 时间管理法的五大法则：恰当运用这五大法则，可以让时间管理法不会成为你的一种镣铐，而是成为运用自如的乐器。 不要为了完成工作而放弃自己的兴趣爱好。对作者而说，不论工作有多困难，任务有多繁重，只要他愿意，就一定能在自己预估的时间里按部就班的完成，但事实上，作者并不是像我们想象中的那么从一而终，很多时候它的本质工作，是要为兴趣让路的。没有什么比满足自己的求知欲和好奇重要，与其被迫在完成工作和满足好奇心之间做出选择，不如索性大方拒绝那些必须完成的任务而选择兴趣。 不接受紧急的任务。因为接受紧急的任务可能会因为由于时间仓促而无法做到尽善其美，更重要的是，它会打破你原有的节奏，引起一系列的连锁反应，最后反而是更费时间的。 一累了就马上停止工作去休息。 保证睡眠时间，每天10小时左右。没有这条守则，时间管理方法将永远是纸上谈兵。作者认为，休息是需要规划、记录、安排再规划的，因为这种方法并不是一种间歇性的方法，而是一种长期性的计划，这是一种很容易让人产生压迫感的方法，如果睡的不好，没有足够的休息，当你面对一张慢慢当当的计划表的时候，很容易陷入被计划牵着鼻子走的恶训循环，一旦陷入这样的恶训循环，就离放弃不远了。 把累人的工作和愉快的工作结合在一起。","categories":[],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"}]},{"title":"搭建博客以及优化","date":"2021-02-23T09:09:39.356Z","path":"2021/02/23/搭建博客以及优化/","text":"不会吧不会吧，难道你还没有属于自己的博客？ 目录不显示文章标题，tags标签怎么加，文章截断 标签这个东西可以在我们写完一个博客文章之后在最上方添加，这样比较方便，对应 yilia 主题你会发现没有这个你的文章没有标题，是空白的。 还有一个是文章截断问题，默认是主页显示整篇的文章，写完文章后，用记事本打开，再需要的地方加上截断代码 &lt;!--more--&gt; 图片加载-采用 lazyload 图片懒加载 图片加载只需要两步 配置，在hexo目录下，执行以下命令，插入模块 1npm install hexo-lazyload-image --save 然后在你的 hexo 目录的配置文件 _config.xml 中添加配置： 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片. loadingImg - 图片未加载时的代替图 不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \\themes\\next\\source\\images 目录下, 然后引用时: loadingImg: /images/图片文件名 借鉴的有简书的这位好友，很感谢带给我的帮助，帮我处理了很多日常写博客的问题https://www.jianshu.com/p/f6f19b02c661 还有就是新手们怎么搭建博客，这里推荐一位好友www.codesheep.cn","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]